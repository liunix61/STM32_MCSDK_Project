<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: Motor Control Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Motor Control Interface<div class="ingroups"><a class="el" href="group___m_c_s_d_k.html">MCSDK</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>MC Interface component of the Motor Control SDK.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:motorcontrol_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motorcontrol_8h.html">motorcontrol.h</a></td></tr>
<tr class="memdesc:motorcontrol_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Motor Control Subsystem initialization functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mc__interface_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mc__interface_8h.html">mc_interface.h</a></td></tr>
<tr class="memdesc:mc__interface_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains all definitions and functions prototypes for the MC Interface component of the Motor Control SDK. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:motorcontrol_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motorcontrol_8c.html">motorcontrol.c</a></td></tr>
<tr class="memdesc:motorcontrol_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Motor Control Subsystem initialization functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mc__interface_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mc__interface_8c.html">mc_interface.c</a></td></tr>
<tr class="memdesc:mc__interface_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file provides firmware functions that implement the features of the MC Interface component of the Motor Control SDK: <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga93b37db848f1e9e2f72923b7d6909f1c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a> { <a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1cad4d949d293c5da638085a77923be9150">MCI_BUFFER_EMPTY</a>
, <a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1cae9f26ee1b08e2ff96d23761e60bb9497">MCI_COMMAND_NOT_ALREADY_EXECUTED</a>
, <a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1caa37592c9a61810de56769f10c13b5dc1">MCI_COMMAND_EXECUTED_SUCCESFULLY</a>
, <a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1cad75729ad0b4166e6a4311c44b8926ffd">MCI_COMMAND_EXECUTED_UNSUCCESFULLY</a>
 }</td></tr>
<tr class="separator:ga93b37db848f1e9e2f72923b7d6909f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee9535da22d0d1dd20142e97a5ec175"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga4ee9535da22d0d1dd20142e97a5ec175">MCI_UserCommands_t</a> { <br />
&#160;&#160;<a class="el" href="group___m_c_interface.html#gga4ee9535da22d0d1dd20142e97a5ec175a3a90b9db6d7bd180265e817cccdd51a9">MCI_NOCOMMANDSYET</a>
, <a class="el" href="group___m_c_interface.html#gga4ee9535da22d0d1dd20142e97a5ec175ac6acad2878f334fa351ee3df28ad3ea6">MCI_CMD_EXECSPEEDRAMP</a>
, <a class="el" href="group___m_c_interface.html#gga4ee9535da22d0d1dd20142e97a5ec175a17db3dc4beb4a325b31f28fc333f216e">MCI_CMD_EXECTORQUERAMP</a>
, <a class="el" href="group___m_c_interface.html#gga4ee9535da22d0d1dd20142e97a5ec175a6398c30bb6077549ed6a098131eda5a0">MCI_CMD_SETCURRENTREFERENCES</a>
, <br />
&#160;&#160;<a class="el" href="group___m_c_interface.html#gga4ee9535da22d0d1dd20142e97a5ec175aa01be1fb31e00bd00456e3fba685cdfb">MCI_CMD_SETOPENLOOPCURRENT</a>
, <a class="el" href="group___m_c_interface.html#gga4ee9535da22d0d1dd20142e97a5ec175a3b10fe56da43b90450b9ed3a76588578">MCI_CMD_SETOPENLOOPVOLTAGE</a>
<br />
 }</td></tr>
<tr class="separator:ga4ee9535da22d0d1dd20142e97a5ec175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9c63cc62b4961a5e4ae805cac0abf0c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaf9c63cc62b4961a5e4ae805cac0abf0c">MCI_State_t</a> { <br />
&#160;&#160;<a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca35ac6f5bc5696afc493bfb5067ade0f2">ICLWAIT</a> = 12
, <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> = 0
, <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca8d86de0851abd047aef8c1cbb3c1603b">ALIGNMENT</a> = 2
, <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0caf79f81787f9abf2d722902f0f7cfa8e1">CHARGE_BOOT_CAP</a> = 16
, <br />
&#160;&#160;<a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca4a727c494b6bb2945a8d36fdebbf2cf9">OFFSET_CALIB</a> = 17
, <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca13d000b4d7dc70d90239b7430d1eb6b2">START</a> = 4
, <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0caf3a64d3eaee1db88ef3b6ee9b78047c5">SWITCH_OVER</a> = 19
, <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> = 6
, <br />
&#160;&#160;<a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca679ee5320d66c8322e310daeb2ee99b8">STOP</a> = 8
, <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca481894d1977cdfcf5820b30d0ab39355">FAULT_NOW</a> = 10
, <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca3ddcec004b2a75fa65e7d2d92e7a86f0">FAULT_OVER</a> = 11
, <b>WAIT_STOP_MOTOR</b> = 20
<br />
 }</td></tr>
<tr class="memdesc:gaf9c63cc62b4961a5e4ae805cac0abf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">State_t enum type definition, it lists all the possible state machine states.  <a href="group___m_c_interface.html#gaf9c63cc62b4961a5e4ae805cac0abf0c">More...</a><br /></td></tr>
<tr class="separator:gaf9c63cc62b4961a5e4ae805cac0abf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd997d5aeb82b1a62f65d57731e7b11f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gadd997d5aeb82b1a62f65d57731e7b11f">MCI_DirectCommands_t</a> { <br />
&#160;&#160;<a class="el" href="group___m_c_interface.html#ggadd997d5aeb82b1a62f65d57731e7b11fa0d717fc79b8b65e145af32231869d4a9">MCI_NO_COMMAND</a> = 0
, <a class="el" href="group___m_c_interface.html#ggadd997d5aeb82b1a62f65d57731e7b11fa09f2ac02895a420c9167398412cb0a1a">MCI_START</a>
, <a class="el" href="group___m_c_interface.html#ggadd997d5aeb82b1a62f65d57731e7b11fa8c9c0776127166f26debd1e52f1d0777">MCI_ACK_FAULTS</a>
, <a class="el" href="group___m_c_interface.html#ggadd997d5aeb82b1a62f65d57731e7b11fa919a891beb3830a6954db3c0d0b40412">MCI_MEASURE_OFFSETS</a>
, <br />
&#160;&#160;<a class="el" href="group___m_c_interface.html#ggadd997d5aeb82b1a62f65d57731e7b11fa51154f963d7ffd900d7f489e2b074f64">MCI_ALIGN_ENCODER</a>
, <a class="el" href="group___m_c_interface.html#ggadd997d5aeb82b1a62f65d57731e7b11fa97922b94000013cc76c5dd773882dbdf">MCI_STOP</a>
<br />
 }</td></tr>
<tr class="separator:gadd997d5aeb82b1a62f65d57731e7b11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5c1d915db5adf398cbe27acc15496f7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga5c1d915db5adf398cbe27acc15496f7f">MX_MotorControl_Init</a> (void)</td></tr>
<tr class="memdesc:ga5c1d915db5adf398cbe27acc15496f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and configures the Motor Control Subsystem.  <a href="group___m_c_interface.html#ga5c1d915db5adf398cbe27acc15496f7f">More...</a><br /></td></tr>
<tr class="separator:ga5c1d915db5adf398cbe27acc15496f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69655a488452da04725907b29f3c4d3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga69655a488452da04725907b29f3c4d3e">MCI_Init</a> (MCI_Handle_t *pHandle, <a class="el" href="struct_speedn_torq_ctrl___handle__t.html">SpeednTorqCtrl_Handle_t</a> *pSTC, <a class="el" href="struct_f_o_c_vars__t.html">pFOCVars_t</a> pFOCVars, <a class="el" href="struct_pos_ctrl___handle__t.html">PosCtrl_Handle_t</a> *pPosCtrl, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pPWMHandle)</td></tr>
<tr class="memdesc:ga69655a488452da04725907b29f3c4d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes all the object variables, usually it has to be called once right after object creation. It is also used to assign the state machine object, the speed and torque controller, and the FOC drive object to be used by MC Interface.  <a href="group___m_c_interface.html#ga69655a488452da04725907b29f3c4d3e">More...</a><br /></td></tr>
<tr class="separator:ga69655a488452da04725907b29f3c4d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacfd5ea988bd0b0afe0856836b3ed46e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaacfd5ea988bd0b0afe0856836b3ed46e">MCI_ExecPositionCommand</a> (MCI_Handle_t *pHandle, float FinalPosition, float Duration)</td></tr>
<tr class="memdesc:gaacfd5ea988bd0b0afe0856836b3ed46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set a mechanical position of rotor. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#gaacfd5ea988bd0b0afe0856836b3ed46e">More...</a><br /></td></tr>
<tr class="separator:gaacfd5ea988bd0b0afe0856836b3ed46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181d97fe2b058f2c7c7d8bc15a237bac"><td class="memItemLeft" align="right" valign="top">PosCtrlStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga181d97fe2b058f2c7c7d8bc15a237bac">MCI_GetCtrlPositionState</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga181d97fe2b058f2c7c7d8bc15a237bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the state of the position control.  <a href="group___m_c_interface.html#ga181d97fe2b058f2c7c7d8bc15a237bac">More...</a><br /></td></tr>
<tr class="separator:ga181d97fe2b058f2c7c7d8bc15a237bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bf23abd19413ce92ff75a9d397de9e3"><td class="memItemLeft" align="right" valign="top">AlignStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga7bf23abd19413ce92ff75a9d397de9e3">MCI_GetAlignmentStatus</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga7bf23abd19413ce92ff75a9d397de9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the rotor alignment procedure.  <a href="group___m_c_interface.html#ga7bf23abd19413ce92ff75a9d397de9e3">More...</a><br /></td></tr>
<tr class="separator:ga7bf23abd19413ce92ff75a9d397de9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fede234d630c4d009a5ebc7dfce0fcb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga0fede234d630c4d009a5ebc7dfce0fcb">MCI_GetCurrentPosition</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga0fede234d630c4d009a5ebc7dfce0fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the current position of the rotor.  <a href="group___m_c_interface.html#ga0fede234d630c4d009a5ebc7dfce0fcb">More...</a><br /></td></tr>
<tr class="separator:ga0fede234d630c4d009a5ebc7dfce0fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c36b4534a5f443198f88e8069c0e0f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gad0c36b4534a5f443198f88e8069c0e0f">MCI_GetTargetPosition</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gad0c36b4534a5f443198f88e8069c0e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the final position asked to the motor.  <a href="group___m_c_interface.html#gad0c36b4534a5f443198f88e8069c0e0f">More...</a><br /></td></tr>
<tr class="separator:gad0c36b4534a5f443198f88e8069c0e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6548573a31cadd84d87450099bb0be1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gab6548573a31cadd84d87450099bb0be1">MCI_GetMoveDuration</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gab6548573a31cadd84d87450099bb0be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the total movement duration to reach the final position.  <a href="group___m_c_interface.html#gab6548573a31cadd84d87450099bb0be1">More...</a><br /></td></tr>
<tr class="separator:gab6548573a31cadd84d87450099bb0be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f88751260207da7605e934f1086d09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga63f88751260207da7605e934f1086d09">MCI_ExecBufferedCommands</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga63f88751260207da7605e934f1086d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is usually a method managed by task. It must be called periodically in order to check the status of the related pSTM object and eventually to execute the buffered command if the condition occurs.  <a href="group___m_c_interface.html#ga63f88751260207da7605e934f1086d09">More...</a><br /></td></tr>
<tr class="separator:ga63f88751260207da7605e934f1086d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5473dc15507bfd0f73951f0d4c3f819b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga5473dc15507bfd0f73951f0d4c3f819b">MCI_ExecSpeedRamp</a> (MCI_Handle_t *pHandle, int16_t hFinalSpeed, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga5473dc15507bfd0f73951f0d4c3f819b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set a motor speed ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#ga5473dc15507bfd0f73951f0d4c3f819b">More...</a><br /></td></tr>
<tr class="separator:ga5473dc15507bfd0f73951f0d4c3f819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb7e1d924def8953ec0aa4493ba4bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga8fb7e1d924def8953ec0aa4493ba4bcb">MCI_ExecSpeedRamp_F</a> (MCI_Handle_t *pHandle, const float FinalSpeed, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga8fb7e1d924def8953ec0aa4493ba4bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set a motor speed ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#ga8fb7e1d924def8953ec0aa4493ba4bcb">More...</a><br /></td></tr>
<tr class="separator:ga8fb7e1d924def8953ec0aa4493ba4bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814b9ec4c7b544c5fd86a94d4a69b240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga814b9ec4c7b544c5fd86a94d4a69b240">MCI_ExecTorqueRamp</a> (MCI_Handle_t *pHandle, int16_t hFinalTorque, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga814b9ec4c7b544c5fd86a94d4a69b240"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set a motor torque ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#ga814b9ec4c7b544c5fd86a94d4a69b240">More...</a><br /></td></tr>
<tr class="separator:ga814b9ec4c7b544c5fd86a94d4a69b240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f87a17408f48585e42d8b4f531a4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga77f87a17408f48585e42d8b4f531a4e8">MCI_ExecTorqueRamp_F</a> (MCI_Handle_t *pHandle, float FinalTorque, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga77f87a17408f48585e42d8b4f531a4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set a motor torque ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#ga77f87a17408f48585e42d8b4f531a4e8">More...</a><br /></td></tr>
<tr class="separator:ga77f87a17408f48585e42d8b4f531a4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab344cb878cf4f37b34df807cb50a5da5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gab344cb878cf4f37b34df807cb50a5da5">MCI_SetCurrentReferences</a> (MCI_Handle_t *pHandle, <a class="el" href="structqd__t.html">qd_t</a> Iqdref)</td></tr>
<tr class="memdesc:gab344cb878cf4f37b34df807cb50a5da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#gab344cb878cf4f37b34df807cb50a5da5">More...</a><br /></td></tr>
<tr class="separator:gab344cb878cf4f37b34df807cb50a5da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b6a07cf328155f032fa068e9e04d09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gae8b6a07cf328155f032fa068e9e04d09">MCI_SetCurrentReferences_F</a> (MCI_Handle_t *pHandle, <a class="el" href="structqd__f__t.html">qd_f_t</a> IqdRef)</td></tr>
<tr class="memdesc:gae8b6a07cf328155f032fa068e9e04d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#gae8b6a07cf328155f032fa068e9e04d09">More...</a><br /></td></tr>
<tr class="separator:gae8b6a07cf328155f032fa068e9e04d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad492e094c58042efe4f837fc62a9d887"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gad492e094c58042efe4f837fc62a9d887">MCI_StartMotor</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gad492e094c58042efe4f837fc62a9d887"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to begin the start-up procedure. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value. Before calling MCI_StartMotor it is mandatory to execute one of these commands:<br  />
 MCI_ExecSpeedRamp<br  />
 MCI_ExecTorqueRamp<br  />
 MCI_SetCurrentReferences<br  />
 Otherwise the behavior in run state will be unpredictable.<br  />
 <b>Note:</b> The MCI_StartMotor command is used just to begin the start-up procedure moving the state machine from IDLE state to IDLE_START. The command MCI_StartMotor is not blocking the execution of project until the motor is really running; to do this, the user have to check the state machine and verify that the RUN state (or any other state) has been reached.  <a href="group___m_c_interface.html#gad492e094c58042efe4f837fc62a9d887">More...</a><br /></td></tr>
<tr class="separator:gad492e094c58042efe4f837fc62a9d887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ffe756795656f7300d3fe4d3a0a3db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga39ffe756795656f7300d3fe4d3a0a3db">MCI_StartOffsetMeasurments</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga39ffe756795656f7300d3fe4d3a0a3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to begin the phase offset calibration procedure. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_StartOffsetMeasurments command is used to begin phase offset calibration procedure moving the state machine from IDLE state to OFFSET_CALIB. The command MCI_StartOffsetMeasurments is not blocking the execution of project until the measurments are done; to do this, the user have to check the state machine and verify that the IDLE state (or any other state) has been reached.  <a href="group___m_c_interface.html#ga39ffe756795656f7300d3fe4d3a0a3db">More...</a><br /></td></tr>
<tr class="separator:ga39ffe756795656f7300d3fe4d3a0a3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb63fd6e9f2537de867d2f976cae29e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaeb63fd6e9f2537de867d2f976cae29e2">MCI_GetCalibratedOffsetsMotor</a> (MCI_Handle_t *pHandle, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *PolarizationOffsets)</td></tr>
<tr class="memdesc:gaeb63fd6e9f2537de867d2f976cae29e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to get the phase offset values. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_GetCalibratedOffsetsMotor command is used to get the phase offset values .  <a href="group___m_c_interface.html#gaeb63fd6e9f2537de867d2f976cae29e2">More...</a><br /></td></tr>
<tr class="separator:gaeb63fd6e9f2537de867d2f976cae29e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5baf843ad8a1d5d1f624c204932e36df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga5baf843ad8a1d5d1f624c204932e36df">MCI_SetCalibratedOffsetsMotor</a> (MCI_Handle_t *pHandle, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *PolarizationOffsets)</td></tr>
<tr class="memdesc:ga5baf843ad8a1d5d1f624c204932e36df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to set the phase offset values. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_SetCalibratedOffsetsMotor command is used to set the phase offset values . The command MCI_SetCalibratedOffsetsMotor is not blocking the execution of project until the measurments are done; to do this, the user have to check the state machine and verify that the IDLE state (or any other state) has been reached.  <a href="group___m_c_interface.html#ga5baf843ad8a1d5d1f624c204932e36df">More...</a><br /></td></tr>
<tr class="separator:ga5baf843ad8a1d5d1f624c204932e36df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f963eae914e2d3b9016b3f417750fcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga6f963eae914e2d3b9016b3f417750fcf">MCI_StopMotor</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga6f963eae914e2d3b9016b3f417750fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to begin the stop motor procedure. If the state machine is in RUN or START states the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_StopMotor command is used just to begin the stop motor procedure moving the state machine to ANY_STOP. The command MCI_StopMotor is not blocking the execution of project until the motor is really stopped; to do this, the user have to check the state machine and verify that the IDLE state has been reached again.  <a href="group___m_c_interface.html#ga6f963eae914e2d3b9016b3f417750fcf">More...</a><br /></td></tr>
<tr class="separator:ga6f963eae914e2d3b9016b3f417750fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a392f725376b9c09ef5eec6dce12558"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga7a392f725376b9c09ef5eec6dce12558">MCI_FaultAcknowledged</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga7a392f725376b9c09ef5eec6dce12558"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to indicate that the user has seen the error condition. If is possible, the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.  <a href="group___m_c_interface.html#ga7a392f725376b9c09ef5eec6dce12558">More...</a><br /></td></tr>
<tr class="separator:ga7a392f725376b9c09ef5eec6dce12558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63c760c5c7905a21faa1cfa9acb414d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gae63c760c5c7905a21faa1cfa9acb414d">MCI_FaultProcessing</a> (MCI_Handle_t *pHandle, uint16_t hSetErrors, uint16_t hResetErrors)</td></tr>
<tr class="memdesc:gae63c760c5c7905a21faa1cfa9acb414d"><td class="mdescLeft">&#160;</td><td class="mdescRight">It clocks both HW and SW faults processing and update the state machine accordingly with hSetErrors, hResetErrors and present state. Refer to State_t description for more information about fault states.  <a href="group___m_c_interface.html#gae63c760c5c7905a21faa1cfa9acb414d">More...</a><br /></td></tr>
<tr class="separator:gae63c760c5c7905a21faa1cfa9acb414d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e95a73280381a6fb788a119816fcba"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga09e95a73280381a6fb788a119816fcba">MCI_GetFaultState</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga09e95a73280381a6fb788a119816fcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns two 16 bit fields containing information about both faults currently present and faults historically occurred since the state machine has been moved into state.  <a href="group___m_c_interface.html#ga09e95a73280381a6fb788a119816fcba">More...</a><br /></td></tr>
<tr class="separator:ga09e95a73280381a6fb788a119816fcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga270f7a86c8bd9da7dc263b5d55ca7de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga270f7a86c8bd9da7dc263b5d55ca7de0">MCI_IsCommandAcknowledged</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga270f7a86c8bd9da7dc263b5d55ca7de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the state of the last buffered command.  <a href="group___m_c_interface.html#ga270f7a86c8bd9da7dc263b5d55ca7de0">More...</a><br /></td></tr>
<tr class="separator:ga270f7a86c8bd9da7dc263b5d55ca7de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf0790ece81c2c29bddb5060ab0e5cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_interface.html#gaf9c63cc62b4961a5e4ae805cac0abf0c">MCI_State_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaaf0790ece81c2c29bddb5060ab0e5cdb">MCI_GetSTMState</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaaf0790ece81c2c29bddb5060ab0e5cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the state of the related pSTM object.  <a href="group___m_c_interface.html#gaaf0790ece81c2c29bddb5060ab0e5cdb">More...</a><br /></td></tr>
<tr class="separator:gaaf0790ece81c2c29bddb5060ab0e5cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b5b555595ad7704c61f7eb6cf831c8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaf9b5b555595ad7704c61f7eb6cf831c8">MCI_GetOccurredFaults</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaf9b5b555595ad7704c61f7eb6cf831c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a 16 bit fields containing information about faults historically occurred since the state machine has been moved into FAULT_NOW state. <br  />
<a class="el" href="">Returned error codes are listed here </a>.  <a href="group___m_c_interface.html#gaf9b5b555595ad7704c61f7eb6cf831c8">More...</a><br /></td></tr>
<tr class="separator:gaf9b5b555595ad7704c61f7eb6cf831c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bdc250e3e00f5da65cdb84628f6105"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga92bdc250e3e00f5da65cdb84628f6105">MCI_GetCurrentFaults</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga92bdc250e3e00f5da65cdb84628f6105"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a 16 bit fields containing information about faults currently present. <br  />
<a class="el" href="">Returned error codes are listed here </a>.  <a href="group___m_c_interface.html#ga92bdc250e3e00f5da65cdb84628f6105">More...</a><br /></td></tr>
<tr class="separator:ga92bdc250e3e00f5da65cdb84628f6105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f5e2d87cfc9de98f630bdf13532629a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga4f5e2d87cfc9de98f630bdf13532629a">MCI_GetMecSpeedRef_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga4f5e2d87cfc9de98f630bdf13532629a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mechanical rotor speed reference expressed in rpm.  <a href="group___m_c_interface.html#ga4f5e2d87cfc9de98f630bdf13532629a">More...</a><br /></td></tr>
<tr class="separator:ga4f5e2d87cfc9de98f630bdf13532629a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e99e9c430199980dd226586cf3dca9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaf3e99e9c430199980dd226586cf3dca9">MCI_GetAvrgMecSpeed_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaf3e99e9c430199980dd226586cf3dca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical speed, expressed in rpm and related to the sensor actually used by FOC algorithm.  <a href="group___m_c_interface.html#gaf3e99e9c430199980dd226586cf3dca9">More...</a><br /></td></tr>
<tr class="separator:gaf3e99e9c430199980dd226586cf3dca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935749f2eeaf420fd2e8e45641d45845"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c___type.html#ga93791db1e1974fe42cab1e0a9c35e21e">MC_ControlMode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga935749f2eeaf420fd2e8e45641d45845">MCI_GetControlMode</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga935749f2eeaf420fd2e8e45641d45845"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the modality of the speed and torque controller.  <a href="group___m_c_interface.html#ga935749f2eeaf420fd2e8e45641d45845">More...</a><br /></td></tr>
<tr class="separator:ga935749f2eeaf420fd2e8e45641d45845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9886422959d033fed61981d8b5985e00"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga9886422959d033fed61981d8b5985e00">MCI_GetImposedMotorDirection</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga9886422959d033fed61981d8b5985e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the motor direction imposed by the last command (MCI_ExecSpeedRamp, MCI_ExecTorqueRamp or MCI_SetCurrentReferences).  <a href="group___m_c_interface.html#ga9886422959d033fed61981d8b5985e00">More...</a><br /></td></tr>
<tr class="separator:ga9886422959d033fed61981d8b5985e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dba057c41bc1e019941d9cfe9a54bd5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga6dba057c41bc1e019941d9cfe9a54bd5">MCI_GetLastRampFinalSpeed</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga6dba057c41bc1e019941d9cfe9a54bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the last ramp final speed sent by the user expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>.  <a href="group___m_c_interface.html#ga6dba057c41bc1e019941d9cfe9a54bd5">More...</a><br /></td></tr>
<tr class="separator:ga6dba057c41bc1e019941d9cfe9a54bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447b945f2d2df284a1140546e1de2926"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga447b945f2d2df284a1140546e1de2926">MCI_GetLastRampFinalTorque</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga447b945f2d2df284a1140546e1de2926"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the last ramp final torque sent by the user .This value represents actually the Iq current expressed in digit.  <a href="group___m_c_interface.html#ga447b945f2d2df284a1140546e1de2926">More...</a><br /></td></tr>
<tr class="separator:ga447b945f2d2df284a1140546e1de2926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898c0949556c7de262e96226a27a460b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga898c0949556c7de262e96226a27a460b">MCI_GetLastRampFinalDuration</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga898c0949556c7de262e96226a27a460b"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the last ramp Duration sent by the user .  <a href="group___m_c_interface.html#ga898c0949556c7de262e96226a27a460b">More...</a><br /></td></tr>
<tr class="separator:ga898c0949556c7de262e96226a27a460b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f7ba74a795eb1d19e761eceb0269545"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga1f7ba74a795eb1d19e761eceb0269545">MCI_RampCompleted</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga1f7ba74a795eb1d19e761eceb0269545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the settled speed or torque ramp has been completed.  <a href="group___m_c_interface.html#ga1f7ba74a795eb1d19e761eceb0269545">More...</a><br /></td></tr>
<tr class="separator:ga1f7ba74a795eb1d19e761eceb0269545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga074bf76ebd1fb259b5c14b65da7b034c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga074bf76ebd1fb259b5c14b65da7b034c">MCI_GetLastRampFinalSpeed_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga074bf76ebd1fb259b5c14b65da7b034c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns last ramp final speed expressed in rpm.  <a href="group___m_c_interface.html#ga074bf76ebd1fb259b5c14b65da7b034c">More...</a><br /></td></tr>
<tr class="separator:ga074bf76ebd1fb259b5c14b65da7b034c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b7a23eacfd8e188e12ed2eb2011ddfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga8b7a23eacfd8e188e12ed2eb2011ddfd">MCI_StopSpeedRamp</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga8b7a23eacfd8e188e12ed2eb2011ddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the execution of speed ramp.  <a href="group___m_c_interface.html#ga8b7a23eacfd8e188e12ed2eb2011ddfd">More...</a><br /></td></tr>
<tr class="separator:ga8b7a23eacfd8e188e12ed2eb2011ddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cc1abd8dee123a6b77da7d9d6e16d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga98cc1abd8dee123a6b77da7d9d6e16d5">MCI_StopRamp</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga98cc1abd8dee123a6b77da7d9d6e16d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the execution of ongoing ramp.  <a href="group___m_c_interface.html#ga98cc1abd8dee123a6b77da7d9d6e16d5">More...</a><br /></td></tr>
<tr class="separator:ga98cc1abd8dee123a6b77da7d9d6e16d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a794dcdafd274d25bf7f05584a48c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga82a794dcdafd274d25bf7f05584a48c4">MCI_GetSpdSensorReliability</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga82a794dcdafd274d25bf7f05584a48c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns speed sensor reliability with reference to the sensor actually used for reference frame transformation.  <a href="group___m_c_interface.html#ga82a794dcdafd274d25bf7f05584a48c4">More...</a><br /></td></tr>
<tr class="separator:ga82a794dcdafd274d25bf7f05584a48c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab710f9661e807ac5a6761527c4391544"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gab710f9661e807ac5a6761527c4391544">MCI_GetAvrgMecSpeedUnit</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gab710f9661e807ac5a6761527c4391544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical speed, expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a> and related to the sensor actually used by FOC algorithm.  <a href="group___m_c_interface.html#gab710f9661e807ac5a6761527c4391544">More...</a><br /></td></tr>
<tr class="separator:gab710f9661e807ac5a6761527c4391544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f95aea22785ac8c5bc2c86abf0efeb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gac2f95aea22785ac8c5bc2c86abf0efeb">MCI_GetMecSpeedRefUnit</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gac2f95aea22785ac8c5bc2c86abf0efeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mechanical rotor speed reference expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>.  <a href="group___m_c_interface.html#gac2f95aea22785ac8c5bc2c86abf0efeb">More...</a><br /></td></tr>
<tr class="separator:gac2f95aea22785ac8c5bc2c86abf0efeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b7dc42e7f107903289624badb1bba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structab__t.html">ab_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga35b7dc42e7f107903289624badb1bba3">MCI_GetIab</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga35b7dc42e7f107903289624badb1bba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Iab in <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format.  <a href="group___m_c_interface.html#ga35b7dc42e7f107903289624badb1bba3">More...</a><br /></td></tr>
<tr class="separator:ga35b7dc42e7f107903289624badb1bba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b9e2359f164c3acaac0acbdd2d326e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalphabeta__t.html">alphabeta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga82b9e2359f164c3acaac0acbdd2d326e">MCI_GetIalphabeta</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga82b9e2359f164c3acaac0acbdd2d326e"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Ialphabeta in <a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a> format.  <a href="group___m_c_interface.html#ga82b9e2359f164c3acaac0acbdd2d326e">More...</a><br /></td></tr>
<tr class="separator:ga82b9e2359f164c3acaac0acbdd2d326e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37366425df4914d275b634d494ea73e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga37366425df4914d275b634d494ea73e6">MCI_GetIqd</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga37366425df4914d275b634d494ea73e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Iqd in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format.  <a href="group___m_c_interface.html#ga37366425df4914d275b634d494ea73e6">More...</a><br /></td></tr>
<tr class="separator:ga37366425df4914d275b634d494ea73e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad7b16f781148d636a632daf23e7192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__f__t.html">qd_f_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga3ad7b16f781148d636a632daf23e7192">MCI_GetIqd_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga3ad7b16f781148d636a632daf23e7192"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Iqd in float format.  <a href="group___m_c_interface.html#ga3ad7b16f781148d636a632daf23e7192">More...</a><br /></td></tr>
<tr class="separator:ga3ad7b16f781148d636a632daf23e7192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7343a99d44efa034e47d4da80a5a4b88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga7343a99d44efa034e47d4da80a5a4b88">MCI_GetIqdHF</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga7343a99d44efa034e47d4da80a5a4b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current IqdHF in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format.  <a href="group___m_c_interface.html#ga7343a99d44efa034e47d4da80a5a4b88">More...</a><br /></td></tr>
<tr class="separator:ga7343a99d44efa034e47d4da80a5a4b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf753a851af454331a28ca987ff102e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaadf753a851af454331a28ca987ff102e">MCI_GetIqdref</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaadf753a851af454331a28ca987ff102e"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Iqdref in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format.  <a href="group___m_c_interface.html#gaadf753a851af454331a28ca987ff102e">More...</a><br /></td></tr>
<tr class="separator:gaadf753a851af454331a28ca987ff102e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab44c7762ef38aeca587677b4ab18150c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__f__t.html">qd_f_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gab44c7762ef38aeca587677b4ab18150c">MCI_GetIqdref_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gab44c7762ef38aeca587677b4ab18150c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Iqdref in float format.  <a href="group___m_c_interface.html#gab44c7762ef38aeca587677b4ab18150c">More...</a><br /></td></tr>
<tr class="separator:gab44c7762ef38aeca587677b4ab18150c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca2bfbc6b48738362566561c5c95c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga8ca2bfbc6b48738362566561c5c95c53">MCI_GetVqd</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga8ca2bfbc6b48738362566561c5c95c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Vqd in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format.  <a href="group___m_c_interface.html#ga8ca2bfbc6b48738362566561c5c95c53">More...</a><br /></td></tr>
<tr class="separator:ga8ca2bfbc6b48738362566561c5c95c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5cf86931dd0ad217d3c4f61db97a173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalphabeta__t.html">alphabeta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gac5cf86931dd0ad217d3c4f61db97a173">MCI_GetValphabeta</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gac5cf86931dd0ad217d3c4f61db97a173"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Valphabeta in <a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a> format.  <a href="group___m_c_interface.html#gac5cf86931dd0ad217d3c4f61db97a173">More...</a><br /></td></tr>
<tr class="separator:gac5cf86931dd0ad217d3c4f61db97a173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b06d6e8bb35763b772053d562683b0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga40b06d6e8bb35763b772053d562683b0">MCI_GetElAngledpp</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga40b06d6e8bb35763b772053d562683b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the rotor electrical angle actually used for reference frame transformation.  <a href="group___m_c_interface.html#ga40b06d6e8bb35763b772053d562683b0">More...</a><br /></td></tr>
<tr class="separator:ga40b06d6e8bb35763b772053d562683b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf25e2edb6c1d3a10151aefe667ab7be7"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaf25e2edb6c1d3a10151aefe667ab7be7">MCI_GetTeref</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaf25e2edb6c1d3a10151aefe667ab7be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the reference electrical torque, fed to derived class for Iqref and Idref computation.  <a href="group___m_c_interface.html#gaf25e2edb6c1d3a10151aefe667ab7be7">More...</a><br /></td></tr>
<tr class="separator:gaf25e2edb6c1d3a10151aefe667ab7be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b153b3b81542f3064a0fbbb0222d2c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga62b153b3b81542f3064a0fbbb0222d2c">MCI_GetTeref_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga62b153b3b81542f3064a0fbbb0222d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the reference electrical torque.  <a href="group___m_c_interface.html#ga62b153b3b81542f3064a0fbbb0222d2c">More...</a><br /></td></tr>
<tr class="separator:ga62b153b3b81542f3064a0fbbb0222d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03dddcb5e831e3fe9c757b6361a2ba3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaa03dddcb5e831e3fe9c757b6361a2ba3">MCI_GetPhaseCurrentAmplitude</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaa03dddcb5e831e3fe9c757b6361a2ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the motor phase current amplitude (0-to-peak) in s16A To convert s16A into Ampere following formula must be used: Current(Amp) = [Current(s16A) * Vdd micro] / [65536 * Rshunt * Aop].  <a href="group___m_c_interface.html#gaa03dddcb5e831e3fe9c757b6361a2ba3">More...</a><br /></td></tr>
<tr class="separator:gaa03dddcb5e831e3fe9c757b6361a2ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6fb1fccbd5db7e843bd723ceecd72f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga4a6fb1fccbd5db7e843bd723ceecd72f">MCI_GetPhaseVoltageAmplitude</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga4a6fb1fccbd5db7e843bd723ceecd72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the applied motor phase voltage amplitude (0-to-peak) in s16V. To convert s16V into Volts following formula must be used: PhaseVoltage(V) = [PhaseVoltage(s16A) * Vbus(V)] /[sqrt(3) *32767].  <a href="group___m_c_interface.html#ga4a6fb1fccbd5db7e843bd723ceecd72f">More...</a><br /></td></tr>
<tr class="separator:ga4a6fb1fccbd5db7e843bd723ceecd72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cb1a3c43b9bad27bb32495d318e33bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga6cb1a3c43b9bad27bb32495d318e33bd">MCI_Clear_Iqdref</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga6cb1a3c43b9bad27bb32495d318e33bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">It re-initializes Iqdref variables with their default values.  <a href="group___m_c_interface.html#ga6cb1a3c43b9bad27bb32495d318e33bd">More...</a><br /></td></tr>
<tr class="separator:ga6cb1a3c43b9bad27bb32495d318e33bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb5999bf96250ab31a25db5c3acdb969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gabb5999bf96250ab31a25db5c3acdb969">MCI_SetSpeedMode</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gabb5999bf96250ab31a25db5c3acdb969"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#gabb5999bf96250ab31a25db5c3acdb969">More...</a><br /></td></tr>
<tr class="separator:gabb5999bf96250ab31a25db5c3acdb969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a4dbccd507057d014e57bd4e08ecab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga77a4dbccd507057d014e57bd4e08ecab">MCI_SetOpenLoopCurrent</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga77a4dbccd507057d014e57bd4e08ecab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#ga77a4dbccd507057d014e57bd4e08ecab">More...</a><br /></td></tr>
<tr class="separator:ga77a4dbccd507057d014e57bd4e08ecab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab539f38639a4b63e3b26aa4b5bcbf300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gab539f38639a4b63e3b26aa4b5bcbf300">MCI_SetOpenLoopVoltage</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gab539f38639a4b63e3b26aa4b5bcbf300"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#gab539f38639a4b63e3b26aa4b5bcbf300">More...</a><br /></td></tr>
<tr class="separator:gab539f38639a4b63e3b26aa4b5bcbf300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a50cbb7839903d8d48256dc631242e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga36a50cbb7839903d8d48256dc631242e">MCI_GetDutyCycleRef</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga36a50cbb7839903d8d48256dc631242e"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the reference eletrical torque, fed to derived class for Iqref and Idref computation.  <a href="group___m_c_interface.html#ga36a50cbb7839903d8d48256dc631242e">More...</a><br /></td></tr>
<tr class="separator:ga36a50cbb7839903d8d48256dc631242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc7c207ed92d6ed2ce1457da51317e4"><td class="memItemLeft" align="right" valign="top">__weak bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gadcc7c207ed92d6ed2ce1457da51317e4">MCI_StartWithMeasurementOffset</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gadcc7c207ed92d6ed2ce1457da51317e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to begin the start-up procedure with an offset calibration even if it has been already done previously. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value. Before calling MCI_StartWithMeasurementOffset it is mandatory to execute one of these commands:<br  />
 MCI_ExecSpeedRamp<br  />
 MCI_ExecTorqueRamp<br  />
 MCI_SetCurrentReferences<br  />
 Otherwise the behaviour in run state will be unpredictable.<br  />
 <b>Note:</b> The MCI_StartWithMeasurementOffset command is used just to begin the start-up procedure moving the state machine from IDLE state to IDLE_START. The command MCI_StartWithMeasurementOffset is not blocking the execution of project until the motor is really running; to do this, the user have to check the state machine and verify that the RUN state (or any other state) has been reached.  <a href="group___m_c_interface.html#gadcc7c207ed92d6ed2ce1457da51317e4">More...</a><br /></td></tr>
<tr class="separator:gadcc7c207ed92d6ed2ce1457da51317e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >MC Interface component of the Motor Control SDK. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga93b37db848f1e9e2f72923b7d6909f1c" name="ga93b37db848f1e9e2f72923b7d6909f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b37db848f1e9e2f72923b7d6909f1c">&#9670;&#160;</a></span>MCI_CommandState_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga93b37db848f1e9e2f72923b7d6909f1cad4d949d293c5da638085a77923be9150" name="gga93b37db848f1e9e2f72923b7d6909f1cad4d949d293c5da638085a77923be9150"></a>MCI_BUFFER_EMPTY&#160;</td><td class="fielddoc"><p >If no buffered command has been called. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga93b37db848f1e9e2f72923b7d6909f1cae9f26ee1b08e2ff96d23761e60bb9497" name="gga93b37db848f1e9e2f72923b7d6909f1cae9f26ee1b08e2ff96d23761e60bb9497"></a>MCI_COMMAND_NOT_ALREADY_EXECUTED&#160;</td><td class="fielddoc"><p >If the buffered command condition hasn't already occurred. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga93b37db848f1e9e2f72923b7d6909f1caa37592c9a61810de56769f10c13b5dc1" name="gga93b37db848f1e9e2f72923b7d6909f1caa37592c9a61810de56769f10c13b5dc1"></a>MCI_COMMAND_EXECUTED_SUCCESFULLY&#160;</td><td class="fielddoc"><p >If the buffered command has been executed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga93b37db848f1e9e2f72923b7d6909f1cad75729ad0b4166e6a4311c44b8926ffd" name="gga93b37db848f1e9e2f72923b7d6909f1cad75729ad0b4166e6a4311c44b8926ffd"></a>MCI_COMMAND_EXECUTED_UNSUCCESFULLY&#160;</td><td class="fielddoc"><p >If the buffered command has been executed unsuccessfully. </p>
</td></tr>
</table>

</div>
</div>
<a id="gadd997d5aeb82b1a62f65d57731e7b11f" name="gadd997d5aeb82b1a62f65d57731e7b11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd997d5aeb82b1a62f65d57731e7b11f">&#9670;&#160;</a></span>MCI_DirectCommands_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___m_c_interface.html#gadd997d5aeb82b1a62f65d57731e7b11f">MCI_DirectCommands_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadd997d5aeb82b1a62f65d57731e7b11fa0d717fc79b8b65e145af32231869d4a9" name="ggadd997d5aeb82b1a62f65d57731e7b11fa0d717fc79b8b65e145af32231869d4a9"></a>MCI_NO_COMMAND&#160;</td><td class="fielddoc"><p >No Command &mdash; Set when going to IDLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd997d5aeb82b1a62f65d57731e7b11fa09f2ac02895a420c9167398412cb0a1a" name="ggadd997d5aeb82b1a62f65d57731e7b11fa09f2ac02895a420c9167398412cb0a1a"></a>MCI_START&#160;</td><td class="fielddoc"><p >Start controling the Motor </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd997d5aeb82b1a62f65d57731e7b11fa8c9c0776127166f26debd1e52f1d0777" name="ggadd997d5aeb82b1a62f65d57731e7b11fa8c9c0776127166f26debd1e52f1d0777"></a>MCI_ACK_FAULTS&#160;</td><td class="fielddoc"><p >Acknowledge Motor Control subsystem faults </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd997d5aeb82b1a62f65d57731e7b11fa919a891beb3830a6954db3c0d0b40412" name="ggadd997d5aeb82b1a62f65d57731e7b11fa919a891beb3830a6954db3c0d0b40412"></a>MCI_MEASURE_OFFSETS&#160;</td><td class="fielddoc"><p >Start the ADCs Offset measurements procedure </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd997d5aeb82b1a62f65d57731e7b11fa51154f963d7ffd900d7f489e2b074f64" name="ggadd997d5aeb82b1a62f65d57731e7b11fa51154f963d7ffd900d7f489e2b074f64"></a>MCI_ALIGN_ENCODER&#160;</td><td class="fielddoc"><p >Start the Encoder alignment procedure </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd997d5aeb82b1a62f65d57731e7b11fa97922b94000013cc76c5dd773882dbdf" name="ggadd997d5aeb82b1a62f65d57731e7b11fa97922b94000013cc76c5dd773882dbdf"></a>MCI_STOP&#160;</td><td class="fielddoc"><p >Stop the Motor and the control </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf9c63cc62b4961a5e4ae805cac0abf0c" name="gaf9c63cc62b4961a5e4ae805cac0abf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9c63cc62b4961a5e4ae805cac0abf0c">&#9670;&#160;</a></span>MCI_State_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___m_c_interface.html#gaf9c63cc62b4961a5e4ae805cac0abf0c">MCI_State_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State_t enum type definition, it lists all the possible state machine states. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0ca35ac6f5bc5696afc493bfb5067ade0f2" name="ggaf9c63cc62b4961a5e4ae805cac0abf0ca35ac6f5bc5696afc493bfb5067ade0f2"></a>ICLWAIT&#160;</td><td class="fielddoc"><p >Persistent state, the system is waiting for ICL deactivation. Is not possible to run the motor if ICL is active. Until the ICL is active the state is forced to ICLWAIT, when ICL become inactive the state is moved to IDLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18" name="ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18"></a>IDLE&#160;</td><td class="fielddoc"><p >Persistent state, following state can be IDLE_START if a start motor command has been given or IDLE_ALIGNMENT if a start alignment command has been given </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0ca8d86de0851abd047aef8c1cbb3c1603b" name="ggaf9c63cc62b4961a5e4ae805cac0abf0ca8d86de0851abd047aef8c1cbb3c1603b"></a>ALIGNMENT&#160;</td><td class="fielddoc"><p >Persistent state in which the encoder are properly aligned to set mechanical angle, following state can only be ANY_STOP </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0caf79f81787f9abf2d722902f0f7cfa8e1" name="ggaf9c63cc62b4961a5e4ae805cac0abf0caf79f81787f9abf2d722902f0f7cfa8e1"></a>CHARGE_BOOT_CAP&#160;</td><td class="fielddoc"><p >Persistent state where the gate driver boot capacitors will be charged. Next states will be OFFSET_CALIB. It can also be ANY_STOP if a stop motor command has been given. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0ca4a727c494b6bb2945a8d36fdebbf2cf9" name="ggaf9c63cc62b4961a5e4ae805cac0abf0ca4a727c494b6bb2945a8d36fdebbf2cf9"></a>OFFSET_CALIB&#160;</td><td class="fielddoc"><p >Persistent state where the offset of motor currents measurements will be calibrated. Next state will be CLEAR. It can also be ANY_STOP if a stop motor command has been given. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0ca13d000b4d7dc70d90239b7430d1eb6b2" name="ggaf9c63cc62b4961a5e4ae805cac0abf0ca13d000b4d7dc70d90239b7430d1eb6b2"></a>START&#160;</td><td class="fielddoc"><p >Persistent state where the motor start-up is intended to be executed. The following state is normally SWITCH_OVER or RUN as soon as first validated speed is detected. Another possible following state is ANY_STOP if a stop motor command has been executed </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0caf3a64d3eaee1db88ef3b6ee9b78047c5" name="ggaf9c63cc62b4961a5e4ae805cac0abf0caf3a64d3eaee1db88ef3b6ee9b78047c5"></a>SWITCH_OVER&#160;</td><td class="fielddoc"><p >TBD </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e" name="ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e"></a>RUN&#160;</td><td class="fielddoc"><p >Persistent state with running motor. The following state is normally ANY_STOP when a stop motor command has been executed </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0ca679ee5320d66c8322e310daeb2ee99b8" name="ggaf9c63cc62b4961a5e4ae805cac0abf0ca679ee5320d66c8322e310daeb2ee99b8"></a>STOP&#160;</td><td class="fielddoc"><p >Persistent state. Following state is normally STOP_IDLE as soon as conditions for moving state machine are detected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0ca481894d1977cdfcf5820b30d0ab39355" name="ggaf9c63cc62b4961a5e4ae805cac0abf0ca481894d1977cdfcf5820b30d0ab39355"></a>FAULT_NOW&#160;</td><td class="fielddoc"><p >Persistent state, the state machine can be moved from any condition directly to this state by STM_FaultProcessing method. This method also manage the passage to the only allowed following state that is FAULT_OVER </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9c63cc62b4961a5e4ae805cac0abf0ca3ddcec004b2a75fa65e7d2d92e7a86f0" name="ggaf9c63cc62b4961a5e4ae805cac0abf0ca3ddcec004b2a75fa65e7d2d92e7a86f0"></a>FAULT_OVER&#160;</td><td class="fielddoc"><p >Persistent state where the application is intended to stay when the fault conditions disappeared. Following state is normally STOP_IDLE, state machine is moved as soon as the user has acknowledged the fault condition. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4ee9535da22d0d1dd20142e97a5ec175" name="ga4ee9535da22d0d1dd20142e97a5ec175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ee9535da22d0d1dd20142e97a5ec175">&#9670;&#160;</a></span>MCI_UserCommands_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___m_c_interface.html#ga4ee9535da22d0d1dd20142e97a5ec175">MCI_UserCommands_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4ee9535da22d0d1dd20142e97a5ec175a3a90b9db6d7bd180265e817cccdd51a9" name="gga4ee9535da22d0d1dd20142e97a5ec175a3a90b9db6d7bd180265e817cccdd51a9"></a>MCI_NOCOMMANDSYET&#160;</td><td class="fielddoc"><p >No command has been set by the user. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4ee9535da22d0d1dd20142e97a5ec175ac6acad2878f334fa351ee3df28ad3ea6" name="gga4ee9535da22d0d1dd20142e97a5ec175ac6acad2878f334fa351ee3df28ad3ea6"></a>MCI_CMD_EXECSPEEDRAMP&#160;</td><td class="fielddoc"><p >ExecSpeedRamp command coming from the user. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4ee9535da22d0d1dd20142e97a5ec175a17db3dc4beb4a325b31f28fc333f216e" name="gga4ee9535da22d0d1dd20142e97a5ec175a17db3dc4beb4a325b31f28fc333f216e"></a>MCI_CMD_EXECTORQUERAMP&#160;</td><td class="fielddoc"><p >ExecTorqueRamp command coming from the user. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4ee9535da22d0d1dd20142e97a5ec175a6398c30bb6077549ed6a098131eda5a0" name="gga4ee9535da22d0d1dd20142e97a5ec175a6398c30bb6077549ed6a098131eda5a0"></a>MCI_CMD_SETCURRENTREFERENCES&#160;</td><td class="fielddoc"><p >SetCurrentReferences command coming from the user. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4ee9535da22d0d1dd20142e97a5ec175aa01be1fb31e00bd00456e3fba685cdfb" name="gga4ee9535da22d0d1dd20142e97a5ec175aa01be1fb31e00bd00456e3fba685cdfb"></a>MCI_CMD_SETOPENLOOPCURRENT&#160;</td><td class="fielddoc"><p >set open loop current . </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4ee9535da22d0d1dd20142e97a5ec175a3b10fe56da43b90450b9ed3a76588578" name="gga4ee9535da22d0d1dd20142e97a5ec175a3b10fe56da43b90450b9ed3a76588578"></a>MCI_CMD_SETOPENLOOPVOLTAGE&#160;</td><td class="fielddoc"><p >set open loop voltage . </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6cb1a3c43b9bad27bb32495d318e33bd" name="ga6cb1a3c43b9bad27bb32495d318e33bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cb1a3c43b9bad27bb32495d318e33bd">&#9670;&#160;</a></span>MCI_Clear_Iqdref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_Clear_Iqdref </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It re-initializes Iqdref variables with their default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63f88751260207da7605e934f1086d09" name="ga63f88751260207da7605e934f1086d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63f88751260207da7605e934f1086d09">&#9670;&#160;</a></span>MCI_ExecBufferedCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_ExecBufferedCommands </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is usually a method managed by task. It must be called periodically in order to check the status of the related pSTM object and eventually to execute the buffered command if the condition occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacfd5ea988bd0b0afe0856836b3ed46e" name="gaacfd5ea988bd0b0afe0856836b3ed46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacfd5ea988bd0b0afe0856836b3ed46e">&#9670;&#160;</a></span>MCI_ExecPositionCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_ExecPositionCommand </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>FinalPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a buffered command to set a mechanical position of rotor. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
    <tr><td class="paramname">FinalPosition</td><td>is the desired rotor position asked. </td></tr>
    <tr><td class="paramname">Duration</td><td>the duration of the movement to reach the final position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5473dc15507bfd0f73951f0d4c3f819b" name="ga5473dc15507bfd0f73951f0d4c3f819b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5473dc15507bfd0f73951f0d4c3f819b">&#9670;&#160;</a></span>MCI_ExecSpeedRamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_ExecSpeedRamp </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>hFinalSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a buffered command to set a motor speed ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to operate on. </td></tr>
    <tr><td class="paramname">hFinalSpeed</td><td>is the value of mechanical rotor speed reference at the end of the ramp expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>the duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8fb7e1d924def8953ec0aa4493ba4bcb" name="ga8fb7e1d924def8953ec0aa4493ba4bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb7e1d924def8953ec0aa4493ba4bcb">&#9670;&#160;</a></span>MCI_ExecSpeedRamp_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_ExecSpeedRamp_F </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>FinalSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a buffered command to set a motor speed ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to operate on. </td></tr>
    <tr><td class="paramname">FinalSpeed</td><td>is the value of mechanical rotor speed reference at the end of the ramp expressed in rpm. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>the duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga814b9ec4c7b544c5fd86a94d4a69b240" name="ga814b9ec4c7b544c5fd86a94d4a69b240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814b9ec4c7b544c5fd86a94d4a69b240">&#9670;&#160;</a></span>MCI_ExecTorqueRamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_ExecTorqueRamp </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>hFinalTorque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a buffered command to set a motor torque ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
    <tr><td class="paramname">hFinalTorque</td><td>is the value of motor torque reference at the end of the ramp. This value represents actually the Iq current expressed in digit. To convert current expressed in Amps to current expressed in digit is possible to use the formula: Current (digit) = [Current(Amp) * 65536 * Rshunt * Aop] / Vdd micro. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>the duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77f87a17408f48585e42d8b4f531a4e8" name="ga77f87a17408f48585e42d8b4f531a4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f87a17408f48585e42d8b4f531a4e8">&#9670;&#160;</a></span>MCI_ExecTorqueRamp_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_ExecTorqueRamp_F </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>FinalTorque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a buffered command to set a motor torque ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
    <tr><td class="paramname">FinalTorque</td><td>is the value of motor torque reference at the end of the ramp. This value represents actually the Iq current expressed in Ampere. Here the formula for conversion from current in Ampere to digit: I(s16) = [i(Amp) * 65536 * Rshunt * Aop] / Vdd_micro. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>the duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a392f725376b9c09ef5eec6dce12558" name="ga7a392f725376b9c09ef5eec6dce12558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a392f725376b9c09ef5eec6dce12558">&#9670;&#160;</a></span>MCI_FaultAcknowledged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MCI_FaultAcknowledged </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a user command used to indicate that the user has seen the error condition. If is possible, the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>It returns true if the command is successfully executed otherwise it return false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae63c760c5c7905a21faa1cfa9acb414d" name="gae63c760c5c7905a21faa1cfa9acb414d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae63c760c5c7905a21faa1cfa9acb414d">&#9670;&#160;</a></span>MCI_FaultProcessing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_FaultProcessing </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hSetErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hResetErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It clocks both HW and SW faults processing and update the state machine accordingly with hSetErrors, hResetErrors and present state. Refer to State_t description for more information about fault states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHanlde</td><td>pointer of type STM_Handle_t </td></tr>
    <tr><td class="paramname">hSetErrors</td><td>Bit field reporting faults currently present </td></tr>
    <tr><td class="paramname">hResetErrors</td><td>Bit field reporting faults to be cleared </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">State_t</td><td>New state machine state after fault processing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7bf23abd19413ce92ff75a9d397de9e3" name="ga7bf23abd19413ce92ff75a9d397de9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bf23abd19413ce92ff75a9d397de9e3">&#9670;&#160;</a></span>MCI_GetAlignmentStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak AlignStatus_t MCI_GetAlignmentStatus </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns information about the rotor alignment procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">State_t</td><td>It returns the current state of the alignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3e99e9c430199980dd226586cf3dca9" name="gaf3e99e9c430199980dd226586cf3dca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3e99e9c430199980dd226586cf3dca9">&#9670;&#160;</a></span>MCI_GetAvrgMecSpeed_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MCI_GetAvrgMecSpeed_F </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last computed average mechanical speed, expressed in rpm and related to the sensor actually used by FOC algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab710f9661e807ac5a6761527c4391544" name="gab710f9661e807ac5a6761527c4391544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab710f9661e807ac5a6761527c4391544">&#9670;&#160;</a></span>MCI_GetAvrgMecSpeedUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MCI_GetAvrgMecSpeedUnit </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last computed average mechanical speed, expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a> and related to the sensor actually used by FOC algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb63fd6e9f2537de867d2f976cae29e2" name="gaeb63fd6e9f2537de867d2f976cae29e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb63fd6e9f2537de867d2f976cae29e2">&#9670;&#160;</a></span>MCI_GetCalibratedOffsetsMotor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MCI_GetCalibratedOffsetsMotor </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *&#160;</td>
          <td class="paramname"><em>PolarizationOffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a user command used to get the phase offset values. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_GetCalibratedOffsetsMotor command is used to get the phase offset values . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Pointer on ploarization offset structure that conatains phase A, and C values. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>It returns true if the command is successfully executed otherwise it return false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga935749f2eeaf420fd2e8e45641d45845" name="ga935749f2eeaf420fd2e8e45641d45845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga935749f2eeaf420fd2e8e45641d45845">&#9670;&#160;</a></span>MCI_GetControlMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="group___m_c___type.html#ga93791db1e1974fe42cab1e0a9c35e21e">MC_ControlMode_t</a> MCI_GetControlMode </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the modality of the speed and torque controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">MC_ControlMode_t</td><td>It returns the modality of STC. It can be one of these two values: MCM_TORQUE_MODE or MCM_SPEED_MODE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga181d97fe2b058f2c7c7d8bc15a237bac" name="ga181d97fe2b058f2c7c7d8bc15a237bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga181d97fe2b058f2c7c7d8bc15a237bac">&#9670;&#160;</a></span>MCI_GetCtrlPositionState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak PosCtrlStatus_t MCI_GetCtrlPositionState </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns information about the state of the position control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">State_t</td><td>It returns the current state position control execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92bdc250e3e00f5da65cdb84628f6105" name="ga92bdc250e3e00f5da65cdb84628f6105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92bdc250e3e00f5da65cdb84628f6105">&#9670;&#160;</a></span>MCI_GetCurrentFaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t MCI_GetCurrentFaults </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns a 16 bit fields containing information about faults currently present. <br  />
<a class="el" href="">Returned error codes are listed here </a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>16 bit fields with information about about currently present faults. <br  />
<a class="el" href="">Returned error codes are listed here </a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0fede234d630c4d009a5ebc7dfce0fcb" name="ga0fede234d630c4d009a5ebc7dfce0fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fede234d630c4d009a5ebc7dfce0fcb">&#9670;&#160;</a></span>MCI_GetCurrentPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MCI_GetCurrentPosition </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the current position of the rotor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td>It returns the current mechanical angular position of the rotor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36a50cbb7839903d8d48256dc631242e" name="ga36a50cbb7839903d8d48256dc631242e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36a50cbb7839903d8d48256dc631242e">&#9670;&#160;</a></span>MCI_GetDutyCycleRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t MCI_GetDutyCycleRef </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the reference eletrical torque, fed to derived class for Iqref and Idref computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>Teref </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40b06d6e8bb35763b772053d562683b0" name="ga40b06d6e8bb35763b772053d562683b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40b06d6e8bb35763b772053d562683b0">&#9670;&#160;</a></span>MCI_GetElAngledpp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MCI_GetElAngledpp </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the rotor electrical angle actually used for reference frame transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>Rotor electrical angle in dpp format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09e95a73280381a6fb788a119816fcba" name="ga09e95a73280381a6fb788a119816fcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09e95a73280381a6fb788a119816fcba">&#9670;&#160;</a></span>MCI_GetFaultState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint32_t MCI_GetFaultState </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns two 16 bit fields containing information about both faults currently present and faults historically occurred since the state machine has been moved into state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHanlde</td><td>pointer of type STM_Handle_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint32_t</td><td>Two 16 bit fields: in the most significant half are stored the information about currently present faults. In the least significant half are stored the information about the faults historically occurred since the state machine has been moved into FAULT_NOW state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35b7dc42e7f107903289624badb1bba3" name="ga35b7dc42e7f107903289624badb1bba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35b7dc42e7f107903289624badb1bba3">&#9670;&#160;</a></span>MCI_GetIab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="structab__t.html">ab_t</a> MCI_GetIab </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns stator current Iab in <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a></td><td>Stator current Iab </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82b9e2359f164c3acaac0acbdd2d326e" name="ga82b9e2359f164c3acaac0acbdd2d326e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82b9e2359f164c3acaac0acbdd2d326e">&#9670;&#160;</a></span>MCI_GetIalphabeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="structalphabeta__t.html">alphabeta_t</a> MCI_GetIalphabeta </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns stator current Ialphabeta in <a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a></td><td>Stator current Ialphabeta </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9886422959d033fed61981d8b5985e00" name="ga9886422959d033fed61981d8b5985e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9886422959d033fed61981d8b5985e00">&#9670;&#160;</a></span>MCI_GetImposedMotorDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MCI_GetImposedMotorDirection </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the motor direction imposed by the last command (MCI_ExecSpeedRamp, MCI_ExecTorqueRamp or MCI_SetCurrentReferences). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>It returns 1 or -1 according the sign of hFinalSpeed, hFinalTorque or Iqdref.q of the last command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37366425df4914d275b634d494ea73e6" name="ga37366425df4914d275b634d494ea73e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37366425df4914d275b634d494ea73e6">&#9670;&#160;</a></span>MCI_GetIqd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="structqd__t.html">qd_t</a> MCI_GetIqd </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns stator current Iqd in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a></td><td>Stator current Iqd </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ad7b16f781148d636a632daf23e7192" name="ga3ad7b16f781148d636a632daf23e7192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ad7b16f781148d636a632daf23e7192">&#9670;&#160;</a></span>MCI_GetIqd_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="structqd__f__t.html">qd_f_t</a> MCI_GetIqd_F </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns stator current Iqd in float format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="structqd__f__t.html" title="Two components q, d in float type.">qd_f_t</a></td><td>Stator current Iqd (in Ampere) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7343a99d44efa034e47d4da80a5a4b88" name="ga7343a99d44efa034e47d4da80a5a4b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7343a99d44efa034e47d4da80a5a4b88">&#9670;&#160;</a></span>MCI_GetIqdHF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="structqd__t.html">qd_t</a> MCI_GetIqdHF </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns stator current IqdHF in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a></td><td>Stator current IqdHF if HFI is selected as main sensor. Otherwise it returns { 0, 0}. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaadf753a851af454331a28ca987ff102e" name="gaadf753a851af454331a28ca987ff102e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadf753a851af454331a28ca987ff102e">&#9670;&#160;</a></span>MCI_GetIqdref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="structqd__t.html">qd_t</a> MCI_GetIqdref </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns stator current Iqdref in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a></td><td>Stator current Iqdref </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab44c7762ef38aeca587677b4ab18150c" name="gab44c7762ef38aeca587677b4ab18150c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab44c7762ef38aeca587677b4ab18150c">&#9670;&#160;</a></span>MCI_GetIqdref_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="structqd__f__t.html">qd_f_t</a> MCI_GetIqdref_F </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns stator current Iqdref in float format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="structqd__f__t.html" title="Two components q, d in float type.">qd_f_t</a></td><td>Stator current Iqdref (in Ampere) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga898c0949556c7de262e96226a27a460b" name="ga898c0949556c7de262e96226a27a460b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga898c0949556c7de262e96226a27a460b">&#9670;&#160;</a></span>MCI_GetLastRampFinalDuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t MCI_GetLastRampFinalDuration </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns information about the last ramp Duration sent by the user . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>last ramp final torque sent by the user expressed in digit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6dba057c41bc1e019941d9cfe9a54bd5" name="ga6dba057c41bc1e019941d9cfe9a54bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dba057c41bc1e019941d9cfe9a54bd5">&#9670;&#160;</a></span>MCI_GetLastRampFinalSpeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MCI_GetLastRampFinalSpeed </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns information about the last ramp final speed sent by the user expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>last ramp final speed sent by the user expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga074bf76ebd1fb259b5c14b65da7b034c" name="ga074bf76ebd1fb259b5c14b65da7b034c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga074bf76ebd1fb259b5c14b65da7b034c">&#9670;&#160;</a></span>MCI_GetLastRampFinalSpeed_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MCI_GetLastRampFinalSpeed_F </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns last ramp final speed expressed in rpm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td>last ramp final speed sent by the user expressed in rpm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga447b945f2d2df284a1140546e1de2926" name="ga447b945f2d2df284a1140546e1de2926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga447b945f2d2df284a1140546e1de2926">&#9670;&#160;</a></span>MCI_GetLastRampFinalTorque()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MCI_GetLastRampFinalTorque </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns information about the last ramp final torque sent by the user .This value represents actually the Iq current expressed in digit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>last ramp final torque sent by the user expressed in digit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f5e2d87cfc9de98f630bdf13532629a" name="ga4f5e2d87cfc9de98f630bdf13532629a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f5e2d87cfc9de98f630bdf13532629a">&#9670;&#160;</a></span>MCI_GetMecSpeedRef_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MCI_GetMecSpeedRef_F </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current mechanical rotor speed reference expressed in rpm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac2f95aea22785ac8c5bc2c86abf0efeb" name="gac2f95aea22785ac8c5bc2c86abf0efeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2f95aea22785ac8c5bc2c86abf0efeb">&#9670;&#160;</a></span>MCI_GetMecSpeedRefUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MCI_GetMecSpeedRefUnit </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current mechanical rotor speed reference expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab6548573a31cadd84d87450099bb0be1" name="gab6548573a31cadd84d87450099bb0be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6548573a31cadd84d87450099bb0be1">&#9670;&#160;</a></span>MCI_GetMoveDuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MCI_GetMoveDuration </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the total movement duration to reach the final position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td>It returns the movement duration allowed to reach the target position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9b5b555595ad7704c61f7eb6cf831c8" name="gaf9b5b555595ad7704c61f7eb6cf831c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9b5b555595ad7704c61f7eb6cf831c8">&#9670;&#160;</a></span>MCI_GetOccurredFaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t MCI_GetOccurredFaults </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns a 16 bit fields containing information about faults historically occurred since the state machine has been moved into FAULT_NOW state. <br  />
<a class="el" href="">Returned error codes are listed here </a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>16 bit fields with information about the faults historically occurred since the state machine has been moved into FAULT_NOW state. <br  />
<a class="el" href="">Returned error codes are listed here </a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa03dddcb5e831e3fe9c757b6361a2ba3" name="gaa03dddcb5e831e3fe9c757b6361a2ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa03dddcb5e831e3fe9c757b6361a2ba3">&#9670;&#160;</a></span>MCI_GetPhaseCurrentAmplitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MCI_GetPhaseCurrentAmplitude </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the motor phase current amplitude (0-to-peak) in s16A To convert s16A into Ampere following formula must be used: Current(Amp) = [Current(s16A) * Vdd micro] / [65536 * Rshunt * Aop]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>Motor phase current (0-to-peak) in s16A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a6fb1fccbd5db7e843bd723ceecd72f" name="ga4a6fb1fccbd5db7e843bd723ceecd72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a6fb1fccbd5db7e843bd723ceecd72f">&#9670;&#160;</a></span>MCI_GetPhaseVoltageAmplitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MCI_GetPhaseVoltageAmplitude </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the applied motor phase voltage amplitude (0-to-peak) in s16V. To convert s16V into Volts following formula must be used: PhaseVoltage(V) = [PhaseVoltage(s16A) * Vbus(V)] /[sqrt(3) *32767]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>Motor phase voltage (0-to-peak) in s16V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82a794dcdafd274d25bf7f05584a48c4" name="ga82a794dcdafd274d25bf7f05584a48c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82a794dcdafd274d25bf7f05584a48c4">&#9670;&#160;</a></span>MCI_GetSpdSensorReliability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MCI_GetSpdSensorReliability </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns speed sensor reliability with reference to the sensor actually used for reference frame transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>It returns true if the speed sensor utilized for reference frame transformation and (in speed control mode) for speed regulation is reliable, false otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf0790ece81c2c29bddb5060ab0e5cdb" name="gaaf0790ece81c2c29bddb5060ab0e5cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf0790ece81c2c29bddb5060ab0e5cdb">&#9670;&#160;</a></span>MCI_GetSTMState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="group___m_c_interface.html#gaf9c63cc62b4961a5e4ae805cac0abf0c">MCI_State_t</a> MCI_GetSTMState </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns information about the state of the related pSTM object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">State_t</td><td>It returns the current state of the related pSTM object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0c36b4534a5f443198f88e8069c0e0f" name="gad0c36b4534a5f443198f88e8069c0e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0c36b4534a5f443198f88e8069c0e0f">&#9670;&#160;</a></span>MCI_GetTargetPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MCI_GetTargetPosition </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the final position asked to the motor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td>It returns the target mechanical angular position of the rotor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf25e2edb6c1d3a10151aefe667ab7be7" name="gaf25e2edb6c1d3a10151aefe667ab7be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf25e2edb6c1d3a10151aefe667ab7be7">&#9670;&#160;</a></span>MCI_GetTeref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MCI_GetTeref </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the reference electrical torque, fed to derived class for Iqref and Idref computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>Teref </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62b153b3b81542f3064a0fbbb0222d2c" name="ga62b153b3b81542f3064a0fbbb0222d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62b153b3b81542f3064a0fbbb0222d2c">&#9670;&#160;</a></span>MCI_GetTeref_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MCI_GetTeref_F </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns the reference electrical torque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td>Teref </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5cf86931dd0ad217d3c4f61db97a173" name="gac5cf86931dd0ad217d3c4f61db97a173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5cf86931dd0ad217d3c4f61db97a173">&#9670;&#160;</a></span>MCI_GetValphabeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="structalphabeta__t.html">alphabeta_t</a> MCI_GetValphabeta </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns stator current Valphabeta in <a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a></td><td>Stator current Valphabeta </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ca2bfbc6b48738362566561c5c95c53" name="ga8ca2bfbc6b48738362566561c5c95c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ca2bfbc6b48738362566561c5c95c53">&#9670;&#160;</a></span>MCI_GetVqd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="structqd__t.html">qd_t</a> MCI_GetVqd </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns stator current Vqd in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a></td><td>Stator current Vqd </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga69655a488452da04725907b29f3c4d3e" name="ga69655a488452da04725907b29f3c4d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69655a488452da04725907b29f3c4d3e">&#9670;&#160;</a></span>MCI_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_Init </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_speedn_torq_ctrl___handle__t.html">SpeednTorqCtrl_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pSTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_o_c_vars__t.html">pFOCVars_t</a>&#160;</td>
          <td class="paramname"><em>pFOCVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pos_ctrl___handle__t.html">PosCtrl_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pPosCtrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pPWMHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes all the object variables, usually it has to be called once right after object creation. It is also used to assign the state machine object, the speed and torque controller, and the FOC drive object to be used by MC Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>pointer on the component instance to initialize. </td></tr>
    <tr><td class="paramname">pSTM</td><td>the state machine object used by the MCI. </td></tr>
    <tr><td class="paramname">pSTC</td><td>the speed and torque controller used by the MCI. </td></tr>
    <tr><td class="paramname">pFOCVars</td><td>pointer to FOC vars to be used by MCI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga270f7a86c8bd9da7dc263b5d55ca7de0" name="ga270f7a86c8bd9da7dc263b5d55ca7de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga270f7a86c8bd9da7dc263b5d55ca7de0">&#9670;&#160;</a></span>MCI_IsCommandAcknowledged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a> MCI_IsCommandAcknowledged </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It returns information about the state of the last buffered command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CommandState_t</td><td>It can be one of the following codes:<ul>
<li>MCI_BUFFER_EMPTY if no buffered command has been called.</li>
<li>MCI_COMMAND_NOT_ALREADY_EXECUTED if the buffered command condition hasn't already occurred.</li>
<li>MCI_COMMAND_EXECUTED_SUCCESFULLY if the buffered command has been executed successfully. In this case calling this function reset the command state to BC_BUFFER_EMPTY.</li>
<li>MCI_COMMAND_EXECUTED_UNSUCCESFULLY if the buffered command has been executed unsuccessfully. In this case calling this function reset the command state to BC_BUFFER_EMPTY. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f7ba74a795eb1d19e761eceb0269545" name="ga1f7ba74a795eb1d19e761eceb0269545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f7ba74a795eb1d19e761eceb0269545">&#9670;&#160;</a></span>MCI_RampCompleted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MCI_RampCompleted </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the settled speed or torque ramp has been completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>It returns true if the ramp is completed, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5baf843ad8a1d5d1f624c204932e36df" name="ga5baf843ad8a1d5d1f624c204932e36df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5baf843ad8a1d5d1f624c204932e36df">&#9670;&#160;</a></span>MCI_SetCalibratedOffsetsMotor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MCI_SetCalibratedOffsetsMotor </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *&#160;</td>
          <td class="paramname"><em>PolarizationOffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a user command used to set the phase offset values. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_SetCalibratedOffsetsMotor command is used to set the phase offset values . The command MCI_SetCalibratedOffsetsMotor is not blocking the execution of project until the measurments are done; to do this, the user have to check the state machine and verify that the IDLE state (or any other state) has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Pointer on ploarization offset structure that contains phase A, and C values. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>It returns true if the command is successfully executed otherwise it return false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab344cb878cf4f37b34df807cb50a5da5" name="gab344cb878cf4f37b34df807cb50a5da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab344cb878cf4f37b34df807cb50a5da5">&#9670;&#160;</a></span>MCI_SetCurrentReferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_SetCurrentReferences </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td>
          <td class="paramname"><em>Iqdref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
    <tr><td class="paramname">Iqdref</td><td>current references on qd reference frame in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae8b6a07cf328155f032fa068e9e04d09" name="gae8b6a07cf328155f032fa068e9e04d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8b6a07cf328155f032fa068e9e04d09">&#9670;&#160;</a></span>MCI_SetCurrentReferences_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_SetCurrentReferences_F </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqd__f__t.html">qd_f_t</a>&#160;</td>
          <td class="paramname"><em>IqdRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
    <tr><td class="paramname">Iqdref</td><td>current (A) references on qd reference frame in <a class="el" href="structqd__f__t.html" title="Two components q, d in float type.">qd_f_t</a> format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77a4dbccd507057d014e57bd4e08ecab" name="ga77a4dbccd507057d014e57bd4e08ecab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77a4dbccd507057d014e57bd4e08ecab">&#9670;&#160;</a></span>MCI_SetOpenLoopCurrent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_SetOpenLoopCurrent </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
    <tr><td class="paramname">Iqdref</td><td>current references on qd reference frame in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab539f38639a4b63e3b26aa4b5bcbf300" name="gab539f38639a4b63e3b26aa4b5bcbf300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab539f38639a4b63e3b26aa4b5bcbf300">&#9670;&#160;</a></span>MCI_SetOpenLoopVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_SetOpenLoopVoltage </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
    <tr><td class="paramname">Iqdref</td><td>current references on qd reference frame in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb5999bf96250ab31a25db5c3acdb969" name="gabb5999bf96250ab31a25db5c3acdb969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb5999bf96250ab31a25db5c3acdb969">&#9670;&#160;</a></span>MCI_SetSpeedMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_SetSpeedMode </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
    <tr><td class="paramname">Iqdref</td><td>current references on qd reference frame in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad492e094c58042efe4f837fc62a9d887" name="gad492e094c58042efe4f837fc62a9d887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad492e094c58042efe4f837fc62a9d887">&#9670;&#160;</a></span>MCI_StartMotor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MCI_StartMotor </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a user command used to begin the start-up procedure. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value. Before calling MCI_StartMotor it is mandatory to execute one of these commands:<br  />
 MCI_ExecSpeedRamp<br  />
 MCI_ExecTorqueRamp<br  />
 MCI_SetCurrentReferences<br  />
 Otherwise the behavior in run state will be unpredictable.<br  />
 <b>Note:</b> The MCI_StartMotor command is used just to begin the start-up procedure moving the state machine from IDLE state to IDLE_START. The command MCI_StartMotor is not blocking the execution of project until the motor is really running; to do this, the user have to check the state machine and verify that the RUN state (or any other state) has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>It returns true if the command is successfully executed otherwise it return false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39ffe756795656f7300d3fe4d3a0a3db" name="ga39ffe756795656f7300d3fe4d3a0a3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39ffe756795656f7300d3fe4d3a0a3db">&#9670;&#160;</a></span>MCI_StartOffsetMeasurments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MCI_StartOffsetMeasurments </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a user command used to begin the phase offset calibration procedure. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_StartOffsetMeasurments command is used to begin phase offset calibration procedure moving the state machine from IDLE state to OFFSET_CALIB. The command MCI_StartOffsetMeasurments is not blocking the execution of project until the measurments are done; to do this, the user have to check the state machine and verify that the IDLE state (or any other state) has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>It returns true if the command is successfully executed otherwise it return false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadcc7c207ed92d6ed2ce1457da51317e4" name="gadcc7c207ed92d6ed2ce1457da51317e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcc7c207ed92d6ed2ce1457da51317e4">&#9670;&#160;</a></span>MCI_StartWithMeasurementOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MCI_StartWithMeasurementOffset </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a user command used to begin the start-up procedure with an offset calibration even if it has been already done previously. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value. Before calling MCI_StartWithMeasurementOffset it is mandatory to execute one of these commands:<br  />
 MCI_ExecSpeedRamp<br  />
 MCI_ExecTorqueRamp<br  />
 MCI_SetCurrentReferences<br  />
 Otherwise the behaviour in run state will be unpredictable.<br  />
 <b>Note:</b> The MCI_StartWithMeasurementOffset command is used just to begin the start-up procedure moving the state machine from IDLE state to IDLE_START. The command MCI_StartWithMeasurementOffset is not blocking the execution of project until the motor is really running; to do this, the user have to check the state machine and verify that the RUN state (or any other state) has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>It returns true if the command is successfully executed otherwise it return false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f963eae914e2d3b9016b3f417750fcf" name="ga6f963eae914e2d3b9016b3f417750fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f963eae914e2d3b9016b3f417750fcf">&#9670;&#160;</a></span>MCI_StopMotor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MCI_StopMotor </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a user command used to begin the stop motor procedure. If the state machine is in RUN or START states the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_StopMotor command is used just to begin the stop motor procedure moving the state machine to ANY_STOP. The command MCI_StopMotor is not blocking the execution of project until the motor is really stopped; to do this, the user have to check the state machine and verify that the IDLE state has been reached again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>It returns true if the command is successfully executed otherwise it return false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98cc1abd8dee123a6b77da7d9d6e16d5" name="ga98cc1abd8dee123a6b77da7d9d6e16d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98cc1abd8dee123a6b77da7d9d6e16d5">&#9670;&#160;</a></span>MCI_StopRamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MCI_StopRamp </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the execution of ongoing ramp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b7a23eacfd8e188e12ed2eb2011ddfd" name="ga8b7a23eacfd8e188e12ed2eb2011ddfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b7a23eacfd8e188e12ed2eb2011ddfd">&#9670;&#160;</a></span>MCI_StopSpeedRamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MCI_StopSpeedRamp </td>
          <td>(</td>
          <td class="paramtype">MCI_Handle_t *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the execution of speed ramp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Pointer on the component instance to work on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>It returns true if the command is executed, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This function is deprecated and should not be used anymore. It will be removed in a future version of the MCSDK. Use <a class="el" href="group___m_c_interface.html#ga98cc1abd8dee123a6b77da7d9d6e16d5" title="Stop the execution of ongoing ramp.">MCI_StopRamp()</a> instead. </dd></dl>

</div>
</div>
<a id="ga5c1d915db5adf398cbe27acc15496f7f" name="ga5c1d915db5adf398cbe27acc15496f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1d915db5adf398cbe27acc15496f7f">&#9670;&#160;</a></span>MX_MotorControl_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MX_MotorControl_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes and configures the Motor Control Subsystem. </p>
<p >This function initializes and configures all the structures and components needed for the Motor Control subsystem required by the Application. It expects that all the peripherals needed for Motor Control purposes are already configured but that their interrupts are not enabled yet.</p>
<p >CubeMX calls this function after all peripherals initializations and before the NVIC is configured </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
