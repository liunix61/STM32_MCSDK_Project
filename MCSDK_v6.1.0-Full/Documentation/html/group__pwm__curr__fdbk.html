<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: PWM &amp; Current Feedback</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Related components</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">PWM &amp; Current Feedback<div class="ingroups"><a class="el" href="group___m_c_s_d_k.html">MCSDK</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>PWM &amp; Current Feedback components of the Motor Control SDK.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Related components</h2></td></tr>
<tr class="memitem:group___i_c_s__pwm__curr__fdbk"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_c_s__pwm__curr__fdbk.html">ICS 2 ADCs PWM &amp; Current Feedback</a></td></tr>
<tr class="memdesc:group___i_c_s__pwm__curr__fdbk"><td class="mdescLeft">&#160;</td><td class="mdescRight">ICS, 2 ADCs, PWM &amp; Current Feedback implementation for F30X, F4XX, F7XX, G4XX and L4XX MCUs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__r1__ps__pwm__curr__fdbk"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__r1__ps__pwm__curr__fdbk.html">R1 PWM &amp; Current Feedback</a></td></tr>
<tr class="memdesc:group__r1__ps__pwm__curr__fdbk"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-Shunt with phase shift PWM &amp; Current Feedback implementation for F30X, F7XX, G0XX, G4XX and L4XX MCUs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___r3__1__pwm__curr__fdbk"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html">R3 1 ADC PWM &amp; Current Feedback</a></td></tr>
<tr class="memdesc:group___r3__1__pwm__curr__fdbk"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-Shunt, 1 ADC, PWM &amp; Current Feedback implementation for F0XX, F30X, F4XX, F7XX, G0XX and L4XX MCUs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___r3__2__pwm__curr__fdbk"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__2__pwm__curr__fdbk.html">R3 2 ADCs PWM &amp; Current Feedback</a></td></tr>
<tr class="memdesc:group___r3__2__pwm__curr__fdbk"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-Shunt, 2 ADCs, PWM &amp; Current Feedback implementation for F30X, F4XX, F7XX, G4XX, H7XX and L4XX MCUs <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__pwm__curr__fdbk__6s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk__6s.html">Six-Step PWM generation</a></td></tr>
<tr class="memdesc:group__pwm__curr__fdbk__6s"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM components for Six Step drive. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:pwm__common_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pwm__common_8h.html">pwm_common.h</a></td></tr>
<tr class="memdesc:pwm__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains all definitions and functions prototypes for the PWM &amp; Current Feedback component of the Motor Control SDK. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pwm__curr__fdbk_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pwm__curr__fdbk_8h.html">pwm_curr_fdbk.h</a></td></tr>
<tr class="memdesc:pwm__curr__fdbk_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains all definitions and functions prototypes for the PWM &amp; Current Feedback component of the Motor Control SDK. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pwm__common_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pwm__common_8c.html">pwm_common.c</a></td></tr>
<tr class="memdesc:pwm__common_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file provides firmware functions that implement common features of the PWM &amp; Current Feedback component of the Motor Control SDK: <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pwm__curr__fdbk__ovm_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pwm__curr__fdbk__ovm_8c.html">pwm_curr_fdbk_ovm.c</a></td></tr>
<tr class="memdesc:pwm__curr__fdbk__ovm_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file provides firmware functions that implement the following features of the PWM &amp; Current Feedback component of the Motor Control SDK: <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pwm__curr__fdbk_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pwm__curr__fdbk_8c.html">pwm_curr_fdbk.c</a></td></tr>
<tr class="memdesc:pwm__curr__fdbk_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file provides firmware functions that implement the following features of the PWM &amp; Current Feedback component of the Motor Control SDK: <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_w_m_c___handle.html">PWMC_Handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used to handle the data of an instance of the PWM &amp; Current Feedback component.  <a href="struct_p_w_m_c___handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vector___time__t.html">Vector_Time_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector modules T1 and T2. Specified in <a class="el" href="md_docs_overmodulation.html">Overmodulation</a>.  <a href="struct_vector___time__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5febe836591f0388113c624ad3e1a16a"><td class="memItemLeft" align="right" valign="top"><a id="ga5febe836591f0388113c624ad3e1a16a" name="ga5febe836591f0388113c624ad3e1a16a"></a>
typedef struct <a class="el" href="struct_p_w_m_c___handle.html">PWMC_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PWMC_Handle_t</b></td></tr>
<tr class="memdesc:ga5febe836591f0388113c624ad3e1a16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM &amp; Current Sensing component handle type. <br /></td></tr>
<tr class="separator:ga5febe836591f0388113c624ad3e1a16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7381a768e880cca363cbfba4ee087d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a>) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gabe7381a768e880cca363cbfba4ee087d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer on callback functions used by PWMC components.  <a href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">More...</a><br /></td></tr>
<tr class="separator:gabe7381a768e880cca363cbfba4ee087d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9470fcb01290e562fb5fff247f4ea3f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gad9470fcb01290e562fb5fff247f4ea3f">PWMC_GetPhaseCurr_Cb_t</a>) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="structab__t.html">ab_t</a> *Iab)</td></tr>
<tr class="memdesc:gad9470fcb01290e562fb5fff247f4ea3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer on the function provided by the PMWC component instance to get the phase current.  <a href="group__pwm__curr__fdbk.html#gad9470fcb01290e562fb5fff247f4ea3f">More...</a><br /></td></tr>
<tr class="separator:gad9470fcb01290e562fb5fff247f4ea3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccf5e51ae37934d1ffe4702dab2ed12"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga8ccf5e51ae37934d1ffe4702dab2ed12">PWMC_TurnOnLowSides_Cb_t</a>) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, const uint32_t ticks)</td></tr>
<tr class="memdesc:ga8ccf5e51ae37934d1ffe4702dab2ed12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer on the function provided by the PMWC component instance to set low sides ON.  <a href="group__pwm__curr__fdbk.html#ga8ccf5e51ae37934d1ffe4702dab2ed12">More...</a><br /></td></tr>
<tr class="separator:ga8ccf5e51ae37934d1ffe4702dab2ed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6deba4698c817309573dde4acb9a167b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga6deba4698c817309573dde4acb9a167b">PWMC_SetOcpRefVolt_Cb_t</a>) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, uint16_t hDACVref)</td></tr>
<tr class="memdesc:ga6deba4698c817309573dde4acb9a167b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer on the function provided by the PMWC component instance to set the reference voltage for the over current protection.  <a href="group__pwm__curr__fdbk.html#ga6deba4698c817309573dde4acb9a167b">More...</a><br /></td></tr>
<tr class="separator:ga6deba4698c817309573dde4acb9a167b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf73746ea2bb4c532979b18c95f598e5"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gadf73746ea2bb4c532979b18c95f598e5">PWMC_SetSampPointSectX_Cb_t</a>) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gadf73746ea2bb4c532979b18c95f598e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer on the functions provided by the PMWC component instance to set the ADC sampling point for each sectors.  <a href="group__pwm__curr__fdbk.html#gadf73746ea2bb4c532979b18c95f598e5">More...</a><br /></td></tr>
<tr class="separator:gadf73746ea2bb4c532979b18c95f598e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a54e1741e0569bc136254655adfb548"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga0a54e1741e0569bc136254655adfb548">PWMC_OverCurr_Cb_t</a>) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga0a54e1741e0569bc136254655adfb548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer on the function provided by the PMWC component instance to check if an over current condition has occured.  <a href="group__pwm__curr__fdbk.html#ga0a54e1741e0569bc136254655adfb548">More...</a><br /></td></tr>
<tr class="separator:ga0a54e1741e0569bc136254655adfb548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fabe32a2771ace08a118d21d46bfbe7"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga5fabe32a2771ace08a118d21d46bfbe7">PWMC_RLDetectSetDuty_Cb_t</a>) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, uint16_t hDuty)</td></tr>
<tr class="memdesc:ga5fabe32a2771ace08a118d21d46bfbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer on the function provided by the PMWC component instance to set the PWM duty cycle in RL detection mode.  <a href="group__pwm__curr__fdbk.html#ga5fabe32a2771ace08a118d21d46bfbe7">More...</a><br /></td></tr>
<tr class="separator:ga5fabe32a2771ace08a118d21d46bfbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8f4b36a3a33c9e6818a57419ee86fa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga0e8f4b36a3a33c9e6818a57419ee86fa">PWMC_SetOffsetCalib_Cb_t</a>) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *offsets)</td></tr>
<tr class="memdesc:ga0e8f4b36a3a33c9e6818a57419ee86fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer on the function provided by the PMWC component instance to set the calibrated offsets in RL detection mode.  <a href="group__pwm__curr__fdbk.html#ga0e8f4b36a3a33c9e6818a57419ee86fa">More...</a><br /></td></tr>
<tr class="separator:ga0e8f4b36a3a33c9e6818a57419ee86fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1851d94e86fc6adfdf2a4ed5567e9162"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga1851d94e86fc6adfdf2a4ed5567e9162">PWMC_GetOffsetCalib_Cb_t</a>) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *offsets)</td></tr>
<tr class="memdesc:ga1851d94e86fc6adfdf2a4ed5567e9162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer on the function provided by the PMWC component instance to get the calibrated offsets in RL detection mode.  <a href="group__pwm__curr__fdbk.html#ga1851d94e86fc6adfdf2a4ed5567e9162">More...</a><br /></td></tr>
<tr class="separator:ga1851d94e86fc6adfdf2a4ed5567e9162"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gafbeb53b9dd2d70202e5d4fffe5aa8407"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gafbeb53b9dd2d70202e5d4fffe5aa8407">CRCAction_t</a> { <a class="el" href="group__pwm__curr__fdbk.html#ggafbeb53b9dd2d70202e5d4fffe5aa8407ad8f15e9e15b4d50f6688663116764bbc">CRC_START</a>
, <a class="el" href="group__pwm__curr__fdbk.html#ggafbeb53b9dd2d70202e5d4fffe5aa8407a4ff690a9c0cfc004d96b5b7f7cd3b045">CRC_EXEC</a>
 }</td></tr>
<tr class="memdesc:gafbeb53b9dd2d70202e5d4fffe5aa8407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current reading calibration definition.  <a href="group__pwm__curr__fdbk.html#gafbeb53b9dd2d70202e5d4fffe5aa8407">More...</a><br /></td></tr>
<tr class="separator:gafbeb53b9dd2d70202e5d4fffe5aa8407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3468ec3f8e30a5e55b7e125e49c89c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gad3468ec3f8e30a5e55b7e125e49c89c8">OVM_Mode_t</a> { <a class="el" href="group__pwm__curr__fdbk.html#ggad3468ec3f8e30a5e55b7e125e49c89c8a410c3093ee5dbfc8082d7d088b609bfc">OVM_LINEAR</a> = 0
, <a class="el" href="group__pwm__curr__fdbk.html#ggad3468ec3f8e30a5e55b7e125e49c89c8aa179f4f3de87428c7e0a783b1287e5e1">OVM_1</a> = 1
, <a class="el" href="group__pwm__curr__fdbk.html#ggad3468ec3f8e30a5e55b7e125e49c89c8a2801a969dd6fdc87d52d2987402db004">OVM_2</a> = 2
, <a class="el" href="group__pwm__curr__fdbk.html#ggad3468ec3f8e30a5e55b7e125e49c89c8ad8f16809b759bec11beeb489a4f08237">OVM_ERROR</a> = 3
 }</td></tr>
<tr class="memdesc:gad3468ec3f8e30a5e55b7e125e49c89c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overmodulation modes. Specified in <a class="el" href="md_docs_overmodulation.html">Overmodulation</a>.  <a href="group__pwm__curr__fdbk.html#gad3468ec3f8e30a5e55b7e125e49c89c8">More...</a><br /></td></tr>
<tr class="separator:gad3468ec3f8e30a5e55b7e125e49c89c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaeaabf1bb356c4e30b2a8bb4de7cae9c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gaeaabf1bb356c4e30b2a8bb4de7cae9c1">waitForPolarizationEnd</a> (TIM_TypeDef *TIMx, uint16_t *SWerror, uint8_t repCnt, volatile uint8_t *cnt)</td></tr>
<tr class="memdesc:gaeaabf1bb356c4e30b2a8bb4de7cae9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the end of the polarization.  <a href="group__pwm__curr__fdbk.html#gaeaabf1bb356c4e30b2a8bb4de7cae9c1">More...</a><br /></td></tr>
<tr class="separator:gaeaabf1bb356c4e30b2a8bb4de7cae9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765974bc8cdcd9ade8d9b065a55f52fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga765974bc8cdcd9ade8d9b065a55f52fa">PWMC_GetPhaseCurrents</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="structab__t.html">ab_t</a> *Iab)</td></tr>
<tr class="memdesc:ga765974bc8cdcd9ade8d9b065a55f52fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the phase current of the motor as read by the ADC (in s16A unit).  <a href="group__pwm__curr__fdbk.html#ga765974bc8cdcd9ade8d9b065a55f52fa">More...</a><br /></td></tr>
<tr class="separator:ga765974bc8cdcd9ade8d9b065a55f52fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b3d3aa760c7b97a5c336716b6093cd"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gaf1b3d3aa760c7b97a5c336716b6093cd">PWMC_SetPhaseVoltage</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="structalphabeta__t.html">alphabeta_t</a> Valfa_beta)</td></tr>
<tr class="memdesc:gaf1b3d3aa760c7b97a5c336716b6093cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts input voltages \( V_{\alpha} \) and \( V_{\beta} \) into PWM duty cycles and feed them to the inverter.  <a href="group__pwm__curr__fdbk.html#gaf1b3d3aa760c7b97a5c336716b6093cd">More...</a><br /></td></tr>
<tr class="separator:gaf1b3d3aa760c7b97a5c336716b6093cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad316538b0bf3e24657fbef628c156340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gad316538b0bf3e24657fbef628c156340">PWMC_SwitchOffPWM</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gad316538b0bf3e24657fbef628c156340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches PWM generation off, inactivating the outputs.  <a href="group__pwm__curr__fdbk.html#gad316538b0bf3e24657fbef628c156340">More...</a><br /></td></tr>
<tr class="separator:gad316538b0bf3e24657fbef628c156340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767fcdde0555553531794091e8d04329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga767fcdde0555553531794091e8d04329">PWMC_SwitchOnPWM</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga767fcdde0555553531794091e8d04329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables PWM generation on the proper Timer peripheral.  <a href="group__pwm__curr__fdbk.html#ga767fcdde0555553531794091e8d04329">More...</a><br /></td></tr>
<tr class="separator:ga767fcdde0555553531794091e8d04329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83763a95a39473bc70c395d3b59baefb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga83763a95a39473bc70c395d3b59baefb">PWMC_CurrentReadingCalibr</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="group__pwm__curr__fdbk.html#gafbeb53b9dd2d70202e5d4fffe5aa8407">CRCAction_t</a> action)</td></tr>
<tr class="memdesc:ga83763a95a39473bc70c395d3b59baefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrates ADC current conversions by reading the offset voltage present on ADC pins when no motor current is flowing in.  <a href="group__pwm__curr__fdbk.html#ga83763a95a39473bc70c395d3b59baefb">More...</a><br /></td></tr>
<tr class="separator:ga83763a95a39473bc70c395d3b59baefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45634af68a504aad3a36e4921e11c03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gae45634af68a504aad3a36e4921e11c03">PWMC_TurnOnLowSides</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, uint32_t ticks)</td></tr>
<tr class="memdesc:gae45634af68a504aad3a36e4921e11c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches power stage Low Sides transistors on.  <a href="group__pwm__curr__fdbk.html#gae45634af68a504aad3a36e4921e11c03">More...</a><br /></td></tr>
<tr class="separator:gae45634af68a504aad3a36e4921e11c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae932431c0ac73f7d91372dfa5969efe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gae932431c0ac73f7d91372dfa5969efe4">PWMC_SetOffsetCalib</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *offsets)</td></tr>
<tr class="memdesc:gae932431c0ac73f7d91372dfa5969efe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the calibrated <code>offsets</code> for each of the phases in the <code>pHandle</code> handler. In case of single shunt only phase A is relevant.  <a href="group__pwm__curr__fdbk.html#gae932431c0ac73f7d91372dfa5969efe4">More...</a><br /></td></tr>
<tr class="separator:gae932431c0ac73f7d91372dfa5969efe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7820f48b556999239695d0bb235f8d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gaa7820f48b556999239695d0bb235f8d2">PWMC_GetOffsetCalib</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *offsets)</td></tr>
<tr class="memdesc:gaa7820f48b556999239695d0bb235f8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the calibrated <code>offsets</code> for each of the phases in the <code>pHandle</code> handler. In case of single shunt only phase A is relevant.  <a href="group__pwm__curr__fdbk.html#gaa7820f48b556999239695d0bb235f8d2">More...</a><br /></td></tr>
<tr class="separator:gaa7820f48b556999239695d0bb235f8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35355c5f38a258e2bf52c45b2ab8f270"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga35355c5f38a258e2bf52c45b2ab8f270">PWMC_CheckOverCurrent</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga35355c5f38a258e2bf52c45b2ab8f270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an overcurrent has occured since the last call to this function.  <a href="group__pwm__curr__fdbk.html#ga35355c5f38a258e2bf52c45b2ab8f270">More...</a><br /></td></tr>
<tr class="separator:ga35355c5f38a258e2bf52c45b2ab8f270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582afe90688aa532aad0bf87e79c1e9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga582afe90688aa532aad0bf87e79c1e9b">PWMC_OCPSetReferenceVoltage</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, uint16_t hDACVref)</td></tr>
<tr class="memdesc:ga582afe90688aa532aad0bf87e79c1e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the over current threshold through the DAC reference voltage.  <a href="group__pwm__curr__fdbk.html#ga582afe90688aa532aad0bf87e79c1e9b">More...</a><br /></td></tr>
<tr class="separator:ga582afe90688aa532aad0bf87e79c1e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fca8a148b564fb8fa905b9541de04d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga4fca8a148b564fb8fa905b9541de04d3">PWMC_GetTurnOnLowSidesAction</a> (const <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga4fca8a148b564fb8fa905b9541de04d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the satus of TurnOnLowSides action.  <a href="group__pwm__curr__fdbk.html#ga4fca8a148b564fb8fa905b9541de04d3">More...</a><br /></td></tr>
<tr class="separator:ga4fca8a148b564fb8fa905b9541de04d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac63d74c5196a795e86f111e105f91b47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gac63d74c5196a795e86f111e105f91b47">PWMC_DPWM_ModeEnable</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gac63d74c5196a795e86f111e105f91b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables Discontinuous PWM mode using the <code>pHandle</code> PWMC component.  <a href="group__pwm__curr__fdbk.html#gac63d74c5196a795e86f111e105f91b47">More...</a><br /></td></tr>
<tr class="separator:gac63d74c5196a795e86f111e105f91b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fb9669147463202ff8ea9289eb317d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gac6fb9669147463202ff8ea9289eb317d">PWMC_DPWM_ModeDisable</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gac6fb9669147463202ff8ea9289eb317d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables Discontinuous PWM mode using the <code>pHandle</code> PWMC component.  <a href="group__pwm__curr__fdbk.html#gac6fb9669147463202ff8ea9289eb317d">More...</a><br /></td></tr>
<tr class="separator:gac6fb9669147463202ff8ea9289eb317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3281f3f977d5ae09fcd3d195226a25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga8b3281f3f977d5ae09fcd3d195226a25">PWMC_GetDPWM_Mode</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga8b3281f3f977d5ae09fcd3d195226a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of the Discontinuous PWM Mode stored in the <code>pHandle</code> PWMC component.  <a href="group__pwm__curr__fdbk.html#ga8b3281f3f977d5ae09fcd3d195226a25">More...</a><br /></td></tr>
<tr class="separator:ga8b3281f3f977d5ae09fcd3d195226a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5408c6f8da313252d695b1e03b654d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gaa5408c6f8da313252d695b1e03b654d8">PWMC_RLDetectionModeEnable</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gaa5408c6f8da313252d695b1e03b654d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the RL detection mode by calling the function in <code>pHandle</code> PWMC component.  <a href="group__pwm__curr__fdbk.html#gaa5408c6f8da313252d695b1e03b654d8">More...</a><br /></td></tr>
<tr class="separator:gaa5408c6f8da313252d695b1e03b654d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0ac8d95be39f992ee035b1f43d5230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga1a0ac8d95be39f992ee035b1f43d5230">PWMC_RLDetectionModeDisable</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga1a0ac8d95be39f992ee035b1f43d5230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the RL detection mode by calling the function in <code>pHandle</code> PWMC component.  <a href="group__pwm__curr__fdbk.html#ga1a0ac8d95be39f992ee035b1f43d5230">More...</a><br /></td></tr>
<tr class="separator:ga1a0ac8d95be39f992ee035b1f43d5230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88cceefe7d0c400e9fd97181ddee3185"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga88cceefe7d0c400e9fd97181ddee3185">PWMC_RLDetectionModeSetDuty</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, uint16_t hDuty)</td></tr>
<tr class="memdesc:ga88cceefe7d0c400e9fd97181ddee3185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PWM duty cycle to apply in the RL Detection mode.  <a href="group__pwm__curr__fdbk.html#ga88cceefe7d0c400e9fd97181ddee3185">More...</a><br /></td></tr>
<tr class="separator:ga88cceefe7d0c400e9fd97181ddee3185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0061846eae3e94cc0acd1a899be9217e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga0061846eae3e94cc0acd1a899be9217e">PWMC_SetAlignFlag</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, uint8_t flag)</td></tr>
<tr class="memdesc:ga0061846eae3e94cc0acd1a899be9217e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the aligned motor flag.  <a href="group__pwm__curr__fdbk.html#ga0061846eae3e94cc0acd1a899be9217e">More...</a><br /></td></tr>
<tr class="separator:ga0061846eae3e94cc0acd1a899be9217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad48a54e38dbc69bdede46cebb167380f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gad48a54e38dbc69bdede46cebb167380f">PWMC_RegisterGetPhaseCurrentsCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#gad9470fcb01290e562fb5fff247f4ea3f">PWMC_GetPhaseCurr_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gad48a54e38dbc69bdede46cebb167380f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to get phases current.  <a href="group__pwm__curr__fdbk.html#gad48a54e38dbc69bdede46cebb167380f">More...</a><br /></td></tr>
<tr class="separator:gad48a54e38dbc69bdede46cebb167380f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8e53638dbad492b047cb2e15d7f4654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gab8e53638dbad492b047cb2e15d7f4654">PWMC_RegisterSwitchOffPwmCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gab8e53638dbad492b047cb2e15d7f4654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to switch PWM generation off.  <a href="group__pwm__curr__fdbk.html#gab8e53638dbad492b047cb2e15d7f4654">More...</a><br /></td></tr>
<tr class="separator:gab8e53638dbad492b047cb2e15d7f4654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2853db7fe4d4cbb23100986c35580b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga2853db7fe4d4cbb23100986c35580b58">PWMC_RegisterSwitchonPwmCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga2853db7fe4d4cbb23100986c35580b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to switch PWM generation on.  <a href="group__pwm__curr__fdbk.html#ga2853db7fe4d4cbb23100986c35580b58">More...</a><br /></td></tr>
<tr class="separator:ga2853db7fe4d4cbb23100986c35580b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41d0f1ecfe973b536d257bf53889e9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gaf41d0f1ecfe973b536d257bf53889e9f">PWMC_RegisterReadingCalibrationCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gaf41d0f1ecfe973b536d257bf53889e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to execute a calibration of the current sensing system.  <a href="group__pwm__curr__fdbk.html#gaf41d0f1ecfe973b536d257bf53889e9f">More...</a><br /></td></tr>
<tr class="separator:gaf41d0f1ecfe973b536d257bf53889e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa3ee21a600ccc784fd5ec48b55b3dca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gaaa3ee21a600ccc784fd5ec48b55b3dca">PWMC_RegisterTurnOnLowSidesCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga8ccf5e51ae37934d1ffe4702dab2ed12">PWMC_TurnOnLowSides_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gaaa3ee21a600ccc784fd5ec48b55b3dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to turn low sides on.  <a href="group__pwm__curr__fdbk.html#gaaa3ee21a600ccc784fd5ec48b55b3dca">More...</a><br /></td></tr>
<tr class="separator:gaaa3ee21a600ccc784fd5ec48b55b3dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeea10318096fff184c13368de07d3c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gaaeea10318096fff184c13368de07d3c5">PWMC_RegisterSampPointSectXCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#gadf73746ea2bb4c532979b18c95f598e5">PWMC_SetSampPointSectX_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gaaeea10318096fff184c13368de07d3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to compute ADC sampling point.  <a href="group__pwm__curr__fdbk.html#gaaeea10318096fff184c13368de07d3c5">More...</a><br /></td></tr>
<tr class="separator:gaaeea10318096fff184c13368de07d3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dd7402217694e2363871588ffd7bf47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga6dd7402217694e2363871588ffd7bf47">PWMC_RegisterIsOverCurrentOccurredCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga0a54e1741e0569bc136254655adfb548">PWMC_OverCurr_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga6dd7402217694e2363871588ffd7bf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to check the overcurrent status.  <a href="group__pwm__curr__fdbk.html#ga6dd7402217694e2363871588ffd7bf47">More...</a><br /></td></tr>
<tr class="separator:ga6dd7402217694e2363871588ffd7bf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga707e31c7ced1ae2ab1c00657f0ab90eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga707e31c7ced1ae2ab1c00657f0ab90eb">PWMC_RegisterOCPSetRefVoltageCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga6deba4698c817309573dde4acb9a167b">PWMC_SetOcpRefVolt_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga707e31c7ced1ae2ab1c00657f0ab90eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to set the reference voltage for the overcurrent protection.  <a href="group__pwm__curr__fdbk.html#ga707e31c7ced1ae2ab1c00657f0ab90eb">More...</a><br /></td></tr>
<tr class="separator:ga707e31c7ced1ae2ab1c00657f0ab90eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c83c521f5321fd29bb5c913cdcb20a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga5c83c521f5321fd29bb5c913cdcb20a4">PWMC_RegisterRLDetectionModeEnableCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga5c83c521f5321fd29bb5c913cdcb20a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to enable the R/L detection mode.  <a href="group__pwm__curr__fdbk.html#ga5c83c521f5321fd29bb5c913cdcb20a4">More...</a><br /></td></tr>
<tr class="separator:ga5c83c521f5321fd29bb5c913cdcb20a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70251c1f389d67326351ef8a98c116a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga70251c1f389d67326351ef8a98c116a0">PWMC_RegisterRLDetectionModeDisableCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga70251c1f389d67326351ef8a98c116a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to disable the R/L detection mode.  <a href="group__pwm__curr__fdbk.html#ga70251c1f389d67326351ef8a98c116a0">More...</a><br /></td></tr>
<tr class="separator:ga70251c1f389d67326351ef8a98c116a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9229a31aa4c20ea265b65e6a98629f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gad9229a31aa4c20ea265b65e6a98629f9">PWMC_RegisterRLDetectionModeSetDutyCallBack</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5fabe32a2771ace08a118d21d46bfbe7">PWMC_RLDetectSetDuty_Cb_t</a> pCallBack, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gad9229a31aa4c20ea265b65e6a98629f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Callback that the PWMC component shall invoke to set the duty cycle for the R/L detection mode.  <a href="group__pwm__curr__fdbk.html#gad9229a31aa4c20ea265b65e6a98629f9">More...</a><br /></td></tr>
<tr class="separator:gad9229a31aa4c20ea265b65e6a98629f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab461b4cdbc5f354106c827244606236c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#gab461b4cdbc5f354106c827244606236c">PWMC_Clear</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gab461b4cdbc5f354106c827244606236c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to clear variables in CPWMC.  <a href="group__pwm__curr__fdbk.html#gab461b4cdbc5f354106c827244606236c">More...</a><br /></td></tr>
<tr class="separator:gab461b4cdbc5f354106c827244606236c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151bae7eb91af9261c9f7e4ee1848b95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga151bae7eb91af9261c9f7e4ee1848b95">PWMC_CalcPhaseCurrentsEst</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="structqd__t.html">qd_t</a> Iqd, int16_t hElAngledpp)</td></tr>
<tr class="memdesc:ga151bae7eb91af9261c9f7e4ee1848b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts input currents components Iqd into estimated currents Ia, Ib and Ic.  <a href="group__pwm__curr__fdbk.html#ga151bae7eb91af9261c9f7e4ee1848b95">More...</a><br /></td></tr>
<tr class="separator:ga151bae7eb91af9261c9f7e4ee1848b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cbb6ef4b5fe88fb68a4cf0287971506"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__curr__fdbk.html#ga5cbb6ef4b5fe88fb68a4cf0287971506">PWMC_SetPhaseVoltage_OVM</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="structalphabeta__t.html">alphabeta_t</a> Valfa_beta)</td></tr>
<tr class="memdesc:ga5cbb6ef4b5fe88fb68a4cf0287971506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts input voltage components \( V_{\alpha} \) and \( V_{\beta} \) into duty cycles and feeds them to the inverter with overmodulation function.  <a href="group__pwm__curr__fdbk.html#ga5cbb6ef4b5fe88fb68a4cf0287971506">More...</a><br /></td></tr>
<tr class="separator:ga5cbb6ef4b5fe88fb68a4cf0287971506"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >PWM &amp; Current Feedback components of the Motor Control SDK. </p>
<p >These components fulfill two functions in a Motor Control subsystem:</p>
<ul>
<li>The generation of the Space Vector Pulse Width Modulation on the motor's phases</li>
<li>The sampling of the actual motor's phases current</li>
</ul>
<p >Both these features are closely related as the instants when the values of the phase currents should be sampled by the ADC channels are basically triggered by the timers used to generate the duty cycles for the PWM.</p>
<p >Several implementation of PWM and Current Feedback components are provided by the Motor Control SDK to account for the specificities of the application:</p>
<ul>
<li>The selected MCU: the number of ADCs available on a given MCU, the presence of internal comparators or OpAmps, for instance, lead to different implementation of this feature</li>
<li>The Current sensing topology also has an impact on the firmware: implementations are provided for Insulated Current Sensors, Single Shunt and Three Shunt resistors current sensing topologies</li>
</ul>
<p >The choice of the implementation mostly depend on these two factors and is performed by the Motor Control Workbench tool.</p>
<p >All these implementations are built on a base PWM &amp; Current Feedback component that they extend and that provides the functions and data that are common to all of them. This base component is never used directly as it does not provide a complete implementation of the features. Rather, its handle structure (<a class="el" href="struct_p_w_m_c___handle.html" title="This structure is used to handle the data of an instance of the PWM &amp; Current Feedback component.">PWMC_Handle</a>) is reused by all the PWM &amp; Current Feedback specific implementations and the functions it provides form the API of the PWM and Current feedback feature. Calling them results in calling functions of the component that actually implement the feature. See <a class="el" href="struct_p_w_m_c___handle.html" title="This structure is used to handle the data of an instance of the PWM &amp; Current Feedback component.">PWMC_Handle</a> for more details on this mechanism. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gabe7381a768e880cca363cbfba4ee087d" name="gabe7381a768e880cca363cbfba4ee087d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe7381a768e880cca363cbfba4ee087d">&#9670;&#160;</a></span>PWMC_Generic_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* PWMC_Generic_Cb_t) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer on callback functions used by PWMC components. </p>
<p >This type is needed because the actual functions to use can change at run-time.</p>
<p >See the following items:</p><ul>
<li><a class="el" href="struct_p_w_m_c___handle.html#a0ee494b8d5699faf7b1c95b550ec78eb">PWMC_Handle::pFctSwitchOffPwm</a></li>
<li><a class="el" href="struct_p_w_m_c___handle.html#a77af8fd0d04d8231154b70a0d1c70299">PWMC_Handle::pFctSwitchOnPwm</a></li>
<li><a class="el" href="struct_p_w_m_c___handle.html#abed8e6951211f2de1e4ec761825c7331">PWMC_Handle::pFctCurrReadingCalib</a></li>
<li><a class="el" href="struct_p_w_m_c___handle.html#a73f048f094ddcd21dc6f087cc09b4400">PWMC_Handle::pFctRLDetectionModeEnable</a></li>
<li><a class="el" href="struct_p_w_m_c___handle.html#a1ebae232bacb13e4cfbbc594e9a64d36">PWMC_Handle::pFctRLDetectionModeDisable</a> </li>
</ul>

</div>
</div>
<a id="ga1851d94e86fc6adfdf2a4ed5567e9162" name="ga1851d94e86fc6adfdf2a4ed5567e9162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1851d94e86fc6adfdf2a4ed5567e9162">&#9670;&#160;</a></span>PWMC_GetOffsetCalib_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* PWMC_GetOffsetCalib_Cb_t) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *offsets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer on the function provided by the PMWC component instance to get the calibrated offsets in RL detection mode. </p>
<p >This type is needed because the actual function to use can change at run-time </p>

</div>
</div>
<a id="gad9470fcb01290e562fb5fff247f4ea3f" name="gad9470fcb01290e562fb5fff247f4ea3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9470fcb01290e562fb5fff247f4ea3f">&#9670;&#160;</a></span>PWMC_GetPhaseCurr_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* PWMC_GetPhaseCurr_Cb_t) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="structab__t.html">ab_t</a> *Iab)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer on the function provided by the PMWC component instance to get the phase current. </p>
<p >This type is needed because the actual function to use can change at run-time (See <a class="el" href="struct_p_w_m_c___handle.html#a6378ca9a7f3f1463775e5441010d607b">PWMC_Handle::pFctGetPhaseCurrents</a>). </p>

</div>
</div>
<a id="ga0a54e1741e0569bc136254655adfb548" name="ga0a54e1741e0569bc136254655adfb548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a54e1741e0569bc136254655adfb548">&#9670;&#160;</a></span>PWMC_OverCurr_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* PWMC_OverCurr_Cb_t) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer on the function provided by the PMWC component instance to check if an over current condition has occured. </p>
<p >This type is needed because the actual function to use can change at run-time (See <a class="el" href="struct_p_w_m_c___handle.html#aa2de779585695cf98a9cf573957cfee9">PWMC_Handle::pFctIsOverCurrentOccurred</a>). </p>

</div>
</div>
<a id="ga5fabe32a2771ace08a118d21d46bfbe7" name="ga5fabe32a2771ace08a118d21d46bfbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fabe32a2771ace08a118d21d46bfbe7">&#9670;&#160;</a></span>PWMC_RLDetectSetDuty_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* PWMC_RLDetectSetDuty_Cb_t) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, uint16_t hDuty)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer on the function provided by the PMWC component instance to set the PWM duty cycle in RL detection mode. </p>
<p >This type is needed because the actual function to use can change at run-time (See <a class="el" href="struct_p_w_m_c___handle.html#a0cc6a77f2bb40c98a2c1ba5434ea4719">PWMC_Handle::pFctRLDetectionModeSetDuty</a>). </p>

</div>
</div>
<a id="ga6deba4698c817309573dde4acb9a167b" name="ga6deba4698c817309573dde4acb9a167b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6deba4698c817309573dde4acb9a167b">&#9670;&#160;</a></span>PWMC_SetOcpRefVolt_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* PWMC_SetOcpRefVolt_Cb_t) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, uint16_t hDACVref)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer on the function provided by the PMWC component instance to set the reference voltage for the over current protection. </p>
<p >This type is needed because the actual function to use can change at run-time (See <a class="el" href="struct_p_w_m_c___handle.html#a2e293b0d3f640a9ae4916b4fb9add0ff">PWMC_Handle::pFctOCPSetReferenceVoltage</a>). </p>

</div>
</div>
<a id="ga0e8f4b36a3a33c9e6818a57419ee86fa" name="ga0e8f4b36a3a33c9e6818a57419ee86fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e8f4b36a3a33c9e6818a57419ee86fa">&#9670;&#160;</a></span>PWMC_SetOffsetCalib_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* PWMC_SetOffsetCalib_Cb_t) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *offsets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer on the function provided by the PMWC component instance to set the calibrated offsets in RL detection mode. </p>
<p >This type is needed because the actual function to use can change at run-time (See <a class="el" href="struct_p_w_m_c___handle.html#a52ab3de7505f71740bbbd0b8c54d799a">PWMC_Handle::pFctSetOffsetCalib</a>). </p>

</div>
</div>
<a id="gadf73746ea2bb4c532979b18c95f598e5" name="gadf73746ea2bb4c532979b18c95f598e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf73746ea2bb4c532979b18c95f598e5">&#9670;&#160;</a></span>PWMC_SetSampPointSectX_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* PWMC_SetSampPointSectX_Cb_t) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer on the functions provided by the PMWC component instance to set the ADC sampling point for each sectors. </p>
<p >This type is needed because the actual function to use can change at run-time. See:</p><ul>
<li>PWMC_Handle::pFctSetADCSampPointSect1</li>
<li>PWMC_Handle::pFctSetADCSampPointSect2</li>
<li>PWMC_Handle::pFctSetADCSampPointSect3</li>
<li>PWMC_Handle::pFctSetADCSampPointSect4</li>
<li>PWMC_Handle::pFctSetADCSampPointSect5</li>
<li>PWMC_Handle::pFctSetADCSampPointSect6 </li>
</ul>

</div>
</div>
<a id="ga8ccf5e51ae37934d1ffe4702dab2ed12" name="ga8ccf5e51ae37934d1ffe4702dab2ed12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ccf5e51ae37934d1ffe4702dab2ed12">&#9670;&#160;</a></span>PWMC_TurnOnLowSides_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* PWMC_TurnOnLowSides_Cb_t) (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandle, const uint32_t ticks)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer on the function provided by the PMWC component instance to set low sides ON. </p>
<p >This type is needed because the actual function to use can change at run-time (See <a class="el" href="struct_p_w_m_c___handle.html#ab37c3cf0ee73bd6d9658969295bb58a7">PWMC_Handle::pFctTurnOnLowSides</a>). </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gafbeb53b9dd2d70202e5d4fffe5aa8407" name="gafbeb53b9dd2d70202e5d4fffe5aa8407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbeb53b9dd2d70202e5d4fffe5aa8407">&#9670;&#160;</a></span>CRCAction_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__pwm__curr__fdbk.html#gafbeb53b9dd2d70202e5d4fffe5aa8407">CRCAction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current reading calibration definition. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafbeb53b9dd2d70202e5d4fffe5aa8407ad8f15e9e15b4d50f6688663116764bbc" name="ggafbeb53b9dd2d70202e5d4fffe5aa8407ad8f15e9e15b4d50f6688663116764bbc"></a>CRC_START&#160;</td><td class="fielddoc"><p >Initializes the current reading calibration. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafbeb53b9dd2d70202e5d4fffe5aa8407a4ff690a9c0cfc004d96b5b7f7cd3b045" name="ggafbeb53b9dd2d70202e5d4fffe5aa8407a4ff690a9c0cfc004d96b5b7f7cd3b045"></a>CRC_EXEC&#160;</td><td class="fielddoc"><p >Executes the current reading calibration. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad3468ec3f8e30a5e55b7e125e49c89c8" name="gad3468ec3f8e30a5e55b7e125e49c89c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3468ec3f8e30a5e55b7e125e49c89c8">&#9670;&#160;</a></span>OVM_Mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__pwm__curr__fdbk.html#gad3468ec3f8e30a5e55b7e125e49c89c8">OVM_Mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overmodulation modes. Specified in <a class="el" href="md_docs_overmodulation.html">Overmodulation</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad3468ec3f8e30a5e55b7e125e49c89c8a410c3093ee5dbfc8082d7d088b609bfc" name="ggad3468ec3f8e30a5e55b7e125e49c89c8a410c3093ee5dbfc8082d7d088b609bfc"></a>OVM_LINEAR&#160;</td><td class="fielddoc"><p >Linear mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad3468ec3f8e30a5e55b7e125e49c89c8aa179f4f3de87428c7e0a783b1287e5e1" name="ggad3468ec3f8e30a5e55b7e125e49c89c8aa179f4f3de87428c7e0a783b1287e5e1"></a>OVM_1&#160;</td><td class="fielddoc"><p >Overmodulation mode 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad3468ec3f8e30a5e55b7e125e49c89c8a2801a969dd6fdc87d52d2987402db004" name="ggad3468ec3f8e30a5e55b7e125e49c89c8a2801a969dd6fdc87d52d2987402db004"></a>OVM_2&#160;</td><td class="fielddoc"><p >Overmodulation mode 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad3468ec3f8e30a5e55b7e125e49c89c8ad8f16809b759bec11beeb489a4f08237" name="ggad3468ec3f8e30a5e55b7e125e49c89c8ad8f16809b759bec11beeb489a4f08237"></a>OVM_ERROR&#160;</td><td class="fielddoc"><p >Error output. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga151bae7eb91af9261c9f7e4ee1848b95" name="ga151bae7eb91af9261c9f7e4ee1848b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga151bae7eb91af9261c9f7e4ee1848b95">&#9670;&#160;</a></span>PWMC_CalcPhaseCurrentsEst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMC_CalcPhaseCurrentsEst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td>
          <td class="paramname"><em>Iqd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>hElAngledpp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts input currents components Iqd into estimated currents Ia, Ib and Ic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">Iqd</td><td>Structure that will receive Iq and Id currents. </td></tr>
    <tr><td class="paramname">hElAngledpp</td><td>Electrical angle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35355c5f38a258e2bf52c45b2ab8f270" name="ga35355c5f38a258e2bf52c45b2ab8f270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35355c5f38a258e2bf52c45b2ab8f270">&#9670;&#160;</a></span>PWMC_CheckOverCurrent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t PWMC_CheckOverCurrent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an overcurrent has occured since the last call to this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___m_c___type.html#ga1e85035b6829c4aa817cc7f9c6056a23" title="Error: Emergency input (Over current).">MC_BREAK_IN</a></td><td>if an overcurrent has occurred since last call, and <a class="el" href="group___m_c___type.html#ga6d39359a080c884fa7512bc2b444e43e" title="No error.">MC_NO_FAULTS</a> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab461b4cdbc5f354106c827244606236c" name="gab461b4cdbc5f354106c827244606236c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab461b4cdbc5f354106c827244606236c">&#9670;&#160;</a></span>PWMC_Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMC_Clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to clear variables in CPWMC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83763a95a39473bc70c395d3b59baefb" name="ga83763a95a39473bc70c395d3b59baefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83763a95a39473bc70c395d3b59baefb">&#9670;&#160;</a></span>PWMC_CurrentReadingCalibr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool PWMC_CurrentReadingCalibr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#gafbeb53b9dd2d70202e5d4fffe5aa8407">CRCAction_t</a>&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibrates ADC current conversions by reading the offset voltage present on ADC pins when no motor current is flowing in. </p>
<p >This function should be called before each motor start-up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">action</td><td>Can be <a class="el" href="group__pwm__curr__fdbk.html#ggafbeb53b9dd2d70202e5d4fffe5aa8407ad8f15e9e15b4d50f6688663116764bbc">CRC_START</a> to initialize the offset calibration or <a class="el" href="group__pwm__curr__fdbk.html#ggafbeb53b9dd2d70202e5d4fffe5aa8407a4ff690a9c0cfc004d96b5b7f7cd3b045">CRC_EXEC</a> to execute the offset calibration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the current calibration has been completed, <b>false</b> if it is still ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6fb9669147463202ff8ea9289eb317d" name="gac6fb9669147463202ff8ea9289eb317d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6fb9669147463202ff8ea9289eb317d">&#9670;&#160;</a></span>PWMC_DPWM_ModeDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_DPWM_ModeDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables Discontinuous PWM mode using the <code>pHandle</code> PWMC component. </p>

</div>
</div>
<a id="gac63d74c5196a795e86f111e105f91b47" name="gac63d74c5196a795e86f111e105f91b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac63d74c5196a795e86f111e105f91b47">&#9670;&#160;</a></span>PWMC_DPWM_ModeEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_DPWM_ModeEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables Discontinuous PWM mode using the <code>pHandle</code> PWMC component. </p>

</div>
</div>
<a id="ga8b3281f3f977d5ae09fcd3d195226a25" name="ga8b3281f3f977d5ae09fcd3d195226a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b3281f3f977d5ae09fcd3d195226a25">&#9670;&#160;</a></span>PWMC_GetDPWM_Mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool PWMC_GetDPWM_Mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of the Discontinuous PWM Mode stored in the <code>pHandle</code> PWMC component. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if DPWM Mode is enabled, <b>false</b> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa7820f48b556999239695d0bb235f8d2" name="gaa7820f48b556999239695d0bb235f8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7820f48b556999239695d0bb235f8d2">&#9670;&#160;</a></span>PWMC_GetOffsetCalib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_GetOffsetCalib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the calibrated <code>offsets</code> for each of the phases in the <code>pHandle</code> handler. In case of single shunt only phase A is relevant. </p>

</div>
</div>
<a id="ga765974bc8cdcd9ade8d9b065a55f52fa" name="ga765974bc8cdcd9ade8d9b065a55f52fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga765974bc8cdcd9ade8d9b065a55f52fa">&#9670;&#160;</a></span>PWMC_GetPhaseCurrents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_GetPhaseCurrents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structab__t.html">ab_t</a> *&#160;</td>
          <td class="paramname"><em>Iab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the phase current of the motor as read by the ADC (in s16A unit). </p>
<p >Returns the current values of phases A &amp; B. Phase C current can be deduced thanks to the formula:</p>
<p class="formulaDsp">
\[
I_{C} = -I_{A} - I_{B}
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">Iab</td><td>Pointer to the structure that will receive motor current of phases A &amp; B in ElectricalValue format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4fca8a148b564fb8fa905b9541de04d3" name="ga4fca8a148b564fb8fa905b9541de04d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fca8a148b564fb8fa905b9541de04d3">&#9670;&#160;</a></span>PWMC_GetTurnOnLowSidesAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool PWMC_GetTurnOnLowSidesAction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the satus of TurnOnLowSides action. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>State of TurnOnLowSides action: <b>true</b> if TurnOnLowSides action is active, <b>false</b> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga582afe90688aa532aad0bf87e79c1e9b" name="ga582afe90688aa532aad0bf87e79c1e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga582afe90688aa532aad0bf87e79c1e9b">&#9670;&#160;</a></span>PWMC_OCPSetReferenceVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_OCPSetReferenceVoltage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDACVref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the over current threshold through the DAC reference voltage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">hDACVref</td><td>Value of DAC reference voltage to be applied expressed as a 16bit unsigned integer. Min value: 0 (0 V) Max value: 65536 (VDD_DAC) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad48a54e38dbc69bdede46cebb167380f" name="gad48a54e38dbc69bdede46cebb167380f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad48a54e38dbc69bdede46cebb167380f">&#9670;&#160;</a></span>PWMC_RegisterGetPhaseCurrentsCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterGetPhaseCurrentsCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#gad9470fcb01290e562fb5fff247f4ea3f">PWMC_GetPhaseCurr_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to get phases current. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the callback to get the phase current. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6dd7402217694e2363871588ffd7bf47" name="ga6dd7402217694e2363871588ffd7bf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dd7402217694e2363871588ffd7bf47">&#9670;&#160;</a></span>PWMC_RegisterIsOverCurrentOccurredCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterIsOverCurrentOccurredCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga0a54e1741e0569bc136254655adfb548">PWMC_OverCurr_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to check the overcurrent status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the callback which checks the overcurrent state. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga707e31c7ced1ae2ab1c00657f0ab90eb" name="ga707e31c7ced1ae2ab1c00657f0ab90eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga707e31c7ced1ae2ab1c00657f0ab90eb">&#9670;&#160;</a></span>PWMC_RegisterOCPSetRefVoltageCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterOCPSetRefVoltageCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga6deba4698c817309573dde4acb9a167b">PWMC_SetOcpRefVolt_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to set the reference voltage for the overcurrent protection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the callback which sets the reference voltage. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf41d0f1ecfe973b536d257bf53889e9f" name="gaf41d0f1ecfe973b536d257bf53889e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf41d0f1ecfe973b536d257bf53889e9f">&#9670;&#160;</a></span>PWMC_RegisterReadingCalibrationCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterReadingCalibrationCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to execute a calibration of the current sensing system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the generic callback. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70251c1f389d67326351ef8a98c116a0" name="ga70251c1f389d67326351ef8a98c116a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70251c1f389d67326351ef8a98c116a0">&#9670;&#160;</a></span>PWMC_RegisterRLDetectionModeDisableCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterRLDetectionModeDisableCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to disable the R/L detection mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the generic callback. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c83c521f5321fd29bb5c913cdcb20a4" name="ga5c83c521f5321fd29bb5c913cdcb20a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c83c521f5321fd29bb5c913cdcb20a4">&#9670;&#160;</a></span>PWMC_RegisterRLDetectionModeEnableCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterRLDetectionModeEnableCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to enable the R/L detection mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the generic callback. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9229a31aa4c20ea265b65e6a98629f9" name="gad9229a31aa4c20ea265b65e6a98629f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9229a31aa4c20ea265b65e6a98629f9">&#9670;&#160;</a></span>PWMC_RegisterRLDetectionModeSetDutyCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterRLDetectionModeSetDutyCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5fabe32a2771ace08a118d21d46bfbe7">PWMC_RLDetectSetDuty_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to set the duty cycle for the R/L detection mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the callback which sets the duty cycle. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaeea10318096fff184c13368de07d3c5" name="gaaeea10318096fff184c13368de07d3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeea10318096fff184c13368de07d3c5">&#9670;&#160;</a></span>PWMC_RegisterSampPointSectXCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterSampPointSectXCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#gadf73746ea2bb4c532979b18c95f598e5">PWMC_SetSampPointSectX_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to compute ADC sampling point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the callback which sets the sampling point depending on the sector. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab8e53638dbad492b047cb2e15d7f4654" name="gab8e53638dbad492b047cb2e15d7f4654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8e53638dbad492b047cb2e15d7f4654">&#9670;&#160;</a></span>PWMC_RegisterSwitchOffPwmCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterSwitchOffPwmCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to switch PWM generation off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the generic callback. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2853db7fe4d4cbb23100986c35580b58" name="ga2853db7fe4d4cbb23100986c35580b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2853db7fe4d4cbb23100986c35580b58">&#9670;&#160;</a></span>PWMC_RegisterSwitchonPwmCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterSwitchonPwmCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#gabe7381a768e880cca363cbfba4ee087d">PWMC_Generic_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to switch PWM generation on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the generic callback. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa3ee21a600ccc784fd5ec48b55b3dca" name="gaaa3ee21a600ccc784fd5ec48b55b3dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa3ee21a600ccc784fd5ec48b55b3dca">&#9670;&#160;</a></span>PWMC_RegisterTurnOnLowSidesCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RegisterTurnOnLowSidesCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga8ccf5e51ae37934d1ffe4702dab2ed12">PWMC_TurnOnLowSides_Cb_t</a>&#160;</td>
          <td class="paramname"><em>pCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Callback that the PWMC component shall invoke to turn low sides on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallBack</td><td>Pointer on the callback which turns low sides on. </td></tr>
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a0ac8d95be39f992ee035b1f43d5230" name="ga1a0ac8d95be39f992ee035b1f43d5230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0ac8d95be39f992ee035b1f43d5230">&#9670;&#160;</a></span>PWMC_RLDetectionModeDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RLDetectionModeDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the RL detection mode by calling the function in <code>pHandle</code> PWMC component. </p>

</div>
</div>
<a id="gaa5408c6f8da313252d695b1e03b654d8" name="gaa5408c6f8da313252d695b1e03b654d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5408c6f8da313252d695b1e03b654d8">&#9670;&#160;</a></span>PWMC_RLDetectionModeEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_RLDetectionModeEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the RL detection mode by calling the function in <code>pHandle</code> PWMC component. </p>

</div>
</div>
<a id="ga88cceefe7d0c400e9fd97181ddee3185" name="ga88cceefe7d0c400e9fd97181ddee3185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88cceefe7d0c400e9fd97181ddee3185">&#9670;&#160;</a></span>PWMC_RLDetectionModeSetDuty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t PWMC_RLDetectionModeSetDuty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDuty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the PWM duty cycle to apply in the RL Detection mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
    <tr><td class="paramname">hDuty</td><td>Duty cycle to apply, written in uint16_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___m_c___type.html#ga53baebe4a3ba319ccc2beeebbcc4aefb" title="No error.">MC_NO_ERROR</a></td><td>if the Duty Cycle could be applied on time for the next PWM period. Returns <a class="el" href="group___m_c___type.html#gae6e765beffae40be17d8676f836fadb2" title="Error: FOC rate to high.">MC_DURATION</a> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0061846eae3e94cc0acd1a899be9217e" name="ga0061846eae3e94cc0acd1a899be9217e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0061846eae3e94cc0acd1a899be9217e">&#9670;&#160;</a></span>PWMC_SetAlignFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMC_SetAlignFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the aligned motor flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWMC component. </td></tr>
    <tr><td class="paramname">flag</td><td>Value to be applied as an 8 bit unsigned integer. 1: motor is in aligned stage. 2: motor is not in aligned stage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae932431c0ac73f7d91372dfa5969efe4" name="gae932431c0ac73f7d91372dfa5969efe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae932431c0ac73f7d91372dfa5969efe4">&#9670;&#160;</a></span>PWMC_SetOffsetCalib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_SetOffsetCalib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the calibrated <code>offsets</code> for each of the phases in the <code>pHandle</code> handler. In case of single shunt only phase A is relevant. </p>

</div>
</div>
<a id="gaf1b3d3aa760c7b97a5c336716b6093cd" name="gaf1b3d3aa760c7b97a5c336716b6093cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1b3d3aa760c7b97a5c336716b6093cd">&#9670;&#160;</a></span>PWMC_SetPhaseVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t PWMC_SetPhaseVoltage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalphabeta__t.html">alphabeta_t</a>&#160;</td>
          <td class="paramname"><em>Valfa_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts input voltages \( V_{\alpha} \) and \( V_{\beta} \) into PWM duty cycles and feed them to the inverter. </p>
<p >This function computes the time during which the transistors of each phase are to be switched on in a PWM cycle in order to achieve the reference phase voltage set by <code>Valfa_beta</code>. The function then programs the resulting duty cycles in the related timer channels. It also sets the phase current sampling point for the next PWM cycle accordingly.</p>
<p >This function is used in the FOC frequency loop and needs to complete itself before the next PWM cycle starts in order for the duty cycles it computes to be taken into account. Failing to do so (for instance because the PWM Frequency is too high) results in the function returning <a class="el" href="group___m_c___type.html#gae6e765beffae40be17d8676f836fadb2" title="Error: FOC rate to high.">MC_DURATION</a> which entails a Motor Control Fault that stops the motor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">Valfa_beta</td><td>Voltage Components expressed in the \((\alpha, \beta)\) reference frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___m_c___type.html#ga53baebe4a3ba319ccc2beeebbcc4aefb" title="No error.">MC_NO_ERROR</a></td><td>if no error occurred or <a class="el" href="group___m_c___type.html#gae6e765beffae40be17d8676f836fadb2" title="Error: FOC rate to high.">MC_DURATION</a> if the duty cycles were set too late for being taken into account in the next PWM cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cbb6ef4b5fe88fb68a4cf0287971506" name="ga5cbb6ef4b5fe88fb68a4cf0287971506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cbb6ef4b5fe88fb68a4cf0287971506">&#9670;&#160;</a></span>PWMC_SetPhaseVoltage_OVM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t PWMC_SetPhaseVoltage_OVM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalphabeta__t.html">alphabeta_t</a>&#160;</td>
          <td class="paramname"><em>Valfa_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts input voltage components \( V_{\alpha} \) and \( V_{\beta} \) into duty cycles and feeds them to the inverter with overmodulation function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">Valfa_beta</td><td>Voltage Components expressed in the \((\alpha, \beta)\) reference frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___m_c___type.html#ga53baebe4a3ba319ccc2beeebbcc4aefb" title="No error.">MC_NO_ERROR</a></td><td>if no error occurred or <a class="el" href="group___m_c___type.html#gae6e765beffae40be17d8676f836fadb2" title="Error: FOC rate to high.">MC_DURATION</a> if the duty cycles were set too late for being taken into account in the next PWM cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad316538b0bf3e24657fbef628c156340" name="gad316538b0bf3e24657fbef628c156340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad316538b0bf3e24657fbef628c156340">&#9670;&#160;</a></span>PWMC_SwitchOffPWM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_SwitchOffPWM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches PWM generation off, inactivating the outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga767fcdde0555553531794091e8d04329" name="ga767fcdde0555553531794091e8d04329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga767fcdde0555553531794091e8d04329">&#9670;&#160;</a></span>PWMC_SwitchOnPWM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_SwitchOnPWM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables PWM generation on the proper Timer peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae45634af68a504aad3a36e4921e11c03" name="gae45634af68a504aad3a36e4921e11c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae45634af68a504aad3a36e4921e11c03">&#9670;&#160;</a></span>PWMC_TurnOnLowSides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void PWMC_TurnOnLowSides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches power stage Low Sides transistors on. </p>
<p >This function is meant for charging boot capacitors of the driving section. It has to be called on each motor start-up when using high voltage drivers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">ticks</td><td>Timer ticks value to be applied. Min value: 0 (low sides ON) Max value: PWM_PERIOD_CYCLES/2 (low sides OFF) <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeaabf1bb356c4e30b2a8bb4de7cae9c1" name="gaeaabf1bb356c4e30b2a8bb4de7cae9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaabf1bb356c4e30b2a8bb4de7cae9c1">&#9670;&#160;</a></span>waitForPolarizationEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void waitForPolarizationEnd </td>
          <td>(</td>
          <td class="paramtype">TIM_TypeDef *&#160;</td>
          <td class="paramname"><em>TIMx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>SWerror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>repCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the end of the polarization. </p>
<p >If the polarization exceeds the number of needed PWM cycles, it reports an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TIMx</td><td>Timer used to generate PWM. </td></tr>
    <tr><td class="paramname">SWerror</td><td>Variable used to report a SW error. </td></tr>
    <tr><td class="paramname">repCnt</td><td>Repetition counter value. </td></tr>
    <tr><td class="paramname">cnt</td><td>Polarization counter value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
