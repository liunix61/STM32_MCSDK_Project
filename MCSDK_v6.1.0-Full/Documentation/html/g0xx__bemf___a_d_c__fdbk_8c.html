<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: MCSDK/MCLib/G0xx/Src/g0xx_bemf_ADC_fdbk.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_5ebbea1114bd7627641b9c8b89cd5b2b.html">MCSDK</a></li><li class="navelem"><a class="el" href="dir_79d4adb0498bf053227c39dbd6578f5f.html">MCLib</a></li><li class="navelem"><a class="el" href="dir_b72607a68e31d4d3283361086e037c0c.html">G0xx</a></li><li class="navelem"><a class="el" href="dir_60e784e88e9f3e018b3cca5fa1ec1200.html">Src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">g0xx_bemf_ADC_fdbk.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file provides firmware functions that implement Bemf sensing class to be stantiated when the six-step sensorless driving mode topology is used.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="g0xx__bemf___a_d_c__fdbk_8h.html">g0xx_bemf_ADC_fdbk.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mc__type_8h.html">mc_type.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7dcf7c6ecb1a2dfe1bb43211dde0e80f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga7dcf7c6ecb1a2dfe1bb43211dde0e80f">BADC_Init</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga7dcf7c6ecb1a2dfe1bb43211dde0e80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">It initializes ADC1, DMA and NVIC for three bemf voltages reading.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga7dcf7c6ecb1a2dfe1bb43211dde0e80f">More...</a><br /></td></tr>
<tr class="separator:ga7dcf7c6ecb1a2dfe1bb43211dde0e80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16d1fe93592a6d68c449ed08dc4c9ca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga16d1fe93592a6d68c449ed08dc4c9ca7">BADC_Clear</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga16d1fe93592a6d68c449ed08dc4c9ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the ADC status.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga16d1fe93592a6d68c449ed08dc4c9ca7">More...</a><br /></td></tr>
<tr class="separator:ga16d1fe93592a6d68c449ed08dc4c9ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7eeb20561b4ffcf93fc46c8cf05e23f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaf7eeb20561b4ffcf93fc46c8cf05e23f">BADC_SpeedMeasureOn</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gaf7eeb20561b4ffcf93fc46c8cf05e23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">It enables the speed loop (low frequency) timer.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaf7eeb20561b4ffcf93fc46c8cf05e23f">More...</a><br /></td></tr>
<tr class="separator:gaf7eeb20561b4ffcf93fc46c8cf05e23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70009f6fc85c0dc8783079e99a19dba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga70009f6fc85c0dc8783079e99a19dba7">BADC_SpeedMeasureOff</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga70009f6fc85c0dc8783079e99a19dba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">It disables the speed loop (low frequency) timer.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga70009f6fc85c0dc8783079e99a19dba7">More...</a><br /></td></tr>
<tr class="separator:ga70009f6fc85c0dc8783079e99a19dba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5deba27b8f6543cd76150b9973a0960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gad5deba27b8f6543cd76150b9973a0960">BADC_Start</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle, uint8_t step)</td></tr>
<tr class="memdesc:gad5deba27b8f6543cd76150b9973a0960"><td class="mdescLeft">&#160;</td><td class="mdescRight">It starts bemf ADC conversion of the phase depending on current step.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gad5deba27b8f6543cd76150b9973a0960">More...</a><br /></td></tr>
<tr class="separator:gad5deba27b8f6543cd76150b9973a0960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78af1ff04f60c19f4b13170932f61c4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga78af1ff04f60c19f4b13170932f61c4b">BADC_Stop</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga78af1ff04f60c19f4b13170932f61c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">It stops bemf ADC conversion.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga78af1ff04f60c19f4b13170932f61c4b">More...</a><br /></td></tr>
<tr class="separator:ga78af1ff04f60c19f4b13170932f61c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aef0f7a6b6cc028f885120cb26b1544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga4aef0f7a6b6cc028f885120cb26b1544">BADC_SetSamplingPoint</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandlePWMC, <a class="el" href="struct_speedn_torq_ctrl___handle__t.html">SpeednTorqCtrl_Handle_t</a> *pHandleSTC)</td></tr>
<tr class="memdesc:ga4aef0f7a6b6cc028f885120cb26b1544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the ADC for the current sampling. It means set the sampling point via TIM1_Ch4 value, the ADC sequence and channels.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga4aef0f7a6b6cc028f885120cb26b1544">More...</a><br /></td></tr>
<tr class="separator:ga4aef0f7a6b6cc028f885120cb26b1544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf39116c882a7fed0b0ba4ad5f8c9d60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gadf39116c882a7fed0b0ba4ad5f8c9d60">BADC_IsZcDetected</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHandlePWMC)</td></tr>
<tr class="memdesc:gadf39116c882a7fed0b0ba4ad5f8c9d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">It gets last bemf value and checks for zero crossing detection. It updates speed loop timer and electrical angle accordingly.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gadf39116c882a7fed0b0ba4ad5f8c9d60">More...</a><br /></td></tr>
<tr class="separator:gadf39116c882a7fed0b0ba4ad5f8c9d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f817a0419f9923fb8f982ed0e6ad6cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga5f817a0419f9923fb8f982ed0e6ad6cc">BADC_CalcAvrgMecSpeedUnit</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle, int16_t *pMecSpeedUnit)</td></tr>
<tr class="memdesc:ga5f817a0419f9923fb8f982ed0e6ad6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called - at least - with the same periodicity on which speed control is executed. It computes and returns - through parameter hMecSpeedUnit - the rotor average mechanical speed, expressed in Unit. Average is computed considering a FIFO depth equal to SpeedBufferSizeUnit. Moreover it also computes and returns the reliability state of the sensor.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga5f817a0419f9923fb8f982ed0e6ad6cc">More...</a><br /></td></tr>
<tr class="separator:ga5f817a0419f9923fb8f982ed0e6ad6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac55d6c195cda27c7139d8066ae146f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gabac55d6c195cda27c7139d8066ae146f">BADC_LfTim_UP_IRQHandler</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gabac55d6c195cda27c7139d8066ae146f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of the class to be called when speed loop timer update event occurs It updates the electrical angle accumulator and resets zero crossing detection flag.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gabac55d6c195cda27c7139d8066ae146f">More...</a><br /></td></tr>
<tr class="separator:gabac55d6c195cda27c7139d8066ae146f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2b1080dcf2fc45133af906a268476b"><td class="memItemLeft" align="right" valign="top">__weak bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga0c2b1080dcf2fc45133af906a268476b">BADC_IsSpeedReliable</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga0c2b1080dcf2fc45133af906a268476b"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns false if calculated speed is out of reliability ranges.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga0c2b1080dcf2fc45133af906a268476b">More...</a><br /></td></tr>
<tr class="separator:ga0c2b1080dcf2fc45133af906a268476b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e4dd0497e2aec30ff61901de7924fc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga9e4dd0497e2aec30ff61901de7924fc0">BADC_IsPeriodReliable</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga9e4dd0497e2aec30ff61901de7924fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns false if calculated speed loop timer is out of reliability ranges.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga9e4dd0497e2aec30ff61901de7924fc0">More...</a><br /></td></tr>
<tr class="separator:ga9e4dd0497e2aec30ff61901de7924fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed73244222e539044a088e1335ae1f1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaed73244222e539044a088e1335ae1f1b">BADC_SetDirection</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle, uint8_t direction)</td></tr>
<tr class="memdesc:gaed73244222e539044a088e1335ae1f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">forces the rotation direction  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaed73244222e539044a088e1335ae1f1b">More...</a><br /></td></tr>
<tr class="separator:gaed73244222e539044a088e1335ae1f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43286f6fd372798e5e050ab064a054ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga43286f6fd372798e5e050ab064a054ae">BADC_IsObserverConverged</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga43286f6fd372798e5e050ab064a054ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">It internally performs a checks necessary to state whether the bemf algorithm converged. To be periodically called during motor open-loop ramp-up (e.g. at the same frequency of SPD_CalcElAngle), it returns true if the estimated angle and speed can be considered reliable, false otherwise.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga43286f6fd372798e5e050ab064a054ae">More...</a><br /></td></tr>
<tr class="separator:ga43286f6fd372798e5e050ab064a054ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca2120645a9ca3cb3e76cadbee51b5f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaca2120645a9ca3cb3e76cadbee51b5f4">BADC_SelectAdcChannel</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle, uint8_t Phase)</td></tr>
<tr class="memdesc:gaca2120645a9ca3cb3e76cadbee51b5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">It configures the proper ADC channel according to the current step corresponding to the floating phase. To be periodically called at least at every step change.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaca2120645a9ca3cb3e76cadbee51b5f4">More...</a><br /></td></tr>
<tr class="separator:gaca2120645a9ca3cb3e76cadbee51b5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb54960f0213447cd113c9316c44861"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga1fb54960f0213447cd113c9316c44861">BADC_CalcElAngle</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga1fb54960f0213447cd113c9316c44861"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method updates the estimated electrical angle.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga1fb54960f0213447cd113c9316c44861">More...</a><br /></td></tr>
<tr class="separator:ga1fb54960f0213447cd113c9316c44861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58819153d205b05c8679bcffb65269b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gae58819153d205b05c8679bcffb65269b">BADC_CalcAvrgElSpeedDpp</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gae58819153d205b05c8679bcffb65269b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called - at least - with the same periodicity on which speed control is executed. It computes and update component variable hElSpeedDpp that is estimated average electrical speed expressed in dpp used for instance in observer equations. Average is computed considering a FIFO depth equal to bSpeedBufferSizedpp.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gae58819153d205b05c8679bcffb65269b">More...</a><br /></td></tr>
<tr class="separator:gae58819153d205b05c8679bcffb65269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6e4cf18941ebc1e4e71782beedcd98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaaf6e4cf18941ebc1e4e71782beedcd98">BADC_SetLfTimerRevUp</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle, int16_t hAvrMecSpeedUnit)</td></tr>
<tr class="memdesc:gaaf6e4cf18941ebc1e4e71782beedcd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used during revup phase to synchronize estimated rotor position from Bemf acquisition with imposed virtual speed <br  />
  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaaf6e4cf18941ebc1e4e71782beedcd98">More...</a><br /></td></tr>
<tr class="separator:gaaf6e4cf18941ebc1e4e71782beedcd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61edeb0c711128d31ade66aac22875a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga61edeb0c711128d31ade66aac22875a2">BADC_CalcRevUpDemagTime</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle, <a class="el" href="struct_speedn_torq_ctrl___handle__t.html">SpeednTorqCtrl_Handle_t</a> *pHandleSTC)</td></tr>
<tr class="memdesc:ga61edeb0c711128d31ade66aac22875a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">It calculates and stores in the corresponding variable the demagnetization time in open loop operation <br  />
  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga61edeb0c711128d31ade66aac22875a2">More...</a><br /></td></tr>
<tr class="separator:ga61edeb0c711128d31ade66aac22875a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4861019a35d7669b912b60b733a1a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaa4861019a35d7669b912b60b733a1a77">BADC_CalcRunDemagTime</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle, <a class="el" href="struct_speedn_torq_ctrl___handle__t.html">SpeednTorqCtrl_Handle_t</a> *pHandleSTC)</td></tr>
<tr class="memdesc:gaa4861019a35d7669b912b60b733a1a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">It calculates and stores in the corresponding variable the demagnetization time in closed loop operation <br  />
  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaa4861019a35d7669b912b60b733a1a77">More...</a><br /></td></tr>
<tr class="separator:gaa4861019a35d7669b912b60b733a1a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7039ad7ea60ee3aa867120b3ffeb85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga6a7039ad7ea60ee3aa867120b3ffeb85">BADC_SetLoopClosed</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga6a7039ad7ea60ee3aa867120b3ffeb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called after switch-over procedure when virtual speed sensor transition is ended. <br  />
  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#ga6a7039ad7ea60ee3aa867120b3ffeb85">More...</a><br /></td></tr>
<tr class="separator:ga6a7039ad7ea60ee3aa867120b3ffeb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa90246d9427c9e3c62b63aba52fc2e26"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaa90246d9427c9e3c62b63aba52fc2e26">BADC_GetLastBemfValue</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle, uint8_t phase)</td></tr>
<tr class="memdesc:gaa90246d9427c9e3c62b63aba52fc2e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the last acquired bemf value.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gaa90246d9427c9e3c62b63aba52fc2e26">More...</a><br /></td></tr>
<tr class="separator:gaa90246d9427c9e3c62b63aba52fc2e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad758297237033e039cc295959701dbb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gad758297237033e039cc295959701dbb0">BADC_GetBemfZcrFlag</a> (<a class="el" href="struct_bemf___a_d_c___handle__t.html">Bemf_ADC_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gad758297237033e039cc295959701dbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the zero crossing detection flag.  <a href="group___g0_x_x___bemf___a_d_c___speedn_pos_fdbk.html#gad758297237033e039cc295959701dbb0">More...</a><br /></td></tr>
<tr class="separator:gad758297237033e039cc295959701dbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This file provides firmware functions that implement Bemf sensing class to be stantiated when the six-step sensorless driving mode topology is used. </p>
<dl class="section author"><dt>Author</dt><dd>Motor Control SDK Team, ST Microelectronics </dd></dl>
<p>It is specifically designed for STM32G0XX microcontrollers and implements the sensing using one ADC with DMA support.</p><ul>
<li>MCU peripheral and handle initialization function</li>
<li>ADC sampling function</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<h2><center>&copy; Copyright (c) 2022 STMicroelectronics. All rights reserved.</center></h2>
<p >This software component is licensed by ST under Ultimate Liberty license SLA0044, the "License"; You may not use this file except in compliance with the License. You may obtain a copy of the License at: www.st.com/SLA0044 </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
