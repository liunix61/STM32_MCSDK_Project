<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: Motor Control Protocol Suite</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Motor Control Protocol Suite </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_docs_Motor_Control_Protocol_Suite"></a> </p>
<h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p >The aim of this protocol suite is to implement the features needed to <b>drive</b> and to <b>monitor</b> motor control applications embedded in STM32 MCUs.</p>
<p >It makes it possible, for instance, to send commands for starting or stopping the motor(s) controlled by an application, to set the target speed of the motors, and to tune relevant control variables (such as speed, torque or flux PI regulator coefficients, ...) in real-time. It also provides features to monitor motor control related quantities, like the speed of a motor or the currents flowing through its phases for instance.</p>
<p >The Motor Control Protocol Suite is made of several parts, one of which is the Motor Control Protocol itself. The purpose of this document is to describe, in details, the Motor Control Protocol Suite and all its parts.</p>
<p >In the rest of the document, the <em>Motor Control Protocol Suite</em> is also referred to as <em>MCPS</em> and the <em>Motor Control Protocol</em> is also referred to as <em>MCP</em>.</p>
<h1><a class="anchor" id="overview"></a>
Overview</h1>
<div class="image">
<object type="image/svg+xml" data="mcps_overview.svg" style="pointer-events: none;"></object>
</div>
    <p >The <em>Motor Control Protocol Suite</em> specifies the communication between two devices. The first one is based on an STM32 MCU and runs a Motor Control application. The second one can be any kind of a device (possibly powered by an STM32) running an application that aims at controlling and monitoring the former.</p>
<p >The two devices play different roles and behave differently on both sides of the communication. To handle this difference, the Motor Control Protocol Suite defines two different roles: the <b>Controller</b> role and the <b>Performer</b> role.</p>
<p >The <b>Performer</b> is the device that runs the Motor Control application. The <b>Controller</b> is the one that controls and monitors the <b>Performer</b>. This is highlighted in the figure above: The Controlling and Monitoring Application running on the <b>Controller</b> side uses the Motor Control Protocol Suite to control and monitor an STM32 Motor Control Application that runs on the <b>Performer</b> side. These roles are set at firmware (or software) built time.</p>
<p >The <em>Motor Control Protocol Suite</em> is made of a stack of communication protocols that sit on top of one another and that use one another services.</p>
<p >The <em>Motor Control Protocol</em> itself is at the top and interfaces directly with the application, whether it runs on the <b>Controller</b> or on the <b>Performer</b> side. It provides the services needed by a Controller application to properly monitor and control the motors driven by a Performer application.</p>
<p >To transport the data it has to handle, the <em>Motor Control Protocol</em> uses lower level protocols that are adapted to the physical link that connect the devices. <a class="el" href="motor-control-protocol-suite.html#asymmetric-serial-packet-exchange-protocol">ASPEP</a> (used across serial links) and <a class="el" href="motor-control-protocol-suite.html#stlink-exchange-protocol">STLEP</a>(used across STLink) are two such protocols. <a class="el" href="motor-control-protocol-suite.html#asymmetric-serial-packet-exchange-protocol">ASPEP</a> is specified in the current version of the present document. <a class="el" href="motor-control-protocol-suite.html#stlink-exchange-protocol">STLEP</a> is still draft and not fully supported yet. It will be described in a further version of the present document <br  />
</p>
<h1><a class="anchor" id="motor-control-protocol"></a>
Motor Control Protocol</h1>
<h2><a class="anchor" id="protocol-overview"></a>
Protocol Overview</h2>
<p >The Motor Control Protocol (MCP) works by exchanging messages between the <b>Controller</b> and the <b>Performer</b>. These messages are submitted to the lower level protocol being used to communicate between the Controller and the Performer. This lower level protocol transports the messages and delivers them to the remote.</p>
<p >MCP requires that the lower level protocol offer two independent communication channels: messages sequences exchanged on one of the channel are independent from the ones exchanged on the other. The lower level protocol must provide interfaces that let the MCP specifies on which channel it submits the messages it sends. Also, when receiving a message, the lower level protocol shall notify the MCP about both the message and the channel on which it is received.</p>
<p >MCP does not provide any message segmentation mechanism: an MCP message must be small enough to fully fit into a service data unit of the lower level protocol.</p>
<p >Data are sent in little-endian order: least significant bits of bytes are transmitted first.</p>
<p >The Motor Control Protocol is designed to minimize the amount of computing power needed on the STM32 Performer side to operate it.</p>
<p >This section specifies <b>version 1</b> of the Motor Control Protocol.</p>
<h2><a class="anchor" id="services-overview"></a>
Services overview</h2>
<p >The Motor Control Protocol features are organized around four services: the <a class="el" href="motor-control-protocol-suite.html#the-command-service">Command</a>, <a class="el" href="motor-control-protocol-suite.html#the-registry-service">Registry</a>, <a class="el" href="motor-control-protocol-suite.html#the-datalog-service">Datalog</a> and <a class="el" href="motor-control-protocol-suite.html#the-notification-service">Notification</a> services.</p>
<p >The <a class="el" href="motor-control-protocol-suite.html#the-command-service">Command</a> service deals with the sending, by the <b>Controller</b>, of commands that are executed by the <b>Performer</b>. After execution, the Performer returns a status possibly preceded by additional data. An example of a command is the <code>START_MOTOR</code> command that instructs the Motor Control application on the Performer side to set a motor under control.</p>
<p >The <a class="el" href="motor-control-protocol-suite.html#the-registry-service">Registry</a> service formalizes the access, by the Controller, to internal variables and states of the embedded motor control application on the Performer. Registers are used to let the Controller read measurements made by the embedded motor control application, write run time application parameters, or even trigger actions. Examples of registers include the <code>I_A</code> register that references the current measured on phase A, the <code>CONTROL_MODE</code> register used to get and set the control mode of the application or the <code>SPEED_RAMP</code> register that allows the controller to program a speed ramp for a motor, just to name a few.</p>
<p >The <a class="el" href="motor-control-protocol-suite.html#the-datalog-service">Datalog</a> service lets the Controller monitor the changing values of registers in a controlled way. The registers to monitor and the value sampling rate are configurable. This service allows for plotting registers values like an oscilloscope would do with physical signals.</p>
<p >The <a class="el" href="motor-control-protocol-suite.html#the-notification-service">Notification</a> service provides the Controller with the possibility to be notified when the values of a set of registers change. For instance, it can be used to be notified whenever the <code>STATUS</code> register, that represents the state of the motor control state machine, changes.</p>
<h2><a class="anchor" id="the-command-service"></a>
The Command service</h2>
<p >The Motor Control Protocol defines three core commands that must be available in all MCP implementations. Some other commands are defined, that are applicative ones and which availability depends on the target application. Some of these applicative commands, targeting the most common Motor Control applications are defined in section <a class="el" href="motor-control-protocol-suite.html#motor-control-and-other-commands">Motor Control and other Commands</a>.</p>
<p >In addition, the protocol also provisions for one user defined command that is free for embedded applications designers to implement.</p>
<p >Commands are sent by the <b>Controller</b> (and only the <b>Controller</b>). They are identified by a <b>Command ID</b> and can contain additional data. Upon reception, they are immediately executed by the <b>Performer</b> that returns a status, possibly preceded by additional data.</p>
<p >At most one command can be pending at any time: the <b>Controller</b> must not send a new command before either the preceding one has been answered by the <b>Performer</b> or the <b>Controller</b> has received an indication stating that it has been lost and will never be answered.</p>
<p >The Command service uses a synchronous channel of the lower level protocol: both commands and response messages are transferred on this channel.</p>
<p >All commands share the following message format:</p>
<div class="image">
<object type="image/svg+xml" data="mcp_command_format.svg" style="pointer-events: none;"></object>
</div>
    <p ><b>Figure</b> : MCP Command format</p>
<p >The 13-bit <code>Command ID</code> field uniquely identifies the command. Known command IDs are listed in section 4 below.</p>
<p >The 3-bit <code>Motor #</code> field identifies the motor targeted by the command. A value of 0 usually means that the command does not target a specific motor. It can also mean that it targets all motors. This latter behavior of the Motor # 0 value is indicated in the specification of the commands to which it applies.</p>
<p >The <code>Command Payload</code> field is optional. It is used to transport the parameters of the command, for commands that have some. The content and meaning of the payload is defined independently for each command.</p>
<p >Response messages sent by the Performer to answer commands conform to the following format:</p>
<div class="image">
<object type="image/svg+xml" data="mcp_response_format.svg" style="pointer-events: none;"></object>
</div>
    <p ><b>Figure</b> : MCP Command response format</p>
<p >The last 8 bits of a response message, make the Status Code field. It provides the status of the execution of the command.</p>
<h3><a class="anchor" id="mcp-commands"></a>
MCP Commands</h3>
<h4><a class="anchor" id="mcp-response-codes"></a>
MCP Response Codes</h4>
<p >Command Status Codes are found in Response messages. They refer to the last received command.</p>
<p >Command status codes can be defined independently for each command. However, the codes listed in the Table below are defined and reused across commands where applicable.</p>
<p >The first response code, <code>CMD_OK</code> indicates the successful execution of the preceding command. All other codes indicate an error.</p>
<p ><a class="anchor" id="table--common-mcp-command-status-codes"></a></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">ID   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x00   </td><td class="markdownTableBodyNone"><code>CMD_OK</code>   </td><td class="markdownTableBodyNone">Execution of the command was successful    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x01   </td><td class="markdownTableBodyNone"><code>CMD_NOK</code>   </td><td class="markdownTableBodyNone">Execution of the command failed    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x02   </td><td class="markdownTableBodyNone"><code>CMD_UNKNOWN</code>   </td><td class="markdownTableBodyNone">Command is unknown    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x03   </td><td class="markdownTableBodyNone"><em>Unused</em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x04   </td><td class="markdownTableBodyNone"><code>RO_REG</code>   </td><td class="markdownTableBodyNone">Target register is Read Only. Its value cannot be written    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x05   </td><td class="markdownTableBodyNone"><code>UNKNOWN_REG</code>   </td><td class="markdownTableBodyNone">Target register is unknown    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x06   </td><td class="markdownTableBodyNone"><code>STRING_FORMAT</code>   </td><td class="markdownTableBodyNone">The format of a text string in the command payload is wrong    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x07   </td><td class="markdownTableBodyNone"><code>BAD_DATA_TYPE</code>   </td><td class="markdownTableBodyNone">The type of a register in the command payload is wrong    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x08   </td><td class="markdownTableBodyNone"><code>NO_TXSYNC_SPACE</code>   </td><td class="markdownTableBodyNone">The size of the response to the command exceeds the maximum payload size    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x09   </td><td class="markdownTableBodyNone"><code>NO_TXASYNC_SPACE</code>   </td><td class="markdownTableBodyNone">The number of signals requested for the Datalog exceeds the maximum supported by the Performer    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x0A   </td><td class="markdownTableBodyNone"><code>WRONG_STRUCT_FORMAT</code>   </td><td class="markdownTableBodyNone">The reported size of a structure transmitted in the command does not match its actual size    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x0B   </td><td class="markdownTableBodyNone"><code>WO_REG</code>   </td><td class="markdownTableBodyNone">Target register is Write Only. Its value cannot be read    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x0C   </td><td class="markdownTableBodyNone"><em>Unused</em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x0D   </td><td class="markdownTableBodyNone"><code>USER_CMD_NOT_IMPL</code>   </td><td class="markdownTableBodyNone">Command is a non implemented user command.   </td></tr>
</table>
<p ><b>Table 1:</b> Common MCP command status codes</p>
<h4><a class="anchor" id="get_mcp_version-command"></a>
&lt;tt&gt;GET_MCP_VERSION&lt;/tt&gt; command</h4>
<p ><b>Purpose:</b></p>
<p >The <code>GET_MCP_VERSION</code> command requests the version of the Motor Control Protocol that the Performer supports.</p>
<p ><b>Command ID</b>: <code>0x0000</code>.</p>
<p ><b>Command Payload:</b></p>
<p >This command does not have a payload.</p>
<p ><b>Response:</b></p>
<p >The payload of the response to this command has a four bytes payload that contains an unsigned integer value set to the version of the Motor Control Protocol supported by the Performer. For the version of the MCP described in this document, this value is <code>0x00000001</code>.</p>
<p >The status code to this command is always <code>CMD_OK</code>.</p>
<h4><a class="anchor" id="set_register-command"></a>
&lt;tt&gt;SET_REGISTER&lt;/tt&gt; command</h4>
<p ><b>Purpose:</b></p>
<p >The <code>SET_REGISTER</code> command requests to set the values of one or more registers of the STM32 embedded application.</p>
<p ><b>Command ID</b>: <code>0x0001</code>.</p>
<p ><b>Command Payload:</b></p>
<p >The payload of this command is the concatenation of the identifiers of the registers which values are requested followed by their new values. The figure below depicts this.</p>
<div class="image">
<object type="image/svg+xml" data="mcp_set_register_command_format.svg" style="pointer-events: none;"></object>
</div>
    <p >In the payload of the command, each register ID is followed by the new value to set for it.</p>
<p >For all details about registers and their identifier, refer to the <a class="el" href="motor-control-protocol-suite.html#the-registry-service">Registry Service</a> section.</p>
<p ><b>Response:</b></p>
<p >If the command requests to set the value of only one register, the response has no payload and consists solely in a status code, either <code>CMD_OK</code> if the register could be set or an error code otherwise.</p>
<p >If more than one register is to be set by the command, the response consists in either of the following:</p>
<ul>
<li>The <code>CMD_OK</code> status code alone, with no payload, if all the requested registers could be set successfully;</li>
<li>The <code>CMD_NOK</code> status code preceded by a payload made of as many status codes as there are registers to set in the command. In that case, the <b>Performer</b> tried to set all the registers listed in the command and failed for some of them. The status codes of the register set operations are listed in the order of the registers in the command. The status codes of registers which value could be set correctly is <code>CMD_NOK</code>; that of registers which value that could not be set correctly reflect the reason of the issue;</li>
<li><p class="startli">The <code>CMD_NOK</code> status code preceded by a payload made of less status codes than there are registers to set in the command. In that case, the <b>Performer</b> tried to set the registers listed in the command, in order, and failed for some of them. At some point, the processing of the command failed because of one of the following reason:</p><ul>
<li>The type of a register is not known. Since the <b>Performer</b> does not know the type of the register to set from its identifier, it cannot know the length of its value and thus it cannot decode the remainder of the command message. This issue is reported with the <code>BAD_DATA_TYPE</code> status code;</li>
<li>The length of a Raw Structure parameter does not fit into the remainder of the payload of the command message. Since the <b>Performer</b> cannot know where the structure actually stops, it cannot decode the remainder of the command message. This issue is reported with the <code>WRONG_STRUCT_FORMAT</code> status code.</li>
</ul>
<p class="startli">In any of these cases, the decoding of the command stops at the first occurrence of such an error. Any register that would appear in the command after the one that caused the error is not assigned the value set in the command.</p>
</li>
</ul>
<p >Refer to the <a class="el" href="motor-control-protocol-suite.html#table--common-mcp-command-status-codes">status codes table</a> above for a list of possible status codes. Also, for all details about registers and their identifier, refer to the <a class="el" href="motor-control-protocol-suite.html#the-registry-service">Registry</a> section.</p>
<h4><a class="anchor" id="get_register-command"></a>
&lt;tt&gt;GET_REGISTER&lt;/tt&gt; command</h4>
<p ><b>Purpose:</b></p>
<p >The <code>GET_REGISTER</code> command requests to get the values of one or more registers from the STM32 embedded application.</p>
<p ><b>Command ID</b>: <code>0x0002</code>.</p>
<p ><b>Command Payload:</b></p>
<p >The payload of this command is the concatenation of the identifiers of the registers which values are requested. The figure below depicts this.</p>
<div class="image">
<object type="image/svg+xml" data="mcp_get_register_command_format.svg" style="pointer-events: none;"></object>
</div>
    <p >As registers identifiers are 16 bits in length, the size of the payload of the command is N × 2 bytes with N being the number of registers (N ≥ 1).</p>
<p >It is the responsibility of the application on the <b>Controller</b> side to make sure that the cumulated size of the values of the requested registers fit into the maximum payload size supported by the lower level protocol.</p>
<p >For all details about registers and their identifier, refer to the <a class="el" href="motor-control-protocol-suite.html#the-registry-service">Registry</a> section.</p>
<p ><b>Response:</b></p>
<p >The response consists in the concatenation of the values of the registers listed in the command, in the order where they appear in the command, followed by a response code.</p>
<p >If the values of all the requested registers could be read, the response code is <code>CMD_OK</code>.</p>
<p >If one of the registers cannot be read, the processing of the command stops at this point. The response then consists in the concatenation of the values of the registers that could be read up to the point where the error occurred, followed by a response code. The response code indicates the cause of the error. Refer to the <a class="el" href="motor-control-protocol-suite.html#table--common-mcp-command-status-codes">status codes table</a> above for possible codes.</p>
<p >As an example, consider a <code>GET_REGISTER</code> command that requests the reading of 5 registers. If the third register of the command cannot be read because tis value is too long to fit in the response message, the response will consists in the values of the first two registers followed by the <code>NO_TXSYNC_SPACE</code> status code.</p>
<p >For all details about registers and their identifier, refer to the <a class="el" href="motor-control-protocol-suite.html#the-registry-service">Registry</a> section.</p>
<h4><a class="anchor" id="user-command"></a>
User Command</h4>
<p ><b>Purpose:</b></p>
<p >The <code>USER_COMMAND</code> command is reserved for the needs of the application. Its command ID is not reserved for another purpose. An application on the Performer side is free to implement it or not for its own purposes.</p>
<p ><b>Command ID</b>: <code>0x0100</code>.</p>
<p ><b>Command Payload:</b></p>
<p >The Payload of this command depends on the embedded application.</p>
<p ><b>Response:</b></p>
<p >The payload of the response depends on the embedded application.</p>
<p >If the embedded application does not implement the command the response only contains the <code>USER_CMD_NOT_IMPL</code> status code and the payload is empty.</p>
<p >The embedded application can define its own status codes for this command provided that they are different from the one defined in the <a class="el" href="motor-control-protocol-suite.html#table--common-mcp-command-status-codes">status codes table</a> above.</p>
<h2><a class="anchor" id="the-registry-service"></a>
The Registry service</h2>
<p >In MCP, registers are a way to provide the application on the <b>Controller</b> side a handle on variables, states and more generally data that belong to the embedded application on the <b>Performer</b> side.</p>
<p >This handle, also named <b>register identifier</b> in this document is structured around four items, as outlined in the figure below:</p>
<div class="image">
<object type="image/svg+xml" data="mcp_register_identifier_format.svg" style="pointer-events: none;"></object>
</div>
    <ul>
<li><code>Motor #</code>: number of the motor the register refers to. 0 means that the register does target a motor or that it targets all motors;</li>
<li><code>Type</code>: Information on the size of the value of the Data Element (8, 16, 32, …). The indication of the type of registers either gives the size of their values or provides a means to get it. See below;</li>
<li><code>Identifier</code>: <em>Uniquely</em> identifies a register of a given type;</li>
<li><code>Semantics</code>: <em>Uniquely</em> identifies the purpose of a register independently of the Motor The combination of the <code>Identifier</code> and <code>Type</code> fields define the <code>Semantics</code> of a register.</li>
</ul>
<p >The following table defines the different possible values for the <code>Type</code> field and their meaning.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type ID   </th><th class="markdownTableHeadNone">Purpose   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone"><em>RESERVED</em>   </td><td class="markdownTableBodyNone">Unused type value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">8-bit data   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">16-bit data   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">32-bit data   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">Text string   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone"><em>RESERVED</em>   </td><td class="markdownTableBodyNone">Unused type value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone"><em>RESERVED</em>   </td><td class="markdownTableBodyNone">Unused type value   </td></tr>
</table>
<p ><b>Register identifiers</b> are used in the <a class="el" href="motor-control-protocol-suite.html#get_register-command">`GET_REGISTER`</a> and <a class="el" href="motor-control-protocol-suite.html#set_register-command">`SET_REGISTER`</a> commands to identify the registers these command deal with. They can also be used in other circumstances.</p>
<p >Types 0 and 7 are reserved for a future use and must not be used in the current version of the MCP.</p>
<p >The value of type 1, 2 and 3 registers are 8-bit, 16-bit and 32-bit long respectively.</p>
<p >The values of type 4 registers are NULL terminated text strings. The MCP does not specifies anything about the encoding of the text. The only requirement is that a NULL character indicates the end of the string and the end of the value.</p>
<p >The values of type 5 registers are buffers which sizes are indicated in the first two bytes of the values. This type of often used to store structures. The size of a Raw Structure register buffer is stated in bytes and stored in little endian. See the figure below.</p>
<div class="image">
<object type="image/svg+xml" data="mcp_raw_register_format.svg" style="pointer-events: none;"></object>
</div>
    <p >Note that registers may be readable and/or writable through MCP, thanks to the <code>GET_REGISTER</code> and <code>SET_REGISTER</code> commands. Some registers may event be neither writable nor readable. Such registers are usable with the Datalog service specified below.</p>
<p >The full list of registers depends of the application and can change in time: new registers are added periodically to go with the evolution of the MCSDK. See the <a class="el" href="motor-control-protocol-suite.html#registers">Registers</a> section below for a list of some of them.</p>
<h2><a class="anchor" id="the-datalog-service"></a>
The Datalog service</h2>
<p >The Datalog service offers the periodic recording by the Performer of the values of a number of registers that are then transmitted to the Controller. The Controller can configure the number of registers to record, their identifiers and their sampling frequency, within the limits allowed by the Performer. Recorded values are accumulated and sent by the Performer to the Controller in Datalog messages. This feature allows for sampling registers values in a controlled and coherent way. <br  />
</p>
<p >The Datalog service uses an asynchronous channel of the lower level protocol. The presence of this service is optional in MCP.</p>
<p >The registers that can be monitored through the Datalog service are a subset of the whole register catalog that depend on the Controller application. These registers are classified into two categories, depending on their update frequency: <b>High Frequency</b> registers are updated on the execution periodicity of the High Frequency Task of the MCSDK; <b>Medium Frequency</b> registers are updated on the execution periodicity of the Medium Frequency Task of the MCSDK. The Datalog service allows for setting a sampling rate for the High Frequency registers and another sampling rate for the Medium Frequency registers.</p>
<p >The values of the High Frequency registers are recorded as 16-bit values whatever their real type. A configurable shift can be applied on the values of 32-bit registers.</p>
<p >The values of the Medium Frequency registers are recorded as 32-bit values whatever their real type. <br  />
</p>
<p >The figure below depicts the format of a Datalog messages.</p>
<div class="image">
<object type="image/svg+xml" data="mcp-datalog-format.svg" style="pointer-events: none;"></object>
</div>
    <p >The <b>Timestamp</b> field is a 32-bit counter that is incremented on each High Frequency task execution. It can be used to detect if data have been lost between two Datalog messages. Data can be lost either because a Datalog messages is lost or because the Datalog buffers are filled faster than they are transmitted. The value of this field corresponds to the value of the counter at the time the registers of the first block in the packet (see below) are recorded.</p>
<p >The timestamp field is followed by one or more blocks of registers values. A block of registers values is made of an optional sequence of High Frequency registers values followed by an optional sequence of Medium Frequency registers values. The presence of the High Frequency registers sequence in a block depends on the High Frequency registers sampling rate (<code>HF_SAMPLE_RATE</code>). That of the Medium Frequency registers sequence depends on the Medium Frequency registers sampling rate (<code>MF_SAMPLE_RATE</code>). These two parameters are 8-bit unsigned values. They work with two counters: <code>HF_SAMPLE_COUNT</code> and <code>MF_SAMPLE_COUNT</code> .</p>
<p >When the Datalog service is configured and activated, both these counters are set to 0. On each execution of the High Frequency task, <code>HF_SAMPLE_COUNT</code> is compared to <code>HF_SAMPLE_RATE</code>. If they are equal, <code>HF_SAMPLE_COUNT</code> is set to 0 and the values of the High Frequency registers are recorded in a Datalog message. Otherwise <code>HF_SAMPLE_COUNT</code> is incremented by 1.</p>
<p >Similarly, On each execution of the High Frequency task, <code>MF_SAMPLE_COUNT</code> is compared to <code>MF_SAMPLE_RATE</code>. If they are equal, <code>MF_SAMPLE_COUNT</code> is set to 0 and the values of the Medium Frequency registers are recorded in a Datalog message. Otherwise <code>MF_SAMPLE_COUNT</code> is incremented by 1.</p>
<p >This procedure is repeated until the Datalog message is filled up to a level where no further block can fit in it. The Datalog message is then sent and a new one is being prepared.</p>
<p >There are two special values for the <code>MF_SAMPLE_RATE</code> parameter: 255 and 254. If <code>MF_SAMPLE_RATE</code> is set to 255, then Medium Frequency registers are not recorded and Datalog messages only contain High Frequency registers values. If <code>MF_SAMPLE_RATE</code> is set to 254, then the Medium Frequency registers are only recorded once per Datalog message, with the last register block. The following figure illustrates this.</p>
<div class="image">
<object type="image/svg+xml" data="mcp-datalog-format-254.svg" style="pointer-events: none;"></object>
</div>
    <p >The <b>Async Datalog ID</b> field is set to <b>0</b>. It identifies the message as a Datalog message: messages sent from the Performer to the Controller on the asynchronous channel of the lower level protocol used to transport them that have an <b>Async Datalog ID</b> field (that is: the last but one byte of their content) set to <b>0</b> are Datalog messages.</p>
<p >The <b>Mark</b> field identifies the configuration of the datalog service that corresponds to the content of the Datalog message. Its value is set by the controller at configuration time. It is an 8-bit unsigned value that cannot be 0. This value is useful when changing from one Datalog configuration to another. When the Controller changes the Datalog service configuration (because it adds a register to record for instance), it should also change the Mark value. It will then know when this new configuration is indeed active when it starts receiving Datalog messages with the <b>Mark</b> field set to the new mark value. A Performer must apply a newly received Datalog configuration when starting to fill the next Datalog message. Any Datalog message being in construction at the time the new configuration is received by the Performer must first be filled up as explained above and sent before the new configuration is applied. As a consequence, the Controller may receive up to two Datalog messages with the previous configuration after it has sent a new Datalog configuration.</p>
<p >The MCP provisions for the possibility to configure several instances of the Datalog service, one per active transport link between the Controller and the Performer. However, how this possibility is implemented not specified yet and thus cannot be used in this version of the protocol.</p>
<p >The Datalog is configured thanks to a set of registers <code>DATALOG_UARTA</code>, <code>SHIFT_UARTA</code>, <code>DATALOG_UARTB</code>, <code>SHIFT_UARTA</code>, <code>DATALOG_STLINK</code> and <code>SHIFT_STLINK</code>. Which registers need to be used depend on the physical link (and on the lower level protocol) used to communicate between the Controller and the Performer. Configuring the Datalog service on a physical link requires the setting of one or two registers a <code>DATALOG_*</code> register and the corresponding <code>SHIFT_</code>register. With these registers, all the parameters of the Datalog service can be set. Refer to the <a class="el" href="motor-control-protocol-suite.html#registers">Registers</a> section for a complete description of these registers.</p>
<h2><a class="anchor" id="the-notification-service"></a>
The Notification service</h2>
<p >The Notification service is provisioned, but not fully specified in this version of the protocol, so it is not available in the current version of the protocol.</p>
<p >The Notification service messages use an asynchronous channel of the lower level protocol. The presence of this service is optional in MCP.</p>
<p >Notification messages share part of their format with Datalog messages: they have an <b>Async Datalog ID</b> field, located at the same place as the in the Datalog message (last but one byte of the message). The <b>Async Datalog ID</b> field of a notification message is set to 1.</p>
<h2><a class="anchor" id="multiple-transport-links"></a>
Multiple Transport links</h2>
<p >The Motor Control Protocol provisions for supporting several connections with the lower level protocols at the same type to one <b>Performer</b> device. For instance, a <b>Controller</b> can be connected to a <b>Performer</b> through a serial port and through the STLink at the same time. A mechanism is to be designed to identify the transport link used to exchange messages.</p>
<p >However, this feature of the MCP is not available in the current version of the protocol.</p>
<h1><a class="anchor" id="transport-layers"></a>
Transport Layers</h1>
<p >The transport layers are protocols on which MCP relies to transport its messages between the Controller and the Performer. Their task is to adapt MCP communication to the physical link being used to transport it.</p>
<p >The protocols of the Transport Layers are connected protocols: For MCP communication to occur using them, a connection between the Controller and the Performer need to be established at their level.</p>
<p >The protocols of the Transport Layers provide at least two channels that are multiplexed over the physical link: a Synchronous channel and an asynchronous channel. The Synchronous channel is used by MCP to transport the messages of the command service. The Asynchronous channel is used by MCP to transport the messages of the Datalog and Notification services. The Synchronous Asynchronous channels are independent: a Datalog message may be sent on the Asynchronous channel between a Command and its Response on the Synchronous channel.</p>
<h2><a class="anchor" id="asymmetric-serial-packet-exchange-protocol"></a>
Asymmetric Serial Packet Exchange Protocol</h2>
<h3><a class="anchor" id="aspep-overview"></a>
ASPEP Overview</h3>
<p >The Asymmetric Serial Packet Exchange Protocol – <em>ASPEP</em> in short – is a light-weight protocol designed for controlling STM32 embedded applications that produce real time data, across a serial port.</p>
<p >It is a point-to-point protocol where both sides play different roles and have different traffic shapes. It works in <b>connected</b> mode: no payload data can be exchanged between the two sides before a formal connection has been established.</p>
<p >Communication with ASPEP involves two <b>Hosts</b>, a <b>Controller</b> and a <b>Performer</b>, that exchange <b>Packets</b>.</p>
<p >The <b>Controller</b> is the host that initiates the connection. It is also the one that can send requests to the <b>Performer</b> while the latter can only answer them. The <b>Performer</b> role is meant for the controlled STM32 application while the <b>Controller</b> role is that of the controller application.</p>
<p >A data <b>Packet</b> is made of a 4-byte <b>Header</b> optionally followed by a <b>Payload</b>. When a packet has a payload, the size of this payload is indicated in the header. Different packet types are defined to handle all the possible communication schemes and situations that ASPEP has to face.</p>
<p >To start communicating, the <b>Controller</b> initiates a connection that the <b>Performer</b> accepts.</p>
<p >The purpose of the connection establishment procedure is to negotiate the values of a set of parameters that are needed for the connection to work. These parameters mainly deal with maximum packet sizes and the support of some protocol optional features.</p>
<p >Once a connection is successfully established, <b>Controller</b> and <b>Performer</b> can start exchanging useful data.</p>
<p >An ASPEP connection provides three communication channels: The <b>Synchronous</b> channel, the <b>Asynchronous</b> channel, and the <b>Control</b> channel. Channels are identified by the types of packets that are exchanged between the <b>Controller</b> and the <b>Performer</b>.</p>
<p >On the <b>Synchronous</b> channel, the Controller sends requests to which the Performer responds: The Controller starts a transaction by sending a <code>DATA</code> packet. The Performer ends the transaction by sending a <code>RESPONSE</code> packet. Only the <b>Controller</b> can start a transaction and the <b>Performer</b> cannot send <code>RESPONSE</code> packets outside of a transaction. At most one transaction can be pending at any given time. Both <code>DATA</code> and <code>RESPONSE</code> packets can carry a <b>Payload</b>. The main purpose of the <b>Synchronous</b> channel is for sending commands from the Controller to the Performer. The maximum sizes of <code>DATA</code> and <code>RESPONSE</code> packets are negotiated at connection establishment time, as part of the connection procedure.</p>
<p >The <b>Asynchronous</b> channel is unidirectional. It allows the Performer for sending <code>ASYNC</code> packets from the Performer to the Controller. <code>ASYNC</code> packets carry a payload. The presence of this channel on an ASPEP connection is optional and depends on the parameters negotiated at connection establishment time. The main purpose of the Asynchronous channel is to transfer the real time data produced by the embedded STM32 application (the Performer) towards the Controller in the scope of the <a class="el" href="motor-control-protocol-suite.html#the-datalog-service">Datalog service</a> for instance. The maximum size of an <code>ASYNC</code> packet is negotiated at connection establishment time.</p>
<p >The <b>Control</b> channel is used to establish and manage the connection. Three packet types are exchanged on this channel: <code>BEACON</code>, <code>PING</code>, and <code>ERROR</code> packets. They are used to implement three important features of ASPEP:</p>
<ul>
<li>The <a class="el" href="motor-control-protocol-suite.html#connection-procedure">connection establishment procedure</a> that involves <code>BEACON</code> and <code>PING</code> packets.</li>
<li>The <a class="el" href="motor-control-protocol-suite.html#keep-alive-procedure">Keep-alive</a> feature, used to check whether the embedded application is responsive. This feature uses <code>PING</code> packets.</li>
<li>The <a class="el" href="motor-control-protocol-suite.html#recovery-procedure">Recovery procedure</a> that handles cases where transmission issues may endanger the maintenance of the connection. Its goals it to allow for recovering the synchronization and thus the communication between the <b>Controller</b> and the <b>Performer</b>. This procedure may be triggered by the Controller, on its reception of faulty or unexpected packets from the Performer or by the Performer on its sending of an <code>ERROR</code> packet. The Performer sends such packets when receiving a faulty or unexpected packet from the Controller. Like the connection establishment procedure, the recovery procedure involves <code>BEACON</code> and <code>PING</code> packets.</li>
</ul>
<p >These features are described in full details later in this document.</p>
<p >The three channels are multiplexed over the serial link with different priorities: The <b>Synchronous</b> channel has priority over the <b>Control</b> channel that has priority over the <b>Asynchronous</b> one. This means that if several packets are ready for transmission on either side of a connection, when the serial link is available (not busy), the packet belonging to the channel with the highest priority will be sent first.</p>
<p >Packets are not interrupted nor split during transmission: a packet which transmission has started will be fully transmitted, even if a higher priority packet is submitted (after the start of the transmission).</p>
<p >The payload of ASPEP packets can be protected by a 16-bit CRC that allows for detecting errors on it. This is an optional feature that is negotiated at connection establishment time.</p>
<p >The parameters negotiated at connection establishment time allow for finely tuning the balance between the features provided by the protocol and its impact on the Flash, the RAM and MIPS consumption of the STM32.</p>
<h3><a class="anchor" id="packet-structure-and-transmission"></a>
Packet structure and transmission</h3>
<p >All ASPEP packets share the same structure, depicted in the following figure.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-packet-format.svg" style="pointer-events: none;"></object>
</div>
    <p ><b>Figure</b>: ASPEP general packet structure</p>
<p >An ASPEP packet is made of a 4-byte header optionally followed by a Payload that is, in turn, optionally followed by a CRC.</p>
<h4><a class="anchor" id="packet-headers"></a>
Packet Headers</h4>
<p >The content of the <b>Header</b> of a packet depends on the type of this packet. However, all packet Headers share a common structure, depicted in the following figure.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-packet-header-structure.svg" style="pointer-events: none;"></object>
</div>
    <p ><b>Figure</b>: ASPEP packet header structure</p>
<p ><b>Type</b> is a 4-bit field. Its value indicates the type of the packet.</p>
<p >The 4-bit CRCH field contains the result of a cyclic redundancy check computation performed on the first 28 bits of the header. The generator polynomial used compute it is that of the CCITT-G.704 standard:</p>
<p >$$x^{4} + x + 1$$</p>
<p >The 28 first bits of the Header are split into 7 nibbles that are processed from the least significant to the most significant one as follows:</p>
<ul>
<li>The initial CRC value is set to 0.</li>
<li>the least significant (4-bit) nibble is processed first as if it were the most significant part of the dividend.</li>
<li>the order of bits in each nibble is unchanged for processing which would leads to the following bit processing sequence: 3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12, 19, 18, 17, 16, 23, 22, 21, 20, 27, 26, 25, 24.</li>
</ul>
<p >The structure of the 24 bits of the <em><b>Header Content</b></em> part is defined with each different packet types.</p>
<h4><a class="anchor" id="packet-payload-and-crc"></a>
Packet payload and CRC</h4>
<p >The Payload of a packet is a sequence of bytes submitted by the user for transmission across an ASPEP connection. Whether a packet accepts a Payload depends on its type.</p>
<p >Packets that accept a Payload can optionally feature a 16-bit CRC field containing the result of a cyclic redundancy check computation performed on the whole payload.</p>
<p >Support for this CRC field is negotiated at connection establishment time.</p>
<p >The generator polynomial used to compute if is that of the CRC-16 from CCITT-X.25 standard:</p>
<p >$$x^{16} + x^{12} + x^{5} + 1$$</p>
<p >The initial value of the CRC, at start of computation, is set to 0. Bytes of the payload are processed in submission order.</p>
<h4><a class="anchor" id="packet-transmission"></a>
Packet transmission</h4>
<p >The transmission of an ASPEP Packet starts with the Header. Least significant bits are transmitted first.</p>
<p >If the packet has a payload, an <b>Intra Packet Pause</b> delay is inserted after the last bit of the Header has been transmitted and before the first bit of the Payload is sent. The duration of this pause, $T_{IPP}$, is not specified here. It would typically be <b>1 ms</b> in the <b>Controller</b> to <b>Performer</b> direction and <b>0 ms</b> in the <b>Performer</b> to <b>Controller</b> direction. This pause is sized so that the Performer has the time to properly set the hardware configurations it needs in order to receive the payload with a minimum CPU load expenditure. As an example, this pause should let enough time for the Performer to process the Header, to determine whether a payload is to be expected and, if it is the case, to configure the UART and its attached DMA properly to receive that payload. See</p>
<p >The payload is transmitted byte per byte, least significant bit first for each byte.</p>
<p >If the payload has a CRC, it is transmitted immediately after the end of the payload, least significant bits first also.</p>
<h3><a class="anchor" id="packet-types"></a>
Packet Types</h3>
<p >ASPEP defines six packet types:</p>
<ul>
<li><a class="el" href="motor-control-protocol-suite.html#beacon-packet-type">BEACON</a></li>
<li><a class="el" href="motor-control-protocol-suite.html#ping-packet-type">PING</a></li>
<li><a class="el" href="motor-control-protocol-suite.html#error-packet-type">ERROR</a></li>
<li><a class="el" href="motor-control-protocol-suite.html#request-and-async-packet-type">REQUEST</a></li>
<li><a class="el" href="motor-control-protocol-suite.html#reponse-packet-type">RESPONSE</a></li>
<li><a class="el" href="motor-control-protocol-suite.html#request-and-async-packet-type">ASYNC</a></li>
</ul>
<p >Packets of type <code>BEACON</code>, <code>PING</code> and <code>ERROR</code> constitute the <b>Control</b> channel. <code>BEACON</code> and <code>PING</code> packets can be sent by both the <b>Controller</b> and the <b>Performer</b>. They are involved in the <a class="el" href="motor-control-protocol-suite.html#connection-procedure">Connection procedure</a> and the <a class="el" href="motor-control-protocol-suite.html#recovery-procedure">Recovery procedure</a>. The <code>PING</code> packet is also used in the <a class="el" href="motor-control-protocol-suite.html#keep-alive-procedure">Keep Alive procedure</a>. The <code>ERROR</code> packet is only sent by the <b>Performer</b> to signal its receiving an unexpected or erroneous packet to the <b>Controller</b>. <code>BEACON</code>, <code>PING</code> and <code>ERROR</code> packets do not have a payload. They made of the <b>Header</b> alone.</p>
<p >Packets of type <code>REQUEST</code> and <code>RESPONSE</code> make the <b>Synchronous</b> channel. Both packet types accept a payload. They are involved in <a class="el" href="motor-control-protocol-suite.html#synchronous-transactions">Synchronous transactions</a>. <code>REQUEST</code> packets are sent by the <b>Controller</b>, <code>RESPONSE</code> packets are sent by the <b>Performer</b>.</p>
<p >Packets of type <code>ASYNC</code> constitute the <b>Asynchronous</b> channel. They carry a payload and are only sent by the <b>Performer</b>.</p>
<h4><a class="anchor" id="beacon-packet-type"></a>
BEACON packet type</h4>
<p ><code>BEACON</code> packets are used by both <b>Controller</b> and <b>Performer</b> to exchange and negotiate the parameters of the connection – see the <a class="el" href="motor-control-protocol-suite.html#connection-procedure">Connection procedure</a>. They are also used in the Recovery procedure. <code>BEACON</code> packets do not have a payload.</p>
<p >The figure below describes the structure of a <code>BEACON</code> packet.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-beacon-packet-structure.svg" style="pointer-events: none;"></object>
</div>
    <p >Figure : <code>BEACON</code> packet structure</p>
<p >The Type field of <code>BEACON</code> packets is set to <b>5</b>.</p>
<p >The value of the <b>Version</b> field is the version number of the ASPEP protocol to which the sender of the message conforms. The current version of the protocol has number <b>0</b>.</p>
<p >The other fields of <code>BEACON</code> packets describe the connection parameters negotiated by the sender of the message:</p>
<ul>
<li><code>CRC</code>: Set to <b>1</b> to indicate supports for computing a CRC on the payload of ASPEP packets. Set to <b>0</b> otherwise.</li>
<li><code>RXS Max</code>: Represents the maximum payload size of a <code>REQUEST</code> packet allowed on the connection. The maximum payload size in bytes is derived from the value of the field with the following formula:</li>
</ul>
<p >$$Max\ REQUEST\ payload\ size = P_{REQMax} = (RXS\ Max + 1) \times 32$$</p>
<ul>
<li><code>TXS Max</code>: Represents the maximum payload size of a <code>REPONSE</code> packet allowed in the connection. The maximum payload size in bytes is derived from the value of the field with the following formula:</li>
</ul>
<p >$$Max\ RESPONSE\ payload\ size = \ P_{RESPMax} = (TXS\ Max + 1) \times 32$$</p>
<ul>
<li><code>TXA Max</code>: Represents the maximum payload size of an <code>ASYN</code> packet allowed in the connection. The maximum payload size in bytes is derived from the value of the field with the following formula:</li>
</ul>
<p >$$Max\ ASYNC\ payload\ size = \ P_{ASYNCMax} = (TXA\ Max)\times64$$</p>
<h4><a class="anchor" id="ping-packet-type"></a>
PING packet type</h4>
<p ><code>PING</code> packets are used by both Controller and Performer in the Connection and Keep-Alive procedures. They allow the Performer to report state information and physical link identification to the Controller. <code>PING</code> packets do not have a payload.</p>
<p >The Figure below describes the structure of a PING packet.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-ping-packet-structure.svg" style="pointer-events: none;"></object>
</div>
    <p ><b>Figure</b>: <code>PING</code> packet structure</p>
<p >The Type field of <code>PING</code> packets is set to <b>6</b>.</p>
<p >The Controller does not use the <code>C</code>, <code>N</code> and <code>LIID</code> fields. In <code>PING</code> packets sent by a Controller, these fields are reserved and should be set to <b>0</b>.</p>
<p >The <code>C</code> field is set to <b>1</b> by the Performer to indicate that it is already configured and to <b>0</b> otherwise (A Performer is configured when it is not in the <code>IDLE</code> state; see the <a class="el" href="motor-control-protocol-suite.html#connection-procedure">Connection procedure</a> section below). This information can be used by the Controller to detect a reset of the Performer.</p>
<p >The <code>N</code> field is set, by the Performer to the last bit of the number of the next expected <code>REQUEST</code> packet from the Performer. This number is set to <b>0</b> at ASPEP reset time and incremented on each valid reception of a <code>REQUEST</code> packet from the Controller. See the <a class="el" href="motor-control-protocol-suite.html#synchronous-transactions">Synchronous Transactions</a> section below. This information can be used by the Controller to detect the loss of a <code>REQUEST</code> or a <code>RESPONSE</code> packet in some situations.</p>
<p >The <code>C</code> and <code>N</code> field are written twice in the packet, as shown in the figure above.</p>
<p >The <code>LIID</code> field identifies the ASPEP Layer instance (and the physical serial interface) on which the packet is sent. <b>LIID</b> stands for <b>Layer Instance IDentifier</b>. An embedded STM32 application can accept several parallel connections to the same Controller. This field allows for identifying which ASPEP instance / serial port pair sent the packet. Specification of the values of the <code>LIID</code> field is outside of the scope of the specification of ASPEP.</p>
<p >The <code>Packet Number</code> field is used in the <a class="el" href="motor-control-protocol-suite.html#keep-alive-procedure">Keep-Alive procedure</a>. It is set by the Controller to to a value that is incremented on each PING packet it sends. When sending a PING packet, the Performer sets it to the value of the last <code>Packet Number</code> received from the Controller.</p>
<h4><a class="anchor" id="error-packet-type"></a>
ERROR packet type</h4>
<p ><code>ERROR</code> packets are used by the Performer to notify protocol errors to the Controller. An <code>ERROR</code> packet is sent on the reception of an incorrect ASPEP packet from the Controller. <code>ERROR</code> packets do not have a payload.</p>
<p >The Type field of <code>ERROR</code> packets is set to <b>15</b>.</p>
<p >The Figure below describes the structure of an <code>ERROR</code> packet.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-error-packet-structure.svg" style="pointer-events: none;"></object>
</div>
    <p >Figure : <code>ERROR</code> packet structure</p>
<p >The 8-bit <b>Error Code</b> field is duplicated in the packet. The table below lists possible error code and their meaning.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Code</b>   </th><th class="markdownTableHeadNone"><b>Description</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone"><em>Bad Packet Type</em>: the type of the packet sent by the Controller is either unknown or not allowed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone"><em>Bad Packet Size</em>: The payload of the last REQUEST packet sent by the Controller is too large: the value of its Payload Length field is greater than the RXS Max parameter negotiated on the connection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone"><em>Bad Header</em>: Verification of the CRCH field of the last packet received from the Controller failed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone"><em>Bad Payload CRC</em>: Verification of the CRC field of the last packet received from the Controller failed.   </td></tr>
</table>
<p ><b>Table</b> : MCP Commands status codes</p>
<h4><a class="anchor" id="request-and-async-packet-type"></a>
REQUEST and ASYNC packet type</h4>
<p ><code>REQUEST</code> and <code>ASYNC</code> packets have the same Type field value and both accept a Payload. <code>REQUEST</code> packets are sent by the Controller only while <code>ASYNC</code> packets are only sent by the Performer.</p>
<p >The Figure below describes the structure of <code>REQUEST</code> and <code>ASYNC</code> packets.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-request-async-packet-structure.svg" style="pointer-events: none;"></object>
</div>
    <p ><b>Figure</b>: <code>REQUEST</code> / <code>ASYNC</code> packet structure</p>
<p >The <b>Type</b> field of <code>REQUEST</code> and <code>ASYNC</code> packets is set to <b>9</b>.</p>
<p >The value of the <b>Payload Length</b> field is set to the number of bytes of the Payload part of the packet. The CRC field is not part of the payload and is only present if negotiated at connection establishment time. In addition, if the Payload size is <b>0</b>, no CRC field is transmitted even if negotiated on the connection. The total length of a <code>REQUEST</code> or an <code>ASYNC</code> packet, in bytes, is:</p>
<ul>
<li>4 + <b>Payload Length</b> + 2, if a CRC field is present.</li>
<li>4 + <b>Payload Length</b>, if no CRC is present.</li>
</ul>
<p ><code>REQUEST</code> and <code>ASYNC</code> packets are used to transmit data buffers submitted by users of the protocol. These data buffers cannot be empty, so the <b>Payload Length</b> field of these packets should not be <b>0</b>. However, the Controller can send <code>REQUEST</code> packets with no payload (and thus a <b>Payload Length</b> field set to <b>0</b>) in order to request the retransmission of the last <code>RESPONSE</code> packet sent by the Performer. See the <a class="el" href="motor-control-protocol-suite.html#synchronous-transactions">Synchronous Transactions</a> section for more details.</p>
<h4><a class="anchor" id="reponse-packet-type"></a>
REPONSE packet type</h4>
<p ><code>REPONSE</code> packets are only sent by the Performer and they have a payload. They are involved in synchronous Transactions. See the <a class="el" href="motor-control-protocol-suite.html#synchronous-transactions">Synchronous Transactions</a> section for more details.</p>
<p >The Figure below describes the structure of a <code>REPONSE</code> packet.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-response-packet-structure.svg" style="pointer-events: none;"></object>
</div>
    <p ><b>Figure</b> : <code>RESPONSE</code> packet structure</p>
<p >The <b>Type</b> field of <code>RESPONSE</code> packets is set to <b>10</b>.</p>
<p >The value of the <b>Payload Length</b> field is set to the number of bytes of the Payload part of the packet. The CRC field is not part of the payload and is only present if negotiated at connection establishment time. The total length of a <code>RESPONSE</code> packet, in bytes, is:</p>
<ul>
<li>4 + <b>Payload Length</b> + 2, if a CRC field is present.</li>
<li>4 + <b>Payload Length</b>, if no CRC is present.</li>
</ul>
<p ><code>RESPONSE</code> packets are used to transmit data buffers submitted by users of the protocol. These data buffers cannot be empty, so the Payload length field of these packets must not be <b>0</b>.</p>
<h3><a class="anchor" id="connection-procedure"></a>
Connection Procedure</h3>
<p >Prior to exchanging data across ASPEP, two hosts must connect. The connection procedure describes how such a connection is established.</p>
<p >The need for establishing a connection comes from the fact that both hosts can have different capabilities. For example, one of the hosts can be a PC that has plenty of RAM and computing power while the other is an STM32 device that is much more limited in both respects. And different STM32 devices have very different capabilities. So, for the communication to be possible, hosts need to know the capabilities of one another, and they need to agree on a usage of these capabilities that both can handle. The main purpose of the ASPEP connection procedure is to let both hosts negotiate this agreement. In addition, the connection procedure also allows the Controller to get some state variables from the Performer that it needs to manage the connection.</p>
<h4><a class="anchor" id="connection-procedure-overview"></a>
Connection Procedure overview</h4>
<p >The connection is initiated by the <b>Controller</b>. It is triggered by a user submitting a <em>Connection Request</em>, while the <b>Controller</b> is in the <code>IDLE</code> state. If the <b>Controller</b> is not in the <code>IDLE</code> state, the connection procedure cannot start, and the connection request is aborted.</p>
<p >The connection procedure is made of two phases.</p>
<p >In the first phase, the parameters of the connection are negotiated. This is done by exchanging pairs of <code>BEACON</code> packets: the Controller sends a <code>BEACON</code> packet with values it can support for the parameters and the Performer answers with parameters that both can support. The negotiation ends when a pair of identical <code>BEACON</code> packets is exchanged: The Controller sends a <code>BEACON</code> packet and the Performer responds with the very same <code>BEACON</code>. A Typical parameters negotiation phase then requires the exchange of one or two pairs of <code>BEACON</code> packet: one if the capabilities of the Controller are compatible with that of the Performer, two otherwise. In some cases, it may require more exchanges, for instance when the Controller and the Performer disagree on the version of ASPEP to use.</p>
<p >The purpose of the second phase is to let the Controller identify the link and get some status information from the Performer that are needed for the remainder of the connection.</p>
<p >This procedure is outlined in the figure below, it is described in more details in the following sections.</p>
<h4><a class="anchor" id="connection-procedure-details"></a>
Connection procedure details</h4>
<div class="image">
<object type="image/svg+xml" data="aspep-connection-procedure.svg" style="pointer-events: none;"></object>
</div>
    <p ><b>Figure</b>: Connection Procedure</p>
<p >The connection procedure is made of 6 steps that are highlighted in the Figure above:</p>
<p ><u><b>Step 1:</b></u> The procedure starts with the Controller sending a <code>BEACON</code> packet. The Controller sets the fields of this <code>BEACON</code> packet according to its capabilities:</p>
<ul>
<li><b>CRC</b> is set to <b>1</b> if the Controller supports computing, inserting, and checking the <b>CRC</b> field of packets with payload. It is set to <b>0</b> otherwise.</li>
<li><b>RXS Max</b> is set according to the Controller’s $P_{REQMax}$ parameter reset value</li>
<li><b>TXS Max</b> is set according to the Controller’s $P_{RESPMax}$ parameter reset value</li>
<li><b>TXA Max</b> is set according to the Controller’s $P_{ASYNCMax}$ parameter reset value</li>
</ul>
<p >The Controller also sets the Version field of the <code>BEACON</code> to the number of the latest version of ASPEP it supports.</p>
<p >The computation of the <b>RXS Max</b>, <b>TXS Max</b> and <b>TXA Max</b> fields is done according to the rules stated in sections <a class="el" href="motor-control-protocol-suite.html#maximum-request-payload-size">Maximum REQUEST payload size</a>, <a class="el" href="motor-control-protocol-suite.html#maximum-response-payload-size">Maximum RESPONSE payload size</a> and <a class="el" href="motor-control-protocol-suite.html#maximum-async-payload-size">Maximum ASYNC payload size</a>. <br  />
</p>
<p >On sending the <code>BEACON</code> packet, the Controller switches to the <code>CONFIGURING</code> state.</p>
<p ><u><b>Step 2:</b></u> On reception of the <code>BEACON</code> packet, the Performer first transitions to the <code>IDLE</code> state (unless it is already in it). In this state, the Performer can only send <code>BEACON</code> and <code>PING</code> packets and it can only do so in order to respond to similar packets sent by the Controller. If a synchronous transaction is pending in the Performer, it is aborted, so the Performer will not send a <code>RESPONSE</code> packet to close it.</p>
<p >The Performer then checks whether the capabilities proposed by the Controller are acceptable. To that end, it first checks the Version field.</p>
<p >If its value is not that of an ASPEP version number it supports, the Performer sends a <code>BEACON</code> packet with the highest ASPEP version number it can handle and sets the other fields according to its own reset values of the $P_{CRC}$, $P_{REQMax}$, $P_{RESPMax}$ and $P_{ASYNCMax}$ parameters. It remains in the <code>IDLE</code> state.</p>
<p >If the value of the Controller’s Version field is that of an ASPEP version it supports, the Performer checks the compatibility of the other parameters sent by the Controller according to the following criteria:</p>
<ul>
<li>$P_{REQMax}$: Controller’s $P_{REQMax}$ ≤ Performer’s $P_{REQMax}$</li>
<li>$P_{RESPMax}$: Controller’s $P_{RESPMax}$ = Performer’s $P_{RESPMax}$</li>
<li>$P_{ASYNCMax}$ : Controller’s $P_{ASYNCMax}$ = Performer’s $P_{ASYNCMax}$</li>
<li>$P_{CRC}$ : Controller’s = Performer’s</li>
</ul>
<p >Parameters sent by the Controller that are compatible with the Performer are kept. If a parameter is incompatible a new, compatible, value is computed for it according to the following indications:</p>
<ul>
<li>$P_{REQMax}$: minimum of Controller’s $P_{REQMax}$ and Performer’s $P_{REQMax}$</li>
<li>$P_{RESPMax}$: minimum of Controller’s $P_{RESPMax}$ and Performer’s $P_{RESPMax}$</li>
<li>$P_{ASYNCMax}$: minimum of Controller’s $P_{ASYNCMax}$ and Performer’s $P_{ASYNCMax}$</li>
<li>$P_{CRC}$: set to false if Controller’s and Performer’s $P_{CRC}$ differ</li>
</ul>
<p >The Performer then builds and sends a new <code>BEACON</code> packet with the <b>RXS Max</b>, <b>TXS Max</b> and <b>TXA Max</b> parameters set according to compatible values (the ones kept from the Controller and the newly computed ones) of the parameters and the same Version field as in the Controller’s <code>BEACON</code>.</p>
<p >If the <code>BEACON</code> sent by the Performer is identical to the one received from the Controller, the Performer switches to the <code>CONNECTED</code> state. The Performer is then ready to exchange data with the Controller. From that point on, it can send <code>ASYNC</code> packets and respond to <code>REQUEST</code> packets.</p>
<p ><u><b>Step 3:</b></u> When the Controller receives the <code>BEACON</code> packet returned by the Performer, it first checks if this <code>BEACON</code> is identical to the one it sent in step 1. If that is the case, the Controller switches directly to the <code>CONNECTING</code> state and the procedure carries on from step 5. <br  />
</p>
<p >If that is not the case, two possibilities are at stake: either the Version field returned by the Performer differs from that sent by the Controller or it is identical. <br  />
</p>
<p >If the Version fields differ, the connection procedure restarts from the beginning (step 1) with the Version value sent by the Performer, provided that the Controller supports it. If the Controller does not support the protocol version proposed by the Performer, either the connection aborts or the Controller can try again with a lower version number, that it supports, if any exists. <br  />
</p>
<p >If the Version fields are the same, the Performer has sent its own proposal for the parameters and their values should be acceptable to the Controller. The Controller checks if these values are indeed compatible with its own. If they are not, it computes compatible values and sends a new <code>BEACON</code> packet and the procedure carries on from step 2. If they are compatible, the Controller send a new <code>BEACON</code> packet identical to the one received by the Performer.</p>
<p ><u><b>Step 4:</b></u> On reception of the <code>BEACON</code> packet from the Controller, the Performer acts as in Step 2: It sends the <code>BEACON</code> packet back to the Controller with compatible parameters. If this <code>BEACON</code> is identical to the one received from the Controller, the Performer switches to the <code>CONNECTED</code> state.</p>
<p ><u><b>Step 5:</b></u> In this step, the Controller expects to receive a <code>BEACON</code> packet that is identical to the one it previously sent. If this is not the case, the connection procedure carries on from step 3. <br  />
</p>
<p >On reception of an identical <code>BEACON</code> packet, the Controller switches to the <code>CONNECTING</code> state and sends a <code>PING</code> packet. The purpose is to request the status of the Performer and the identification of the link.</p>
<p ><u><b>Step 6:</b></u> On reception of the <code>PING</code> packet from the Controller, the Performer answers with a <code>PING</code> packet with the following field values:</p>
<ul>
<li><b>C</b>: set to <b>1</b> unless the Save device has been reset between the end of step 4 and the reception of the <code>PING</code> packet from the Controller <br  />
</li>
<li><b>N</b>: set to the bit <b>0</b> of the $N_{NREQ}$ counter of the Performer. <b>N</b> is <b>0</b> if $N_{NREQ}$ is even and 1 if $N_{NREQ}$ is odd.</li>
<li><b>LIID</b>: set to the Layer Instance Identifier attached to the link on the Performer. For more details on this parameter, see section <a class="el" href="motor-control-protocol-suite.html#layer-instance-identifier">Layer Instance IDentifier</a></li>
</ul>
<p >When the Controller receives this PING packet, it switches to the CONNECTED state, unless the C field is 0, and records the values of the fields:</p>
<ul>
<li><b>N</b> is used to initialize the value of the $N_{NREQ}$ counter of the Controller. See the <a class="el" href="motor-control-protocol-suite.html#next-request-packet-number">Next Request Packet Number</a> section for more details</li>
<li><b>LIID</b> is saved to be made available to the user of this ASPEP instance so that it can identify the link it is working on.</li>
</ul>
<p >If the <b>C</b> field of the received <code>PING</code> is set to <b>0</b>, it is up to the Controller to either abort the <em>Connection Request</em> or retry it.</p>
<h4><a class="anchor" id="beacon-and-ping-repetitions"></a>
BEACON and PING repetitions</h4>
<p >The Controller is free to initiate the connection procedure when it wants. Then, the Performer may be unavailable at the time the first <code>BEACON</code> packets are sent (it may be Off, or halted on a breakpoint, or the link quality may be temporarily low…). In that case, it will not receive this packet, and the connection cannot be established.</p>
<p >To solve this issue, the Controller keeps on sending <code>BEACON</code> packets periodically until it gets a <code>BEACON</code> answer from the Performer. This <code>BEACON</code> transmission periodicity is a Controller side parameter named $T_{BEACON}$. Its value is set by and on the Controller side only and is not negotiated with the Performer. It should be set at a value that is reasonably higher than the expected round trip time between the Controller and the Performer. See the section <a class="el" href="motor-control-protocol-suite.html#beacon-packets-transmission-period">BEACON packets transmission period</a> below for more information on this parameter.</p>
<p >This <code>BEACON</code> retransmission scheme is used whenever the Controller sends a <code>BEACON</code> packet, whether it is the first <code>BEACON</code> filled with Controller’s capabilities or a later <code>BEACON</code> packet sent with merged capabilities.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-connection-procedure-with-repetitions.svg" style="pointer-events: none;"></object>
</div>
    <p ><b>Figure</b> : Connection procedure with <code>BEACON</code> and <code>PING</code> repetition</p>
<p >Similarly, the Performer may not fail receiving <code>PING</code> packets that are sent in the second phase of the connection procedure. To overcome this issue, the Controller keeps on sending <code>PING</code> packets periodically until it gets a <code>PING</code> packet as answer from the Performer. The <code>PING</code> transmission periodicity is a Controller side parameter named $T_{PING}$. Just like for the $T_{BEACON}$ parameter, its value is set by and on the Controller side only and is not negotiated with the Performer. It should be set at a value that is reasonably higher than the expected round trip time between the Controller and the Performer. See section <a class="el" href="motor-control-protocol-suite.html#keep-alive-packets-transmission-period">Keep-Alive packets transmission period</a> below for more information on this parameter.</p>
<p >These <code>BEACON</code> and <code>PING</code> retransmission schemes are not specific to the connection procedure. They are applied each time the Controller sends a <code>BEACON</code> or a <code>PING</code> packet. Note that the Performer only sends <code>BEACON</code> and <code>PING</code> packets to answer <code>BEACON</code> and <code>PING</code> packets sent by the Controller, respectively.</p>
<h4><a class="anchor" id="error-handling"></a>
Error handling</h4>
<p >Packets can be badly received, by the Controller or the Performer. During the connection procedure, this can be either because the <b>CRCH</b> field of the received packet is wrong or because the type of the packet is unknown or unexpected at that stage.</p>
<p >When the <b>Performer</b> receives such a packet, it answers with an <code>ERROR</code> packet which <b>Error Code</b> field is either <em>Bad Header</em> (4) if the <b>CRCH</b> field is wrong or <em>Bad Packet Type</em> (1) if the <b>CRCH</b> field is correct, but the packet type is unknown or unexpected. Upon reception of an <code>ERROR</code> packet during the connection procedure, the Controller simply resends the last packet it sent whether it was a <code>BEACON</code> or a <code>PING</code>.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-connection-procedure-with-errors.svg" style="pointer-events: none;"></object>
</div>
    <p ><b>Figure</b>: Errors in the connection procedure</p>
<p >When the Controller receives a bad packet, during the connection procedure, it restarts the Connection Procedure from the beginning which is equivalent to initiating a <a class="el" href="motor-control-protocol-suite.html#recovery-procedure">Recovery Procedure</a> (see below).</p>
<h3><a class="anchor" id="recovery-procedure"></a>
Recovery Procedure</h3>
<p >The goal of the recovery procedure is is to resynchronize the the communication between the Controller and the Performer. It is initiated by the Controller after its receiving any of the following:</p>
<ul>
<li>A packet with an incorrect <b>CRCH</b> field (Bad Header)</li>
<li>A packet with a wrong <b>Type</b> field (Bad Type)</li>
<li>A packet with a wrong <b>Payload Length</b> field (Bad Length)</li>
<li>An <code>ERROR</code> packet from the Performer indicating either a Bad Header, a Bad Type or a Bad Length error.</li>
</ul>
<p >In any of these conditions, either the Controller or the Performer is unable to determine the starting bit of the next packet it will receive. Indeed a malformed packet Header has been received that can be followed by a payload which size is unknown. So, such a packet header can be followed by an unknown number of bytes before a new packet it sent and the receiving side cannot know where to look for the start of the next packet. The Recovery procedure is meant to recover from this issue.</p>
<p >The following figure illustrates the Recovery Procedure.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-recovery-procedure.svg" style="pointer-events: none;"></object>
</div>
    <p >The Controller starts sending <code>BEACON</code> packets with the $T_{BEACON}$ periodicity. The capabilities proposed in these packets are the ones previously negotiated with the Performer. The Controller keeps on sending these until it receives an identical <code>BEACON</code> packet in return.</p>
<p >When the Controller sends the first <code>BEACON</code> packet of the recovery procedure, the Performer may still be transmitting. In that case, the <code>BEACON</code> sending periodicity can be relaxed. It is possible (even though the probability is low) that the data that the Performer is sending at that time contains a sequence of byte that is identical to the <code>BEACON</code> packet expected by the Controller. For this reason, once the Controller has received the expected BEACON packet from the Performer, it waits for a period, $T_{SILENCE}$, during which the Performer must not send anything. Then, the Controller sends another <code>BEACON</code> packet, identical to the first one. Once the Performer has answered it, the recovery procedure ends and the two devices can resume their communication.</p>
<p >If the Performer sends anything during the $T_{SILENCE}$ period, the Controller restarts the Recovery Procedure from the beginning.</p>
<p >The $T_{SILENCE}$ period should be chosen so that it lets enough time for the Performer to prepare <b>and</b> send its biggest possible packet. See</p>
<p >On receiving a <code>BEACON</code> packet while it is already connected, the Performer must do the following:</p>
<ol type="1">
<li>If it is transmitting a packet, it carries on transmitting it to the end. If this packet is a <code>RESPONSE</code> packet, the synchronous transaction is complete.</li>
<li>answer the <code>BEACON</code> packet with an identical <code>BEACON</code> packet</li>
<li>If a synchronous transaction is pending (its <code>RESPONSE</code> packet has not been sent), it is aborted and the <code>RESPONSE</code> packet will not be sent.</li>
<li>Any packet that would have been submitted for transmission by the upper level protocol is discarded and will not be sent</li>
</ol>
<ol type="1">
<li>The upper level protocol using ASPEP is notified that a recovery procedure is on-going and that any service that uses the Asynchronous channel must be reset. The Controller needs to reconfigure any such service before <code>ASYNC</code> packets can be sent again. on the connection.</li>
</ol>
<p >On initiating a Recovery Procedure, the Controller notifies the upper level protocol using ASPEP of the fact. It also notifies it when the the Recovery Procedure has completed so that any service that uses the Asynchronous channel can be reconfigured.</p>
<p >The Controller may decide to close the connection after a number of restarts of the Recovery Procedure. This number is not specified and depends on the implementation.</p>
<h3><a class="anchor" id="keep-alive-procedure"></a>
Keep-Alive procedure</h3>
<p >The Keep-Alive procedure assesses the availability of the connection and provides statuses from the Performer. It is triggered by the Controller on its own initiative and on criteria that are not specified by this document and an implementation choice. But the intention with the Keep-Alive procedure is to use it to check that the Performer is still online and connected. So, it would rather be used if and when no packets have been exchanged between the Controller and the Performer for a while.</p>
<p >The figure below illustrates the Keep-Alive procedure in its typical course:</p>
<div class="image">
<object type="image/svg+xml" data="aspep-keep-alive-procedure.svg" style="pointer-events: none;"></object>
</div>
    <p >The Controller is sending a <code>PING</code> message to start the Keep-Alive procedure. The Performer shall answer it with a <code>PING</code> message, which terminates the procedure.</p>
<p >If the Performer does not answer the <code>PING</code> message from the Controller, the controller would keep on sending <code>PING</code> packets with a $T_{PING}$ periodicity until either the Performer answers or the Controller decides that the Performer is not active anymore and that the connection is closed. This latter decision is an implementation choice on the Controller side and it is not specified in this document. The following figure depicts this situation.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-keep-alive-procedure-repetitions.svg" style="pointer-events: none;"></object>
</div>
    <p >The Keep-Alive procedure can also be used outside of a connection. It is then used to check the presence of a Performer and query its status.</p>
<p >The Keep-Alive procedure can be terminated by the Performer sending an <code>ERROR</code> message. This occurs when the Performer fails to properly decode a <code>PING</code> packet sent by the Controller. Also, it can be terminated if the Controller fails to properly decode a <code>PING</code> packet received from the Performer. If either of these situation occur while a connection is active, a <a class="el" href="motor-control-protocol-suite.html#recovery-procedure">Recovery Procedure</a> is initiated by the Controller. This document does not specify what should happen if any of these situations occur outside of a connection.</p>
<h3><a class="anchor" id="synchronous-transactions"></a>
Synchronous Transactions</h3>
<p >A Synchronous transaction consists in the sending by the Controller of a <code>REQUEST</code> packet that is answered by the Performer with a <code>RESPONSE</code> packet. Packets of type <code>REQUEST</code> and <code>RESPONSE</code> constitute the Synchronous channel. Synchronous Transactions can only occur once a connection is established. Both <code>REQUEST</code> and <code>RESPONSE</code> packet transport a payload. Synchronous transaction are a way for the Controller to send commands to the Performer and for the Performer to send data as a reply to these commands.</p>
<p >The figure below illustrates a Synchronous transaction.</p>
<div class="image">
<object type="image/svg+xml" data="aspep-synchronous-transaction.svg" style="pointer-events: none;"></object>
</div>
    <p >A Synchronous transaction is always initiated by the Controller. It does this by sending a <code>REQUEST</code> packet. The Performer shall send exactly one <code>RESPONSE</code> packet as an answer to the <code>REQUEST</code> packet. The sending (and the reception) of this <code>RESPONSE</code> packet terminates the transaction.</p>
<p >At most one transaction can be on-going on an ASPEP connection. So, the Controller needs to wait the end of an on-going transaction before it can start another one.</p>
<p >The Performer shall not send unsolicited <code>RESPONSE</code> packets.</p>
<p >A synchronous transaction can also be terminated by the Performer sending an <code>ERROR</code> message with the Bad Header, Bad Packet Type or Bad Packet Size error code. This occurs when the Performer fails to properly decode the Header of a <code>REQUEST</code> packet sent by the Controller. It can also be terminated if the Controller fails to properly decode the Header of a <code>RESPONSE</code> packet received from the Performer (Bad Header, Bad Packet Type or Bad Packet Size errors). If either of these situation occur, a <a class="el" href="motor-control-protocol-suite.html#recovery-procedure">Recovery Procedure</a> is initiated by the Controller.</p>
<p >If the CRC verification on the Payload of the <code>REQUEST</code> packet fails, the Performer sends an <code>ERROR</code> packet with the <em>Bad Payload CRC</em> error code. The Master shall then retransmit the <code>REQUEST</code> packet.</p>
<p >If the CRC verification on the Payload of the <code>RESPONSE</code> packet fails, the Controller can send an empty <code>REQUEST</code> packet (payload size set to 0) to request the retransmission, by the Performer of this <code>RESPONSE</code> packet.</p>
<p >A CRC verification on the Payload is mandatory on either side of the connection if the $P_{CRC}$ parameter is negotiated to <code>true</code> at connection establishment time.</p>
<h3><a class="anchor" id="asynchronous-data-transfers"></a>
Asynchronous data transfers</h3>
<p >The Performer can send unsolicited data to the Controller by sending <code>ASYNC</code> packets. Packets of type <code>ASYNC</code> can only be sent by the Performer, and when a connection is established. They constitute the Asynchronous channel.</p>
<p >There is no way for the Controller to request the retransmission of an <code>ASYNC</code> packet in case the verification on the Payload of one of these packets would fail. A CRC verification on the Payload is mandatory on the Controller if the $P_{CRC}$ parameter is negotiated to <code>true</code> at connection establishment time.</p>
<p ><code>ASYNC</code> packets are a way for the Performer to send large amount of real time data to the Controller.</p>
<h3><a class="anchor" id="errors-handling-on-the-performer"></a>
Errors handling on the Performer</h3>
<p >The processing of errors is done differently on the Controller and on the Performer. As the Controller has the initiative, it can trigger a recovery procedure if need be or take any other action needed to keep the connection active and working.</p>
<p >The Performer, however, cannot initiate any procedure. The only thing it can do when it comes across an erroneous situation is sending an <code>ERROR</code> packet to the Controller. On any error detected on the reception of a packet from the Controller (see the <a class="el" href="motor-control-protocol-suite.html#error-packet-type">ERROR packet type</a>), and at any time, the Performer can send an <code>ERROR</code> packet.</p>
<p >When this occurs during the normal operations of a connection, the handling of <code>ERROR</code> packets by the Controller is defined in the <a class="el" href="motor-control-protocol-suite.html#keep-alive-procedure">Keep-Alive procedure</a>, <a class="el" href="motor-control-protocol-suite.html#synchronous-transactions">Synchronous Transactions</a> and <a class="el" href="motor-control-protocol-suite.html#asynchronous-data-transfers">Asynchronous data transfers</a> sections above.</p>
<p >When an <code>ERROR</code> packet is sent in the course of a <a class="el" href="motor-control-protocol-suite.html#connection-procedure">Connection Procdecure</a> or in that of a <a class="el" href="motor-control-protocol-suite.html#recovery-procedure">Recovery Procedure</a>, the whole procedure in which this occurs is restarted.</p>
<h3><a class="anchor" id="aspep-parameters-details"></a>
ASPEP Parameters Details</h3>
<p >As described above, the configuration of an ASPEP connection depends on a set of parameters. These parameters are negotiated at the very start of the connection, as part of the Connection Procedure. Each host has its own value – the <em>reset</em> value – for each of them, that indicate its level of support for the related feature. When the negotiation of a connection procedure completes successfully both hosts share a common, mutually acceptable, value for each of these parameters – the <em>connection</em> value.</p>
<p >Some other parameters are not negotiated and their values are defined on a per-application basis. It is then expected that sensible values are chosen by the application. In these cases, a hint is provided in this document to explain how to choose a value.</p>
<h4><a class="anchor" id="payload-crc-support"></a>
Payload CRC Support</h4>
<p >In the context of an established connection, the <em>Payload CRC support</em> parameter, $P_{CRC}$, indicates whether a CRC is computed on the payload of <code>REQUEST</code>, <code>RESPONSE</code> and <code>ASYNC</code> packets and transmitted with them.</p>
<p >If $P_{CRC}$ is true, each packet with a payload is sent with a CRC field computed as described in section <a class="el" href="motor-control-protocol-suite.html#packet-payload-and-crc">Packet payload and CRC</a> above. Hosts shall then check the validity of the CRC field of each received payload.</p>
<p >If $P_{CRC}$ is false, no CRC field is sent with the payloads and thus, no payload validity check can be performed.</p>
<h4><a class="anchor" id="maximum-request-payload-size"></a>
Maximum REQUEST payload size</h4>
<p >In the context of an established connection, the <em>Maximum REQUEST payload size</em> parameter, $P_{REQMax}$, is the maximum size of the payload of a <code>REQUEST</code> packet that can be sent on this connection. Put another way, it is the maximum size of a payload that a Performer will receive (and that a Controller will send) on the Synchronous channel of that connection.</p>
<p >Outside of an established connection context, $P_{REQMax}$ is the maximum size of the payload of a <code>REQUEST</code> packet that a Host can handle. It is typically the size of buffers allocated to sending or receiving the payload of <code>REQUEST</code> packets in a Controller or a Performer respectively.</p>
<p >$P_{REQMax}$ allowed values are multiples of 32 bytes, ranging from 32 to 2048 inclusive.</p>
<p >The value of the $P_{REQMax}$ connection parameter is negotiated with the RXS Max field of <code>BEACON</code> packets. The relationship between $P_{REQMax}$ and RXS Max is:</p>
<p >$$P_{REQMax} = (RXS\ Max + 1) \times 32$$</p>
<p >the RXS Max field is 6 bits wide allowing for a maximum value of 63. An RXS Max of 0 specifies a $P_{REQMax}$ of 32 bytes and an RXS Max of 63 specifies a $P_{REQMax}$ of 2048 bytes.</p>
<h4><a class="anchor" id="maximum-response-payload-size"></a>
Maximum RESPONSE payload size</h4>
<p >In the context of an established connection, the <em>Maximum RESPONSE payload size</em> parameter, $P_{RESPMax}$, is the maximum size of the payload of a <code>RESPONSE</code> packet that can be sent on this connection. Put another way, it is the maximum size of a payload that a Performer will send (and that a Controller will receive) on the Synchronous channel of that connection.</p>
<p >Outside of an established connection context, $P_{RESPMax}$ is the maximum size of the payload of a <code>RESPONSE</code> packet that a Host can handle. It is typically the size of buffers allocated to sending or receiving the payload of <code>RESPONSE</code> packets in a Performer or a Controller respectively.</p>
<p >$P_{RESPMax}$ allowed values are multiples of 32 bytes, ranging from 32 to 4096 inclusive.</p>
<p >The value of the $P_{RESPMax}$ connection parameter is negotiated with the TXS Max field of <code>BEACON</code> packets. The relationship between $P_{RESPMax}$ and TXS Max is:</p>
<p >$$P_{RESPMax} = (TXS\ Max + 1)\times 32$$</p>
<p >the TXS Max field is 7 bits wide allowing for a maximum value of 127. A TXS Max of 0 specifies a $P_{RESPMax}$ of 32 bytes and a TXS Max of 127 specifies a $P_{RESPMax}$ of 4096 bytes.</p>
<h4><a class="anchor" id="maximum-async-payload-size"></a>
Maximum ASYNC payload size</h4>
<p >In the context of an established connection, the <em>Maximum ASYNC payload size</em> parameter, $P_{ASYNCMax}$, is the maximum size of the payload of an <code>ASYNC</code> packet that can be sent on this connection. Put another way, it is the maximum size of a payload that a Performer will send on the Asynchronous channel of that connection.</p>
<p >Outside of an established connection context, $P_{ASYNCMax}$ is the maximum size of the payload of an ASYNC packet that a Host can handle. It is typically the size of buffers allocated to sending or receiving the payload of ASYNC packets in a Performer or a Controller respectively.</p>
<p >$P_{ASYNCMax}$ allowed values are multiples of 64 bytes, ranging from 0 to 8128 inclusive.</p>
<p >The value of the $P_{ASYNCMax}$ connection parameter is negotiated with the TXA Max field of <code>BEACON</code> packets. The relationship between $P_{ASYNCMax}$ and TXA Max is:</p>
<p >$$P_{ASYNCMax} = (TXA\ Max)\times 64$$</p>
<p >the TXA Max field is 7 bits wide allowing for a maximum value of 127. A TXA Max of 0 specifies a $P_{ASYNCMax}$ of 0 byte and a TXA Max of 127 specifies a $P_{ASYNCMax}$ of 8128 bytes. In other words, a value of 0 means that the Asynchronous channel is either not negotiated in the current connection or not supported by the Host depending on the context in which the $P_{ASYNCMax}$ is evaluated. If $P_{ASYNCMax}$ is negotiated to 0 in a connection, the Performer is not allowed to send ASYNC packets in that connection and thus, all services relying on <code>ASYNC</code> packets are disabled for the duration of the connection.</p>
<h4><a class="anchor" id="intra-packet-pause"></a>
Intra Packet Pause</h4>
<p >$T_{IPP}$, the Intra Packet Pause is a time interval inserted between the end of the transmission of the Header and the start of the transmission of the payload of an ASPEP packet.</p>
<p >This pause is meant to relax real time constraints that the implementation of ASPEP faces on the Performer side. In this context, a good value for this parameter is greater than the firing period of SysTick interrupt. As an example, in the Motor Control SDK, the ASPEP protocol management routines are executed on that interrupt on the Performer. Then, having a pause greater than this period between the end of the Header and the beginning of the Payload of packets sent to the Performer ensures that the implementation has the opportunity to decode the Header and configure the DMA channel linked to the serial port for the reception of the payload. The use of a DMA channel to read the data received on the serial port is an easy enhancement over the legacy version of the Motor Control Protocol.; It is also one that significantly reduces the CPU power consumption needed to handle the communication while allowing for a much higher data throughput in the Controller to Performer direction.</p>
<p >A $T_{IPP}$ value of 1 ms, in the Controller to Performer direction seems to be a good value. It is the one that is expected by default in the firmware of the MCSDK. In the Performer to Controller direction, the default value used by the firmware is 0 ms. The firmware considers that the Controller is hosted on a processor that has sufficient CPU power to allow for this and it does not insert the Intra Packet Pause.</p>
<p >In the current version of the protocol, this parameter are negotiated between the Controller and the Performer.</p>
<h4><a class="anchor" id="beacon-packets-transmission-period"></a>
BEACON packets transmission period</h4>
<p >The $T_{BEACON}$ parameter is the time interval between the sending of two <code>BEACON</code> packets by the Controller. It is used both for the Connection Procedure and for the Recovery Procedure.</p>
<p >In the current version of the protocol, this parameter is not negotiated between the Controller and the Performer.</p>
<p >This parameter should not be seen as a strict periodicity. It's value should rather be a compromise between workload and reactivity. A sensible value for this parameter is one that is reasonably higher than the expected round trip time between the Controller and the Performer. Such a value needs to consider the throughput of the serial link.</p>
<h4><a class="anchor" id="keep-alive-packets-transmission-period"></a>
Keep-Alive packets transmission period</h4>
<p >The $T_{PING}$ parameter is the time interval between the sending of two <code>PING</code> packets by the Controller. It is used both for the Connection Procedure and for the Keep-Alive procedure.</p>
<p >This parameter is not negotiated between the Controller and the Performer.</p>
<p >Like the $T_{BEACON}$ parameter, it should not be seen as a strict periodicity but more as a compromise. A sensible value for this parameter is one that is reasonably higher than the expected round trip time between the Controller and the Performer, in the case of the Connection Procedure. Such a value needs to consider the throughput of the serial link.</p>
<h4><a class="anchor" id="recovery-procedure-silence-period-"></a>
Recovery procedure Silence period</h4>
<p >The Recovery procedure silence period, $T_{SILENCE}$ aims at making as sure as possible that the Controller and the Performer are synchronized. So, the silence period should be significantly longer than the time it takes to transmit the biggest possible packet from the Performer (usually the $P_{ASYNCMax}$, but it may also be $P_{RESPMax}$) plus the time it would take for the Performer to fill such a packet. In the case of the usage of <code>ASYNC</code> packets by MCP's Datalog service, this can easily be done.</p>
<p >The fact the Performer does not send any data during this period followed by its responding to a <code>BEACON</code> from the Controller is considered a reliable indication that both devices are synchronized. if $T_{SILENCE}$ is too short, the indication is not reliable. If it is too long, the connection performance penalty suffers (and the indication reliability may also be impacted if the Performer may enter a sleep state for instance).</p>
<p >This parameter is not negotiated between the Controller and the Performer.</p>
<h4><a class="anchor" id="layer-instance-identifier"></a>
Layer Instance Identifier</h4>
<p >The <b>LIID</b> field of <code>PING</code> identifies the transport layer on which the connection takes place. ASPEP provisions for two concurrent serial port connections taking place at the same time between a Controller and an Performer, named <code>UART_A</code> and <code>UART_B</code>. The LIID field is set to 0 when the <code>PING</code> packet is transported across the <code>UART_A</code> serial port and to 1 when the <code>PING</code> packet is transported across the <code>UART_B</code> serial port.</p>
<p >ASPEP implementations offer an API for the MCP implementation that sits on top of them to know which Transport Layer is connected. This is useful when configuring the DataLog service for instance.</p>
<h4><a class="anchor" id="next-request-packet-number"></a>
Next Request packet Number</h4>
<p >The $N_{NREQ}$ counter (Next Request Packet Number) is maintained on both sides of the connection. It contains the number of REQUEST packet sent (on the Controller side) or received (on the Performer side). The Controller increments this counter when it has successfully sent a REQUEST packet. The Performer increments this counter when it has successfully received a REQUEST packet. For the Controller, checking the value of the <b>N</b> field of a PING packet received from the Performer can help understanding the status of the last transaction before a Recovery Procedure.</p>
<h3><a class="anchor" id="aspep-versions"></a>
ASPEP Versions</h3>
<p >The ASPEP version as transported in the <b>VERSION</b> field of <code>BEACON</code> packets is a monotonous number that is incremented on each update of the ASPEP protocol. An implementation of the ASPEP protocol on the Controller side should support all the versions of the protocol up to (and including) the one it advertises in the first <code>BEACON</code> packet it sends for establishing a connection. On the Performer side, an implementation of the ASPEP protocol shall support at least one version of the protocol. It can optionally support earlier versions.</p>
<p >The first byte of a BEACON packet is guaranteed to be stable across versions of the protocol. This first byte contains the Type and the VERSION fields. Stable means that the Type field will always be 5 and the version will always be three bits. If later versions of the protocol need to change the header structure of the packets, these two fields will anyway keep their original meaning.</p>
<h2><a class="anchor" id="stlink-exchange-protocol"></a>
STLink Exchange Protocol</h2>
<h3><a class="anchor" id="stlep-overview"></a>
STLEP Overview</h3>
<p >The STLink Exchange Protocol – in short STLEP – is a buffer exchange protocol designed on top of the STLink USB protocol. The STLink feature provides external devices with read and write access to the whole the memory of a target STM32 MCU.</p>
<p >STLEP uses this capability to exchange data buffers between two Hosts, one of which is an STM32 MCU. For more information on STLink, see <a href="https://wiki.st.com/stm32mpu/wiki/ST-LINK">https://wiki.st.com/stm32mpu/wiki/ST-LINK</a>.</p>
<p >STLink is a half-duplex protocol in which the target STM32 MCU plays a totally passive role. It cannot trig any action from the controller. In this context, the RAM of the STM32 should be seen as an exchange area.</p>
<p >The STLEP protocol is not available in the version of the Motor Control Protocol Suite described in this document.</p>
<h1><a class="anchor" id="registers-and-applicative-mcp-commands-"></a>
Registers and Applicative MCP Commands</h1>
<h2><a class="anchor" id="motor-control-and-other-commands"></a>
Motor Control and other Commands</h2>
<h3><a class="anchor" id="the-start_motor-command"></a>
The START_MOTOR command</h3>
<p ><b>Purpose:</b></p>
<p >The <code>START_MOTOR</code> command sets the target motor under control. The motor may start rotating as a result of the execution of this command.</p>
<p ><b>Command ID</b>: <code>0x0003</code>.</p>
<p ><b>Command Payload:</b></p>
<p >This command does not have a payload. The id of the target motor is indicated by the <b>Motor #</b> field of the command.</p>
<p ><b>Response:</b></p>
<p >The Payload of the response is empty. If the command can be executed, the <code>CMD_OK</code> response code is returned. Otherwise, the <code>CMD_NOK</code> response code is returned.</p>
<p >Note that the Response is sent as soon as the command is scheduled for execution. So, returning the <code>CMD_OK</code> recode does not mean that the motor is indeed under control. It only means that the start up procedure is about to be executed.</p>
<h3><a class="anchor" id="the-stop_motor-command"></a>
The STOP_MOTOR command</h3>
<p ><b>Purpose:</b></p>
<p >The <code>STOP_RAMP</code> command sets the target motor out of control. The motor may stop rotating as a result of the execution of this command.</p>
<p ><b>Command ID</b>: <code>0x0004</code>.</p>
<p ><b>Command Payload:</b></p>
<p >This command does not have a payload. The id of the target motor is indicated by the <b>Motor #</b> field of the command.</p>
<p ><b>Response:</b></p>
<p >The Payload of the response is empty. If the command can be executed, the <code>CMD_OK</code> response code is returned. Otherwise, the <code>CMD_NOK</code> response code is returned.</p>
<p >Note that the Response is sent as soon as the command is scheduled for execution. So, returning the <code>CMD_OK</code> recode does not mean that the motor is indeed out of control. It only means that the stop procedure is about to be executed.</p>
<h3><a class="anchor" id="the-stop_ramp-command"></a>
The STOP_RAMP command</h3>
<p ><b>Purpose:</b></p>
<p >The <code>STOP_RAMP</code> command command stops any ramp under execution on the target motor, whether a speed or a torque ramp, if any is under execution at the time of sending.</p>
<p ><b>Command ID</b>: <code>0x0005</code>.</p>
<p ><b>Command Payload:</b></p>
<p >This command does not have a payload. The id of the target motor is indicated by the <b>Motor #</b> field of the command.</p>
<p ><b>Response:</b></p>
<p >The Payload of the response is empty. The command always returns <code>CMD_OK</code>.</p>
<h3><a class="anchor" id="the-start_stop-command"></a>
The START_STOP command</h3>
<p ><b>Purpose:</b></p>
<p >The <code>START_STOP</code> command either starts or stops the target motor. If the motor is idle, the command behaves like the <code>START_MOTOR</code> command, otherwise it behaves like the <code>STOP_MOTOR</code> command.</p>
<p ><b>Command ID</b>: <code>0x0006</code>.</p>
<p ><b>Command Payload:</b></p>
<p >This command does not have a payload. The id of the target motor is indicated by the <b>Motor #</b> field of the command.</p>
<p ><b>Response:</b></p>
<p >The Payload of the response is empty. If the command can be executed, the <code>CMD_OK</code> response code is returned. Otherwise, the <code>CMD_NOK</code> response code is returned.</p>
<p >See the <code>START_MOTOR</code> and <code>STOP_MOTOR</code> commands above for more details.</p>
<h3><a class="anchor" id="the-fault_ack-command"></a>
The FAULT_ACK command</h3>
<p ><b>Purpose:</b></p>
<p >The <code>FAULT_ACK</code> command acknowledges any past but not yet acknowledged motor control subsystem fault. If such fault condition exists, it is cleared and if no fault condition is currently active, the Motor Control subsystem goes back to the <code>IDLE</code> state and a <code>MOTOR_START</code> command can be sent to set the motor under control again.</p>
<p >If no past but not yet acknowledged fault exists, nothing is done.</p>
<p ><b>Command ID</b>: <code>0x0007</code>.</p>
<p ><b>Command Payload:</b></p>
<p >This command does not have a payload. The id of the target motor is indicated by the <b>Motor #</b> field of the command.</p>
<p ><b>Response:</b></p>
<p >The command always returns <code>CMD_OK</code>.</p>
<h3><a class="anchor" id="the-user_cmd-command"></a>
The USER_CMD command</h3>
<p ><b>Purpose:</b></p>
<p >The <code>USER_CMD</code> commands are a set of command codes reserved for application use that will never be allocated to MCP commands. So, users are free to use these code for their own needs. In the ST MCSDK firmware implementation of the MCP, a call-back mechanism is provided for the application to handle them if it needs. Up to 32 such commands can be implemented. See the documentation of ST MCSDK firmware for more details on how to use them in the context of the firmware.</p>
<p ><b>Command ID</b>: <code>0x0020</code> to <code>0x003F</code>.</p>
<p ><b>Command Payload:</b></p>
<p >This command have an arbitrary payload that depends on the user's implementation.</p>
<p ><b>Response:</b></p>
<p >The Payload of the response is arbitrary and depends on the user's implementation. The same is true for possible result codes.</p>
<h2><a class="anchor" id="registers"></a>
Registers</h2>
<p >The registers listed here are the ones that are present on all MCPS implementations and that are needed to set the Datalog service up. Other registers exist that are defined separately.</p>
<p >Registers have a type as specified in <a class="el" href="motor-control-protocol-suite.html#the-registry-service">The registry service</a> section. This type provides the information needed for transmitting the value of registers but it does not allow for properly interpreting it. To that end, two additional information are provided with each register definition: the format and the unit. The unit is the physical unit of the value a register such as Amperes, Volts or Hertz for example.</p>
<p >The format can be one of the following</p>
<ul>
<li>S8: signed 8-bit integer</li>
<li>U8: unsigned 8-bit integer</li>
<li>U8ENUM: 8-bit enumeration</li>
<li>U8FLAGS: 8-bit bitfield</li>
<li>S16: signed 16-bit integer</li>
<li>U16: unsigned 16-bit integer</li>
<li>U16FLAGS: 16-bit bitfield</li>
<li>S32: signed 32-bit integer</li>
<li>U32: unsigned 32-bit integer</li>
<li>U32FLAGS: 32-bit bitfield</li>
<li>F32: 32-bit floating point number</li>
<li>Q32: 32-bit Q-format number</li>
</ul>
<p >Registers as described below have a scope, either Global or Motor. A Global scope means that the register does not target any specific motor. The <b>Motor #</b> field of the register identifier of such registers is 0. A Motor scope register is a register that targets a motor. There can be several instances of such a register in an application, differentiated by the <b>Motor #</b> field of the register identifier, which is non 0.</p>
<h3><a class="anchor" id="the-global_config-register"></a>
The GLOBAL_CONFIG register</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Identifier   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Scope   </th><th class="markdownTableHeadNone">Identification Token   </th><th class="markdownTableHeadNone">Access    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Global   </td><td class="markdownTableBodyNone"><code>0x28</code>   </td><td class="markdownTableBodyNone">Read Only, Constant   </td></tr>
</table>
<p >This register is a Raw Structure that provides high level, non motor dependent, information about the embedded Motor Control FW application. This allows a remote tool to start discovering the configuration of the embedded application.</p>
<p >The following table describes the content of the structure.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Size   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Unit   </th><th class="markdownTableHeadNone">Format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">MCSDKVersion   </td><td class="markdownTableBodyNone">Motor Control SDK Version number.   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U32    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">MotorNumber   </td><td class="markdownTableBodyNone">Number of motors driven by the application   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">MCP Flag   </td><td class="markdownTableBodyNone">MCP feature flag - bit 0 : MCP Over ST Link - bit 1 : MCP Over UART A - bit 2 : MCP Over UART B   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8 Flags    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">MCPA UARTA LOG   </td><td class="markdownTableBodyNone">Number of simultaneous streams supported by the Datalog service on ASPEP with UART A LIID.   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">MCPA UARTB LOG   </td><td class="markdownTableBodyNone">Number of simultaneous streams supported by the Datalog service on ASPEP with UART B LIID   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">MCPA STLNK LOG   </td><td class="markdownTableBodyNone">Number of simultaneous streams supported by the Datalog service over ST Link   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8   </td></tr>
</table>
<p >The <b>MCSDKVersion</b> field is structured as follows:</p>
<ul>
<li>bits 0-5: Pre-release number (only used if Release type is not public)</li>
<li>bits 6-7: Release type:<ul>
<li>0: Alpha</li>
<li>1: Beta</li>
<li>2: RC</li>
<li>3: Public (official)</li>
</ul>
</li>
<li>bits 8-15: Patch release number</li>
<li>bits 16-23: Minor release number</li>
<li>bits 24-31: Major release number</li>
</ul>
<p >The <b>MCP Flag</b> field is a bitfield with the following meaning:</p>
<ul>
<li>bit 0 : MCP Over ST Link</li>
<li>bit 1 : MCP Over UART A</li>
<li>bit 2 : MCP Over UART B</li>
<li>bit 3-7: reserved</li>
</ul>
<h3><a class="anchor" id="the-motor_config-register"></a>
The MOTOR_CONFIG register</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Identifier   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Scope   </th><th class="markdownTableHeadNone">Identification Token   </th><th class="markdownTableHeadNone">Access    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Motor   </td><td class="markdownTableBodyNone"><code>0x69</code> to <code>0x6F</code>   </td><td class="markdownTableBodyNone">Read Only, Constant   </td></tr>
</table>
<p >These registers are Raw Structure that contain the parameters of the motors driven by the embedded Motor Control FW application.</p>
<p >The following table describes the content of the structure.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Size   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Unit   </th><th class="markdownTableHeadNone">Format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">PolePairs   </td><td class="markdownTableBodyNone">Number of pole pairs of the motor.   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">F32    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">RatedFlux   </td><td class="markdownTableBodyNone">Rated magnetic flux of the motor   </td><td class="markdownTableBodyNone">V/Hz   </td><td class="markdownTableBodyNone">F32    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">Rs   </td><td class="markdownTableBodyNone">Rated resistance of the motor   </td><td class="markdownTableBodyNone">Ohm   </td><td class="markdownTableBodyNone">F32    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">RsSkinFactor   </td><td class="markdownTableBodyNone">Coils skin factor   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">F32    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">Ls   </td><td class="markdownTableBodyNone">Inductance of the Motor (In the Q direction in case of of an anisotropic motor)   </td><td class="markdownTableBodyNone">H   </td><td class="markdownTableBodyNone">F32    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">Ld   </td><td class="markdownTableBodyNone">Inductance of the Motor in the D direction   </td><td class="markdownTableBodyNone">H   </td><td class="markdownTableBodyNone">F32    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">MaxCurrent   </td><td class="markdownTableBodyNone">Maximum rated motor current   </td><td class="markdownTableBodyNone">A   </td><td class="markdownTableBodyNone">F32    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">CopperMass   </td><td class="markdownTableBodyNone">Amount of copper used in the windings of the stator of the motor.   </td><td class="markdownTableBodyNone">kg   </td><td class="markdownTableBodyNone">F32    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">CoolingTau   </td><td class="markdownTableBodyNone">Thermal time constant of copper &amp; direct environment of motor   </td><td class="markdownTableBodyNone">s   </td><td class="markdownTableBodyNone">F32    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">24*8   </td><td class="markdownTableBodyNone">Name   </td><td class="markdownTableBodyNone">Name of the motor. A human friendly way to identify it.   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8   </td></tr>
</table>
<h3><a class="anchor" id="the-application_config-register"></a>
The APPLICATION_CONFIG register</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Identifier   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Scope   </th><th class="markdownTableHeadNone">Identification Token   </th><th class="markdownTableHeadNone">Access    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Motor   </td><td class="markdownTableBodyNone"><code>0xA9</code> to <code>0xAF</code>   </td><td class="markdownTableBodyNone">Read Only, Constant   </td></tr>
</table>
<p >Motor applicative configuration. This register is useful for a remote tool that need to know the operative boundaries of a motor driven by the FW application.</p>
<p >The following table describes the content of the structure.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Size   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Unit   </th><th class="markdownTableHeadNone">Format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">MaxMechSpeed   </td><td class="markdownTableBodyNone">Absolute value of the maximum mechnical speed.   </td><td class="markdownTableBodyNone">RPM   </td><td class="markdownTableBodyNone">U32    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">MaxReadableCurrent   </td><td class="markdownTableBodyNone">Absolute value of the maximum current readable by the board. Basically (Vref/(2*Rshunt*OpampGain))   </td><td class="markdownTableBodyNone">A   </td><td class="markdownTableBodyNone">F32    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">nominalCurrent   </td><td class="markdownTableBodyNone">Min of the board current and motor nominal current   </td><td class="markdownTableBodyNone">S16A   </td><td class="markdownTableBodyNone">U16    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">nominalVoltage   </td><td class="markdownTableBodyNone">VBus operating point   </td><td class="markdownTableBodyNone">V   </td><td class="markdownTableBodyNone">U16    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">DriveType   </td><td class="markdownTableBodyNone">Motor Driving technology   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8ENUM    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">Padding   </td><td class="markdownTableBodyNone">Padding field to align structure length on 16-bit boundaries   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8   </td></tr>
</table>
<p >The drive type enum is defined as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">FOC   </td><td class="markdownTableBodyNone">Field Oriented Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">SIX_STEP   </td><td class="markdownTableBodyNone">Six Step   </td></tr>
</table>
<h3><a class="anchor" id="the-foc_firmware_cfg-register"></a>
The FOC_FIRMWARE_CFG register</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Identifier   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Scope   </th><th class="markdownTableHeadNone">Identification Token   </th><th class="markdownTableHeadNone">Access    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Motor   </td><td class="markdownTableBodyNone"><code>0xE9</code> to <code>0xEF</code>   </td><td class="markdownTableBodyNone">Read Only, Constant   </td></tr>
</table>
<p >FOC specific motor drive configuration. This register is present only if the <b>DriveType</b> enumeration field of the <code>APPLICATION_CONFIG</code> register for the same motor is set to <b>FOC</b>. Note that this register has the same identifier as the <code>SIXSTEP_FIRMWARE_CFG</code> register that is only present for a Six Step drive.</p>
<p >The following table describes the content of the structure.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Size   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Unit   </th><th class="markdownTableHeadNone">Format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">PrimSpeedPosSensingType   </td><td class="markdownTableBodyNone">Primary speed and position sensing type   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8ENUM    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">AuxSpeedPosSensingType   </td><td class="markdownTableBodyNone">Auxilliary speed and position sensing type   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8ENUM    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">CurrentSensingTopology   </td><td class="markdownTableBodyNone">Current Sensing Topology   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8ENUM    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">FOCRate   </td><td class="markdownTableBodyNone">Rate of the FOC loop execution in PWM periods. 1 means FOC loop is run every PWM period; 2 means it is run every other PWM periods…   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">PWMFrequency   </td><td class="markdownTableBodyNone">PWM frequency   </td><td class="markdownTableBodyNone">Hz   </td><td class="markdownTableBodyNone">U32    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">MediumFrequencyTaskFreq   </td><td class="markdownTableBodyNone">Medium Frequency Task execution frequency   </td><td class="markdownTableBodyNone">Hz   </td><td class="markdownTableBodyNone">U16    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">ConfigurationFlags1   </td><td class="markdownTableBodyNone">Configuration flags   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U16FLAGS    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">ConfigurationFlags2   </td><td class="markdownTableBodyNone">Configuration flags   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U16FLAGS   </td></tr>
</table>
<p >The <b>PrimSpeedPosSensingType</b> and <b>AuxSpeedPosSensingType</b> enumerations are defined as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">NONE   </td><td class="markdownTableBodyNone">No type used    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">SENSORLESS_STO_PLL   </td><td class="markdownTableBodyNone">Sensorless, State Observer + PLL    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">SENSORLESS_STO_CORDIC   </td><td class="markdownTableBodyNone">Sensorless, State Observer + Cordic (Software flavor)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">QUADRATURE_ENCODER   </td><td class="markdownTableBodyNone">Quadrature Encoder    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">HALL_SENSORS   </td><td class="markdownTableBodyNone">Hall effect sensors   </td></tr>
</table>
<p >The <b>CurrentSensingTopology</b> enumeration is defined as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">THREE_SHUNT   </td><td class="markdownTableBodyNone">Three Shunt current sensing topology    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">SINGLE_SHUNT_ACTIVE_WIN   </td><td class="markdownTableBodyNone">Single Shunt current sensing topology with active window injection (ST patented)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">SINGLE_SHUNT_PHASE_SHIFT   </td><td class="markdownTableBodyNone">Single Shunt current sensing topology with phase shifting    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">TWO_ICS   </td><td class="markdownTableBodyNone">Two Insulated Current Sensors   </td></tr>
</table>
<p >The <b>ConfigurationFlags1</b> is defined as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Bit   </th><th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">FLUX_WEAKENING   </td><td class="markdownTableBodyNone">The Flux Weakening feature is present    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">FEED_FORWARD   </td><td class="markdownTableBodyNone">The Feed Forward feature is present    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">MTPA   </td><td class="markdownTableBodyNone">The Maximum Torque Per Ampere feature is present    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">PFC   </td><td class="markdownTableBodyNone">The Power Form factor Correction feature is present    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">ICL   </td><td class="markdownTableBodyNone">The Inrush Current Limiter feature is present    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">RESISTIVE_BREAK   </td><td class="markdownTableBodyNone">The Resistive Break feature is present    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">OCP_DISABLE   </td><td class="markdownTableBodyNone">The Over Current Protection Disabling feature is present    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">STGAP   </td><td class="markdownTableBodyNone">STGAP1S intelligent gate drivers are used    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">POSITION_CTRL   </td><td class="markdownTableBodyNone">The Position Control feature is present    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone">VBUS_SENSING   </td><td class="markdownTableBodyNone">The VBUS sensing feature is present    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">TEMP_SENSING   </td><td class="markdownTableBodyNone">The Temperature sensing feature is present    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone">VOLTAGE_SENSING   </td><td class="markdownTableBodyNone">The Voltage sensing feature is present    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">12   </td><td class="markdownTableBodyNone">FLASH_CONFIG   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">13   </td><td class="markdownTableBodyNone">DAC_CH1   </td><td class="markdownTableBodyNone">The DAC, channel 1 debug feature is present    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">14   </td><td class="markdownTableBodyNone">DAC_CH2   </td><td class="markdownTableBodyNone">The DAC, channel 2 debug feature is present    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">15   </td><td class="markdownTableBodyNone">ON_THE_FLY_STARTUP   </td><td class="markdownTableBodyNone">The On the Fly Startup feature is present   </td></tr>
</table>
<p >The <b>ConfigurationFlags2</b> is defined as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Bit   </th><th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">OVERMODULATION   </td><td class="markdownTableBodyNone">The Overmudulation feature is present    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">DISCONTINUOUS_PWM   </td><td class="markdownTableBodyNone">The Discontinuous PWM feature is present    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">RESERVED_1   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">RESERVED_2   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">RESERVED_3   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">RESERVED_4   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">RESERVED_5   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">RESERVED_6   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">RESERVED_7   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone">RESERVED_8   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">RESERVED_9   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone">RESERVED_10   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">12   </td><td class="markdownTableBodyNone">RESERVED_11   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">13   </td><td class="markdownTableBodyNone">PROFILER   </td><td class="markdownTableBodyNone">The profiler is enabled in the FW    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">14   </td><td class="markdownTableBodyNone">DBG_MCU_LOAD_MEASURE   </td><td class="markdownTableBodyNone">CPU load measurement feature is present (only posssible on Cortex M3/M4)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">15   </td><td class="markdownTableBodyNone">DBG_OPEN_LOOP   </td><td class="markdownTableBodyNone">Open Loop Voltage and Open Loop Current modes are supported   </td></tr>
</table>
<h3><a class="anchor" id="the-sixstep_firmware_cfg-register"></a>
The SIXSTEP_FIRMWARE_CFG register</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Identifier   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Scope   </th><th class="markdownTableHeadNone">Identification Token   </th><th class="markdownTableHeadNone">Access    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Motor   </td><td class="markdownTableBodyNone"><code>0xE9</code> to <code>0xEF</code>   </td><td class="markdownTableBodyNone">Read Only, Constant   </td></tr>
</table>
<p >Six Step specific motor drive configuration. This register is present only if the <b>DriveType</b> enumeration field of the <code>APPLICATION_CONFIG</code> register for the same motor is set to <b>SIX_STEP</b>. Note that this register has the same identifier as the <code>FOC_FIRMWARE_CFG</code> register that is only present for an FOC drive.</p>
<p >The following table describes the content of the structure.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Size   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Unit   </th><th class="markdownTableHeadNone">Format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">PrimSpeedPosSensingType   </td><td class="markdownTableBodyNone">Primary speed and position sensing type   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8ENUM    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">CurrentSensingTopology   </td><td class="markdownTableBodyNone">Current Sensing Topology   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8ENUM    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">PWMFrequency   </td><td class="markdownTableBodyNone">PWM frequency   </td><td class="markdownTableBodyNone">Hz   </td><td class="markdownTableBodyNone">U32    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">MediumFrequencyTaskFreq   </td><td class="markdownTableBodyNone">Medium Frequency Task execution frequency   </td><td class="markdownTableBodyNone">Hz   </td><td class="markdownTableBodyNone">U16    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">ConfigurationFlags1   </td><td class="markdownTableBodyNone">Configuration flags   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U16FLAGS   </td></tr>
</table>
<p >The <b>PrimSpeedPosSensingType</b> enumeration is defined as the <b>PrimSpeedPosSensingType</b> enumeration of the <code>FOC_FIRMWARE_CFG</code> register.</p>
<p >The <b>CurrentSensingTopology</b> enumeration is defined as the <b>CurrentSensingTopology</b> enumeration of the <code>FOC_FIRMWARE_CFG</code> register.</p>
<p >The <b>ConfigurationFlags1</b> is defined as the <b>ConfigurationFlags1</b> of the <code>FOC_FIRMWARE_CFG</code> register.</p>
<h3><a class="anchor" id="the-datalog_uarta-datalog_uartb-and-datalog_stlink-registers"></a>
The DATALOG_UARTA, DATALOG_UARTB and DATALOG_STLINK registers</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Identifier   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Scope   </th><th class="markdownTableHeadNone">Identification Token   </th><th class="markdownTableHeadNone">Access    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>DATALOG_UARTA</code>   </td><td class="markdownTableBodyNone">20   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Global   </td><td class="markdownTableBodyNone"><code>0x528</code>   </td><td class="markdownTableBodyNone">Read/Write    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>DATALOG_UARTB</code>   </td><td class="markdownTableBodyNone">21   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Global   </td><td class="markdownTableBodyNone"><code>0x568</code>   </td><td class="markdownTableBodyNone">Read/Write    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>DATALOG_STLINK</code>   </td><td class="markdownTableBodyNone">22   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Global   </td><td class="markdownTableBodyNone"><code>0x5A8</code>   </td><td class="markdownTableBodyNone">Read/Write   </td></tr>
</table>
<p >These registers configure the mix of high and low frequency register to record for the Datalog Service available on the UARTA, the UARTB and the STLINK interfaces respectively.</p>
<p >The following table describes the content of the structures of these registers:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Size   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Unit   </th><th class="markdownTableHeadNone">Format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">HFRate   </td><td class="markdownTableBodyNone">High Frequency registers sampling rate   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">HFNum   </td><td class="markdownTableBodyNone">Number of High Frequency registers to record   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">MFRate   </td><td class="markdownTableBodyNone">Medium Frequency registers sampling rate   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">MFNum   </td><td class="markdownTableBodyNone">Number of Medium Frequency registers to record   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">HFNum × 16   </td><td class="markdownTableBodyNone">HFID   </td><td class="markdownTableBodyNone">Regsiters identifiers of the High Frequency registers to record   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U16ARRAY    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MFNum × 16   </td><td class="markdownTableBodyNone">MFID   </td><td class="markdownTableBodyNone">Regsiters identifiers of the Merdium Frequency registers to record   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U16ARRAY    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">Mark   </td><td class="markdownTableBodyNone">Datalog configuration Identifier   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8   </td></tr>
</table>
<p >Setting the Mark field to 0 stops the corresponding Datalog service. For all the details on the fields of these registers, refer to the <a class="el" href="motor-control-protocol-suite.html#the-datalog-service">Datalog service</a> section.</p>
<h3><a class="anchor" id="the-shift_uarta-shift_uartb-and-shift_stlink-registers"></a>
The SHIFT_UARTA, SHIFT_UARTB and SHIFT_STLINK registers</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Identifier   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Scope   </th><th class="markdownTableHeadNone">Identification Token   </th><th class="markdownTableHeadNone">Access    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SHIFT_UARTA</code>   </td><td class="markdownTableBodyNone">25   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Global   </td><td class="markdownTableBodyNone"><code>0x668</code>   </td><td class="markdownTableBodyNone">Read/Write    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SHIFT_UARTB</code>   </td><td class="markdownTableBodyNone">26   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Global   </td><td class="markdownTableBodyNone"><code>0x6A8</code>   </td><td class="markdownTableBodyNone">Read/Write    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SHIFT_STLINK</code>   </td><td class="markdownTableBodyNone">27   </td><td class="markdownTableBodyNone">Raw Structure   </td><td class="markdownTableBodyNone">Global   </td><td class="markdownTableBodyNone"><code>0x6E8</code>   </td><td class="markdownTableBodyNone">Read/Write   </td></tr>
</table>
<p >These registers configure the shift to apply to the value of 32-bit High Frequency registers before recording them in the Datalog service on the UARTA, the UARTB and the STLINK interfaces. These registers are only present when 32-bit HF registers exist which is not the case currently in ST MCSDK.</p>
<p >The following table describes the content of the structures of these registers:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Size   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Unit   </th><th class="markdownTableHeadNone">Format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">n × 8   </td><td class="markdownTableBodyNone">HFRegShift   </td><td class="markdownTableBodyNone">High Frequency registers shift value   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">U8ARRAY   </td></tr>
</table>
<p >n is the number of HF register configured for the related Datalog service.</p>
<h1><a class="anchor" id="document-history"></a>
Document history</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Version   </th><th class="markdownTableHeadNone">Date   </th><th class="markdownTableHeadNone">Comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">2022-12-13   </td><td class="markdownTableBodyNone">Initial version   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
