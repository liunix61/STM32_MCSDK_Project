<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: Src/mc_interface.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_413f4e031a85da0d68269c6fd2f76e1c.html">Src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mc_interface.c File Reference<div class="ingroups"><a class="el" href="group___m_c_s_d_k.html">MCSDK</a> &raquo; <a class="el" href="group___m_c_interface.html">Motor Control Interface</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This file provides firmware functions that implement the features of the MC Interface component of the Motor Control SDK:  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="mc__math_8h.html">mc_math.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="speed__torq__ctrl_8h.html">speed_torq_ctrl.h</a>&quot;</code><br />
<code>#include &quot;speed_ctrl.h&quot;</code><br />
<code>#include &quot;<a class="el" href="mc__interface_8h.html">mc_interface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="motorcontrol_8h.html">motorcontrol.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga69655a488452da04725907b29f3c4d3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga69655a488452da04725907b29f3c4d3e">MCI_Init</a> (MCI_Handle_t *pHandle, <a class="el" href="struct_speedn_torq_ctrl___handle__t.html">SpeednTorqCtrl_Handle_t</a> *pSTC, <a class="el" href="struct_f_o_c_vars__t.html">pFOCVars_t</a> pFOCVars, <a class="el" href="struct_pos_ctrl___handle__t.html">PosCtrl_Handle_t</a> *pPosCtrl, <a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pPWMHandle)</td></tr>
<tr class="memdesc:ga69655a488452da04725907b29f3c4d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes all the object variables, usually it has to be called once right after object creation. It is also used to assign the state machine object, the speed and torque controller, and the FOC drive object to be used by MC Interface.  <a href="group___m_c_interface.html#ga69655a488452da04725907b29f3c4d3e">More...</a><br /></td></tr>
<tr class="separator:ga69655a488452da04725907b29f3c4d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5473dc15507bfd0f73951f0d4c3f819b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga5473dc15507bfd0f73951f0d4c3f819b">MCI_ExecSpeedRamp</a> (MCI_Handle_t *pHandle, int16_t hFinalSpeed, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga5473dc15507bfd0f73951f0d4c3f819b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set a motor speed ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#ga5473dc15507bfd0f73951f0d4c3f819b">More...</a><br /></td></tr>
<tr class="separator:ga5473dc15507bfd0f73951f0d4c3f819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb7e1d924def8953ec0aa4493ba4bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga8fb7e1d924def8953ec0aa4493ba4bcb">MCI_ExecSpeedRamp_F</a> (MCI_Handle_t *pHandle, const float FinalSpeed, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga8fb7e1d924def8953ec0aa4493ba4bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set a motor speed ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#ga8fb7e1d924def8953ec0aa4493ba4bcb">More...</a><br /></td></tr>
<tr class="separator:ga8fb7e1d924def8953ec0aa4493ba4bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814b9ec4c7b544c5fd86a94d4a69b240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga814b9ec4c7b544c5fd86a94d4a69b240">MCI_ExecTorqueRamp</a> (MCI_Handle_t *pHandle, int16_t hFinalTorque, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga814b9ec4c7b544c5fd86a94d4a69b240"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set a motor torque ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#ga814b9ec4c7b544c5fd86a94d4a69b240">More...</a><br /></td></tr>
<tr class="separator:ga814b9ec4c7b544c5fd86a94d4a69b240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f87a17408f48585e42d8b4f531a4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga77f87a17408f48585e42d8b4f531a4e8">MCI_ExecTorqueRamp_F</a> (MCI_Handle_t *pHandle, float FinalTorque, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga77f87a17408f48585e42d8b4f531a4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set a motor torque ramp. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#ga77f87a17408f48585e42d8b4f531a4e8">More...</a><br /></td></tr>
<tr class="separator:ga77f87a17408f48585e42d8b4f531a4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab344cb878cf4f37b34df807cb50a5da5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gab344cb878cf4f37b34df807cb50a5da5">MCI_SetCurrentReferences</a> (MCI_Handle_t *pHandle, <a class="el" href="structqd__t.html">qd_t</a> Iqdref)</td></tr>
<tr class="memdesc:gab344cb878cf4f37b34df807cb50a5da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#gab344cb878cf4f37b34df807cb50a5da5">More...</a><br /></td></tr>
<tr class="separator:gab344cb878cf4f37b34df807cb50a5da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b6a07cf328155f032fa068e9e04d09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gae8b6a07cf328155f032fa068e9e04d09">MCI_SetCurrentReferences_F</a> (MCI_Handle_t *pHandle, <a class="el" href="structqd__f__t.html">qd_f_t</a> IqdRef)</td></tr>
<tr class="memdesc:gae8b6a07cf328155f032fa068e9e04d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#gae8b6a07cf328155f032fa068e9e04d09">More...</a><br /></td></tr>
<tr class="separator:gae8b6a07cf328155f032fa068e9e04d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb5999bf96250ab31a25db5c3acdb969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gabb5999bf96250ab31a25db5c3acdb969">MCI_SetSpeedMode</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gabb5999bf96250ab31a25db5c3acdb969"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#gabb5999bf96250ab31a25db5c3acdb969">More...</a><br /></td></tr>
<tr class="separator:gabb5999bf96250ab31a25db5c3acdb969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a4dbccd507057d014e57bd4e08ecab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga77a4dbccd507057d014e57bd4e08ecab">MCI_SetOpenLoopCurrent</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga77a4dbccd507057d014e57bd4e08ecab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#ga77a4dbccd507057d014e57bd4e08ecab">More...</a><br /></td></tr>
<tr class="separator:ga77a4dbccd507057d014e57bd4e08ecab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab539f38639a4b63e3b26aa4b5bcbf300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gab539f38639a4b63e3b26aa4b5bcbf300">MCI_SetOpenLoopVoltage</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gab539f38639a4b63e3b26aa4b5bcbf300"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set directly the motor current references Iq and Id. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#gab539f38639a4b63e3b26aa4b5bcbf300">More...</a><br /></td></tr>
<tr class="separator:gab539f38639a4b63e3b26aa4b5bcbf300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacfd5ea988bd0b0afe0856836b3ed46e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaacfd5ea988bd0b0afe0856836b3ed46e">MCI_ExecPositionCommand</a> (MCI_Handle_t *pHandle, float FinalPosition, float Duration)</td></tr>
<tr class="memdesc:gaacfd5ea988bd0b0afe0856836b3ed46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffered command to set a mechanical position of rotor. This commands don't become active as soon as it is called but it will be executed when the pSTM state is START_RUN or RUN. User can check the status of the command calling the MCI_IsCommandAcknowledged method.  <a href="group___m_c_interface.html#gaacfd5ea988bd0b0afe0856836b3ed46e">More...</a><br /></td></tr>
<tr class="separator:gaacfd5ea988bd0b0afe0856836b3ed46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad492e094c58042efe4f837fc62a9d887"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gad492e094c58042efe4f837fc62a9d887">MCI_StartMotor</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gad492e094c58042efe4f837fc62a9d887"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to begin the start-up procedure. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value. Before calling MCI_StartMotor it is mandatory to execute one of these commands:<br  />
 MCI_ExecSpeedRamp<br  />
 MCI_ExecTorqueRamp<br  />
 MCI_SetCurrentReferences<br  />
 Otherwise the behavior in run state will be unpredictable.<br  />
 <b>Note:</b> The MCI_StartMotor command is used just to begin the start-up procedure moving the state machine from IDLE state to IDLE_START. The command MCI_StartMotor is not blocking the execution of project until the motor is really running; to do this, the user have to check the state machine and verify that the RUN state (or any other state) has been reached.  <a href="group___m_c_interface.html#gad492e094c58042efe4f837fc62a9d887">More...</a><br /></td></tr>
<tr class="separator:gad492e094c58042efe4f837fc62a9d887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc7c207ed92d6ed2ce1457da51317e4"><td class="memItemLeft" align="right" valign="top">__weak bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gadcc7c207ed92d6ed2ce1457da51317e4">MCI_StartWithMeasurementOffset</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gadcc7c207ed92d6ed2ce1457da51317e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to begin the start-up procedure with an offset calibration even if it has been already done previously. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value. Before calling MCI_StartWithMeasurementOffset it is mandatory to execute one of these commands:<br  />
 MCI_ExecSpeedRamp<br  />
 MCI_ExecTorqueRamp<br  />
 MCI_SetCurrentReferences<br  />
 Otherwise the behaviour in run state will be unpredictable.<br  />
 <b>Note:</b> The MCI_StartWithMeasurementOffset command is used just to begin the start-up procedure moving the state machine from IDLE state to IDLE_START. The command MCI_StartWithMeasurementOffset is not blocking the execution of project until the motor is really running; to do this, the user have to check the state machine and verify that the RUN state (or any other state) has been reached.  <a href="group___m_c_interface.html#gadcc7c207ed92d6ed2ce1457da51317e4">More...</a><br /></td></tr>
<tr class="separator:gadcc7c207ed92d6ed2ce1457da51317e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ffe756795656f7300d3fe4d3a0a3db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga39ffe756795656f7300d3fe4d3a0a3db">MCI_StartOffsetMeasurments</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga39ffe756795656f7300d3fe4d3a0a3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to begin the phase offset calibration procedure. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_StartOffsetMeasurments command is used to begin phase offset calibration procedure moving the state machine from IDLE state to OFFSET_CALIB. The command MCI_StartOffsetMeasurments is not blocking the execution of project until the measurments are done; to do this, the user have to check the state machine and verify that the IDLE state (or any other state) has been reached.  <a href="group___m_c_interface.html#ga39ffe756795656f7300d3fe4d3a0a3db">More...</a><br /></td></tr>
<tr class="separator:ga39ffe756795656f7300d3fe4d3a0a3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb63fd6e9f2537de867d2f976cae29e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaeb63fd6e9f2537de867d2f976cae29e2">MCI_GetCalibratedOffsetsMotor</a> (MCI_Handle_t *pHandle, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *PolarizationOffsets)</td></tr>
<tr class="memdesc:gaeb63fd6e9f2537de867d2f976cae29e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to get the phase offset values. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_GetCalibratedOffsetsMotor command is used to get the phase offset values .  <a href="group___m_c_interface.html#gaeb63fd6e9f2537de867d2f976cae29e2">More...</a><br /></td></tr>
<tr class="separator:gaeb63fd6e9f2537de867d2f976cae29e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5baf843ad8a1d5d1f624c204932e36df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga5baf843ad8a1d5d1f624c204932e36df">MCI_SetCalibratedOffsetsMotor</a> (MCI_Handle_t *pHandle, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *PolarizationOffsets)</td></tr>
<tr class="memdesc:ga5baf843ad8a1d5d1f624c204932e36df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to set the phase offset values. If the state machine is in IDLE state the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_SetCalibratedOffsetsMotor command is used to set the phase offset values . The command MCI_SetCalibratedOffsetsMotor is not blocking the execution of project until the measurments are done; to do this, the user have to check the state machine and verify that the IDLE state (or any other state) has been reached.  <a href="group___m_c_interface.html#ga5baf843ad8a1d5d1f624c204932e36df">More...</a><br /></td></tr>
<tr class="separator:ga5baf843ad8a1d5d1f624c204932e36df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f963eae914e2d3b9016b3f417750fcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga6f963eae914e2d3b9016b3f417750fcf">MCI_StopMotor</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga6f963eae914e2d3b9016b3f417750fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to begin the stop motor procedure. If the state machine is in RUN or START states the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.<br  />
 <b>Note:</b> The MCI_StopMotor command is used just to begin the stop motor procedure moving the state machine to ANY_STOP. The command MCI_StopMotor is not blocking the execution of project until the motor is really stopped; to do this, the user have to check the state machine and verify that the IDLE state has been reached again.  <a href="group___m_c_interface.html#ga6f963eae914e2d3b9016b3f417750fcf">More...</a><br /></td></tr>
<tr class="separator:ga6f963eae914e2d3b9016b3f417750fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a392f725376b9c09ef5eec6dce12558"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga7a392f725376b9c09ef5eec6dce12558">MCI_FaultAcknowledged</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga7a392f725376b9c09ef5eec6dce12558"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a user command used to indicate that the user has seen the error condition. If is possible, the command is executed instantaneously otherwise the command is discarded. User must take care of this possibility by checking the return value.  <a href="group___m_c_interface.html#ga7a392f725376b9c09ef5eec6dce12558">More...</a><br /></td></tr>
<tr class="separator:ga7a392f725376b9c09ef5eec6dce12558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63c760c5c7905a21faa1cfa9acb414d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gae63c760c5c7905a21faa1cfa9acb414d">MCI_FaultProcessing</a> (MCI_Handle_t *pHandle, uint16_t hSetErrors, uint16_t hResetErrors)</td></tr>
<tr class="memdesc:gae63c760c5c7905a21faa1cfa9acb414d"><td class="mdescLeft">&#160;</td><td class="mdescRight">It clocks both HW and SW faults processing and update the state machine accordingly with hSetErrors, hResetErrors and present state. Refer to State_t description for more information about fault states.  <a href="group___m_c_interface.html#gae63c760c5c7905a21faa1cfa9acb414d">More...</a><br /></td></tr>
<tr class="separator:gae63c760c5c7905a21faa1cfa9acb414d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f88751260207da7605e934f1086d09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga63f88751260207da7605e934f1086d09">MCI_ExecBufferedCommands</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga63f88751260207da7605e934f1086d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is usually a method managed by task. It must be called periodically in order to check the status of the related pSTM object and eventually to execute the buffered command if the condition occurs.  <a href="group___m_c_interface.html#ga63f88751260207da7605e934f1086d09">More...</a><br /></td></tr>
<tr class="separator:ga63f88751260207da7605e934f1086d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga270f7a86c8bd9da7dc263b5d55ca7de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga270f7a86c8bd9da7dc263b5d55ca7de0">MCI_IsCommandAcknowledged</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga270f7a86c8bd9da7dc263b5d55ca7de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the state of the last buffered command.  <a href="group___m_c_interface.html#ga270f7a86c8bd9da7dc263b5d55ca7de0">More...</a><br /></td></tr>
<tr class="separator:ga270f7a86c8bd9da7dc263b5d55ca7de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf0790ece81c2c29bddb5060ab0e5cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_interface.html#gaf9c63cc62b4961a5e4ae805cac0abf0c">MCI_State_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaaf0790ece81c2c29bddb5060ab0e5cdb">MCI_GetSTMState</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaaf0790ece81c2c29bddb5060ab0e5cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the state of the related pSTM object.  <a href="group___m_c_interface.html#gaaf0790ece81c2c29bddb5060ab0e5cdb">More...</a><br /></td></tr>
<tr class="separator:gaaf0790ece81c2c29bddb5060ab0e5cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181d97fe2b058f2c7c7d8bc15a237bac"><td class="memItemLeft" align="right" valign="top">PosCtrlStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga181d97fe2b058f2c7c7d8bc15a237bac">MCI_GetCtrlPositionState</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga181d97fe2b058f2c7c7d8bc15a237bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the state of the position control.  <a href="group___m_c_interface.html#ga181d97fe2b058f2c7c7d8bc15a237bac">More...</a><br /></td></tr>
<tr class="separator:ga181d97fe2b058f2c7c7d8bc15a237bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bf23abd19413ce92ff75a9d397de9e3"><td class="memItemLeft" align="right" valign="top">AlignStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga7bf23abd19413ce92ff75a9d397de9e3">MCI_GetAlignmentStatus</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga7bf23abd19413ce92ff75a9d397de9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the rotor alignment procedure.  <a href="group___m_c_interface.html#ga7bf23abd19413ce92ff75a9d397de9e3">More...</a><br /></td></tr>
<tr class="separator:ga7bf23abd19413ce92ff75a9d397de9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fede234d630c4d009a5ebc7dfce0fcb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga0fede234d630c4d009a5ebc7dfce0fcb">MCI_GetCurrentPosition</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga0fede234d630c4d009a5ebc7dfce0fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the current position of the rotor.  <a href="group___m_c_interface.html#ga0fede234d630c4d009a5ebc7dfce0fcb">More...</a><br /></td></tr>
<tr class="separator:ga0fede234d630c4d009a5ebc7dfce0fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c36b4534a5f443198f88e8069c0e0f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gad0c36b4534a5f443198f88e8069c0e0f">MCI_GetTargetPosition</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gad0c36b4534a5f443198f88e8069c0e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the final position asked to the motor.  <a href="group___m_c_interface.html#gad0c36b4534a5f443198f88e8069c0e0f">More...</a><br /></td></tr>
<tr class="separator:gad0c36b4534a5f443198f88e8069c0e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6548573a31cadd84d87450099bb0be1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gab6548573a31cadd84d87450099bb0be1">MCI_GetMoveDuration</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gab6548573a31cadd84d87450099bb0be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the total movement duration to reach the final position.  <a href="group___m_c_interface.html#gab6548573a31cadd84d87450099bb0be1">More...</a><br /></td></tr>
<tr class="separator:gab6548573a31cadd84d87450099bb0be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b5b555595ad7704c61f7eb6cf831c8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaf9b5b555595ad7704c61f7eb6cf831c8">MCI_GetOccurredFaults</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaf9b5b555595ad7704c61f7eb6cf831c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a 16 bit fields containing information about faults historically occurred since the state machine has been moved into FAULT_NOW state. <br  />
<a class="el" href="">Returned error codes are listed here </a>.  <a href="group___m_c_interface.html#gaf9b5b555595ad7704c61f7eb6cf831c8">More...</a><br /></td></tr>
<tr class="separator:gaf9b5b555595ad7704c61f7eb6cf831c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bdc250e3e00f5da65cdb84628f6105"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga92bdc250e3e00f5da65cdb84628f6105">MCI_GetCurrentFaults</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga92bdc250e3e00f5da65cdb84628f6105"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a 16 bit fields containing information about faults currently present. <br  />
<a class="el" href="">Returned error codes are listed here </a>.  <a href="group___m_c_interface.html#ga92bdc250e3e00f5da65cdb84628f6105">More...</a><br /></td></tr>
<tr class="separator:ga92bdc250e3e00f5da65cdb84628f6105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e95a73280381a6fb788a119816fcba"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga09e95a73280381a6fb788a119816fcba">MCI_GetFaultState</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga09e95a73280381a6fb788a119816fcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns two 16 bit fields containing information about both faults currently present and faults historically occurred since the state machine has been moved into state.  <a href="group___m_c_interface.html#ga09e95a73280381a6fb788a119816fcba">More...</a><br /></td></tr>
<tr class="separator:ga09e95a73280381a6fb788a119816fcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935749f2eeaf420fd2e8e45641d45845"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c___type.html#ga93791db1e1974fe42cab1e0a9c35e21e">MC_ControlMode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga935749f2eeaf420fd2e8e45641d45845">MCI_GetControlMode</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga935749f2eeaf420fd2e8e45641d45845"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the modality of the speed and torque controller.  <a href="group___m_c_interface.html#ga935749f2eeaf420fd2e8e45641d45845">More...</a><br /></td></tr>
<tr class="separator:ga935749f2eeaf420fd2e8e45641d45845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9886422959d033fed61981d8b5985e00"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga9886422959d033fed61981d8b5985e00">MCI_GetImposedMotorDirection</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga9886422959d033fed61981d8b5985e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the motor direction imposed by the last command (MCI_ExecSpeedRamp, MCI_ExecTorqueRamp or MCI_SetCurrentReferences).  <a href="group___m_c_interface.html#ga9886422959d033fed61981d8b5985e00">More...</a><br /></td></tr>
<tr class="separator:ga9886422959d033fed61981d8b5985e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dba057c41bc1e019941d9cfe9a54bd5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga6dba057c41bc1e019941d9cfe9a54bd5">MCI_GetLastRampFinalSpeed</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga6dba057c41bc1e019941d9cfe9a54bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the last ramp final speed sent by the user expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>.  <a href="group___m_c_interface.html#ga6dba057c41bc1e019941d9cfe9a54bd5">More...</a><br /></td></tr>
<tr class="separator:ga6dba057c41bc1e019941d9cfe9a54bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447b945f2d2df284a1140546e1de2926"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga447b945f2d2df284a1140546e1de2926">MCI_GetLastRampFinalTorque</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga447b945f2d2df284a1140546e1de2926"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the last ramp final torque sent by the user .This value represents actually the Iq current expressed in digit.  <a href="group___m_c_interface.html#ga447b945f2d2df284a1140546e1de2926">More...</a><br /></td></tr>
<tr class="separator:ga447b945f2d2df284a1140546e1de2926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898c0949556c7de262e96226a27a460b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga898c0949556c7de262e96226a27a460b">MCI_GetLastRampFinalDuration</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga898c0949556c7de262e96226a27a460b"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns information about the last ramp Duration sent by the user .  <a href="group___m_c_interface.html#ga898c0949556c7de262e96226a27a460b">More...</a><br /></td></tr>
<tr class="separator:ga898c0949556c7de262e96226a27a460b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga074bf76ebd1fb259b5c14b65da7b034c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga074bf76ebd1fb259b5c14b65da7b034c">MCI_GetLastRampFinalSpeed_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga074bf76ebd1fb259b5c14b65da7b034c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns last ramp final speed expressed in rpm.  <a href="group___m_c_interface.html#ga074bf76ebd1fb259b5c14b65da7b034c">More...</a><br /></td></tr>
<tr class="separator:ga074bf76ebd1fb259b5c14b65da7b034c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f7ba74a795eb1d19e761eceb0269545"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga1f7ba74a795eb1d19e761eceb0269545">MCI_RampCompleted</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga1f7ba74a795eb1d19e761eceb0269545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the settled speed or torque ramp has been completed.  <a href="group___m_c_interface.html#ga1f7ba74a795eb1d19e761eceb0269545">More...</a><br /></td></tr>
<tr class="separator:ga1f7ba74a795eb1d19e761eceb0269545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b7a23eacfd8e188e12ed2eb2011ddfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga8b7a23eacfd8e188e12ed2eb2011ddfd">MCI_StopSpeedRamp</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga8b7a23eacfd8e188e12ed2eb2011ddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the execution of speed ramp.  <a href="group___m_c_interface.html#ga8b7a23eacfd8e188e12ed2eb2011ddfd">More...</a><br /></td></tr>
<tr class="separator:ga8b7a23eacfd8e188e12ed2eb2011ddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cc1abd8dee123a6b77da7d9d6e16d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga98cc1abd8dee123a6b77da7d9d6e16d5">MCI_StopRamp</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga98cc1abd8dee123a6b77da7d9d6e16d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the execution of ongoing ramp.  <a href="group___m_c_interface.html#ga98cc1abd8dee123a6b77da7d9d6e16d5">More...</a><br /></td></tr>
<tr class="separator:ga98cc1abd8dee123a6b77da7d9d6e16d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a794dcdafd274d25bf7f05584a48c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga82a794dcdafd274d25bf7f05584a48c4">MCI_GetSpdSensorReliability</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga82a794dcdafd274d25bf7f05584a48c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns speed sensor reliability with reference to the sensor actually used for reference frame transformation.  <a href="group___m_c_interface.html#ga82a794dcdafd274d25bf7f05584a48c4">More...</a><br /></td></tr>
<tr class="separator:ga82a794dcdafd274d25bf7f05584a48c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab710f9661e807ac5a6761527c4391544"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gab710f9661e807ac5a6761527c4391544">MCI_GetAvrgMecSpeedUnit</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gab710f9661e807ac5a6761527c4391544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical speed, expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a> and related to the sensor actually used by FOC algorithm.  <a href="group___m_c_interface.html#gab710f9661e807ac5a6761527c4391544">More...</a><br /></td></tr>
<tr class="separator:gab710f9661e807ac5a6761527c4391544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e99e9c430199980dd226586cf3dca9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaf3e99e9c430199980dd226586cf3dca9">MCI_GetAvrgMecSpeed_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaf3e99e9c430199980dd226586cf3dca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical speed, expressed in rpm and related to the sensor actually used by FOC algorithm.  <a href="group___m_c_interface.html#gaf3e99e9c430199980dd226586cf3dca9">More...</a><br /></td></tr>
<tr class="separator:gaf3e99e9c430199980dd226586cf3dca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f95aea22785ac8c5bc2c86abf0efeb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gac2f95aea22785ac8c5bc2c86abf0efeb">MCI_GetMecSpeedRefUnit</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gac2f95aea22785ac8c5bc2c86abf0efeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mechanical rotor speed reference expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>.  <a href="group___m_c_interface.html#gac2f95aea22785ac8c5bc2c86abf0efeb">More...</a><br /></td></tr>
<tr class="separator:gac2f95aea22785ac8c5bc2c86abf0efeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f5e2d87cfc9de98f630bdf13532629a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga4f5e2d87cfc9de98f630bdf13532629a">MCI_GetMecSpeedRef_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga4f5e2d87cfc9de98f630bdf13532629a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mechanical rotor speed reference expressed in rpm.  <a href="group___m_c_interface.html#ga4f5e2d87cfc9de98f630bdf13532629a">More...</a><br /></td></tr>
<tr class="separator:ga4f5e2d87cfc9de98f630bdf13532629a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b7dc42e7f107903289624badb1bba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structab__t.html">ab_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga35b7dc42e7f107903289624badb1bba3">MCI_GetIab</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga35b7dc42e7f107903289624badb1bba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Iab in <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format.  <a href="group___m_c_interface.html#ga35b7dc42e7f107903289624badb1bba3">More...</a><br /></td></tr>
<tr class="separator:ga35b7dc42e7f107903289624badb1bba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b9e2359f164c3acaac0acbdd2d326e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalphabeta__t.html">alphabeta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga82b9e2359f164c3acaac0acbdd2d326e">MCI_GetIalphabeta</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga82b9e2359f164c3acaac0acbdd2d326e"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Ialphabeta in <a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a> format.  <a href="group___m_c_interface.html#ga82b9e2359f164c3acaac0acbdd2d326e">More...</a><br /></td></tr>
<tr class="separator:ga82b9e2359f164c3acaac0acbdd2d326e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37366425df4914d275b634d494ea73e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga37366425df4914d275b634d494ea73e6">MCI_GetIqd</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga37366425df4914d275b634d494ea73e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Iqd in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format.  <a href="group___m_c_interface.html#ga37366425df4914d275b634d494ea73e6">More...</a><br /></td></tr>
<tr class="separator:ga37366425df4914d275b634d494ea73e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad7b16f781148d636a632daf23e7192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__f__t.html">qd_f_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga3ad7b16f781148d636a632daf23e7192">MCI_GetIqd_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga3ad7b16f781148d636a632daf23e7192"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Iqd in float format.  <a href="group___m_c_interface.html#ga3ad7b16f781148d636a632daf23e7192">More...</a><br /></td></tr>
<tr class="separator:ga3ad7b16f781148d636a632daf23e7192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7343a99d44efa034e47d4da80a5a4b88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga7343a99d44efa034e47d4da80a5a4b88">MCI_GetIqdHF</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga7343a99d44efa034e47d4da80a5a4b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current IqdHF in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format.  <a href="group___m_c_interface.html#ga7343a99d44efa034e47d4da80a5a4b88">More...</a><br /></td></tr>
<tr class="separator:ga7343a99d44efa034e47d4da80a5a4b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf753a851af454331a28ca987ff102e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaadf753a851af454331a28ca987ff102e">MCI_GetIqdref</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaadf753a851af454331a28ca987ff102e"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Iqdref in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format.  <a href="group___m_c_interface.html#gaadf753a851af454331a28ca987ff102e">More...</a><br /></td></tr>
<tr class="separator:gaadf753a851af454331a28ca987ff102e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab44c7762ef38aeca587677b4ab18150c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__f__t.html">qd_f_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gab44c7762ef38aeca587677b4ab18150c">MCI_GetIqdref_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gab44c7762ef38aeca587677b4ab18150c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Iqdref in float format.  <a href="group___m_c_interface.html#gab44c7762ef38aeca587677b4ab18150c">More...</a><br /></td></tr>
<tr class="separator:gab44c7762ef38aeca587677b4ab18150c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca2bfbc6b48738362566561c5c95c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga8ca2bfbc6b48738362566561c5c95c53">MCI_GetVqd</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga8ca2bfbc6b48738362566561c5c95c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Vqd in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format.  <a href="group___m_c_interface.html#ga8ca2bfbc6b48738362566561c5c95c53">More...</a><br /></td></tr>
<tr class="separator:ga8ca2bfbc6b48738362566561c5c95c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5cf86931dd0ad217d3c4f61db97a173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalphabeta__t.html">alphabeta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gac5cf86931dd0ad217d3c4f61db97a173">MCI_GetValphabeta</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gac5cf86931dd0ad217d3c4f61db97a173"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns stator current Valphabeta in <a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a> format.  <a href="group___m_c_interface.html#gac5cf86931dd0ad217d3c4f61db97a173">More...</a><br /></td></tr>
<tr class="separator:gac5cf86931dd0ad217d3c4f61db97a173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b06d6e8bb35763b772053d562683b0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga40b06d6e8bb35763b772053d562683b0">MCI_GetElAngledpp</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga40b06d6e8bb35763b772053d562683b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the rotor electrical angle actually used for reference frame transformation.  <a href="group___m_c_interface.html#ga40b06d6e8bb35763b772053d562683b0">More...</a><br /></td></tr>
<tr class="separator:ga40b06d6e8bb35763b772053d562683b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf25e2edb6c1d3a10151aefe667ab7be7"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaf25e2edb6c1d3a10151aefe667ab7be7">MCI_GetTeref</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaf25e2edb6c1d3a10151aefe667ab7be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the reference electrical torque, fed to derived class for Iqref and Idref computation.  <a href="group___m_c_interface.html#gaf25e2edb6c1d3a10151aefe667ab7be7">More...</a><br /></td></tr>
<tr class="separator:gaf25e2edb6c1d3a10151aefe667ab7be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b153b3b81542f3064a0fbbb0222d2c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga62b153b3b81542f3064a0fbbb0222d2c">MCI_GetTeref_F</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga62b153b3b81542f3064a0fbbb0222d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the reference electrical torque.  <a href="group___m_c_interface.html#ga62b153b3b81542f3064a0fbbb0222d2c">More...</a><br /></td></tr>
<tr class="separator:ga62b153b3b81542f3064a0fbbb0222d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03dddcb5e831e3fe9c757b6361a2ba3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#gaa03dddcb5e831e3fe9c757b6361a2ba3">MCI_GetPhaseCurrentAmplitude</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:gaa03dddcb5e831e3fe9c757b6361a2ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the motor phase current amplitude (0-to-peak) in s16A To convert s16A into Ampere following formula must be used: Current(Amp) = [Current(s16A) * Vdd micro] / [65536 * Rshunt * Aop].  <a href="group___m_c_interface.html#gaa03dddcb5e831e3fe9c757b6361a2ba3">More...</a><br /></td></tr>
<tr class="separator:gaa03dddcb5e831e3fe9c757b6361a2ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6fb1fccbd5db7e843bd723ceecd72f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga4a6fb1fccbd5db7e843bd723ceecd72f">MCI_GetPhaseVoltageAmplitude</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga4a6fb1fccbd5db7e843bd723ceecd72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the applied motor phase voltage amplitude (0-to-peak) in s16V. To convert s16V into Volts following formula must be used: PhaseVoltage(V) = [PhaseVoltage(s16A) * Vbus(V)] /[sqrt(3) *32767].  <a href="group___m_c_interface.html#ga4a6fb1fccbd5db7e843bd723ceecd72f">More...</a><br /></td></tr>
<tr class="separator:ga4a6fb1fccbd5db7e843bd723ceecd72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cb1a3c43b9bad27bb32495d318e33bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga6cb1a3c43b9bad27bb32495d318e33bd">MCI_Clear_Iqdref</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga6cb1a3c43b9bad27bb32495d318e33bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">It re-initializes Iqdref variables with their default values.  <a href="group___m_c_interface.html#ga6cb1a3c43b9bad27bb32495d318e33bd">More...</a><br /></td></tr>
<tr class="separator:ga6cb1a3c43b9bad27bb32495d318e33bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a50cbb7839903d8d48256dc631242e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_interface.html#ga36a50cbb7839903d8d48256dc631242e">MCI_GetDutyCycleRef</a> (MCI_Handle_t *pHandle)</td></tr>
<tr class="memdesc:ga36a50cbb7839903d8d48256dc631242e"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns the reference eletrical torque, fed to derived class for Iqref and Idref computation.  <a href="group___m_c_interface.html#ga36a50cbb7839903d8d48256dc631242e">More...</a><br /></td></tr>
<tr class="separator:ga36a50cbb7839903d8d48256dc631242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This file provides firmware functions that implement the features of the MC Interface component of the Motor Control SDK: </p>
<dl class="section author"><dt>Author</dt><dd>Motor Control SDK Team, ST Microelectronics </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<h2><center>&copy; Copyright (c) 2022 STMicroelectronics. All rights reserved.</center></h2>
<p >This software component is licensed by ST under Ultimate Liberty license SLA0044, the "License"; You may not use this file except in compliance with the License. You may obtain a copy of the License at: www.st.com/SLA0044 </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
