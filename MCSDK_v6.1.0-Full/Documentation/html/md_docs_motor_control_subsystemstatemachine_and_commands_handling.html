<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: MC State Machine, Commands &amp; Faults</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">MC State Machine, Commands &amp; Faults </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>State Machine</h1>
<p >The operation of the Motor Control FOC library is driven by a state machine that is highlighted in the figure below:</p>
<div class="image">
<object type="image/svg+xml" data="state-machine.svg" style="pointer-events: none;"></object>
</div>
    <p >This state machine handles the motor start and motor stop procedures and management of faults detected by the library. The states are described by the following table.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>State</b>   </th><th class="markdownTableHeadNone"><b>Definition</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ICL WAIT</code>   </td><td class="markdownTableBodyNone">The system is waiting for the deactivation of the Inrush Current Limiter. It is not possible to run the motor if ICL is active. The system remains in this state until the ICL is deactivated. It then moves to the IDLE state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>IDLE</code>   </td><td class="markdownTableBodyNone">The motor is not under control but the system is ready to receive a <em>Motor Control Start</em> command or a <em>Measure Polarization Offsets</em> command.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>OFFSET MEASUREMENT</code>   </td><td class="markdownTableBodyNone">Sate in which the polarization offsets of the phase currents acquisition circuitry are measured. This state is reached after the reception of a <em>Motor Control Start</em> command if the offsets are not known to the system at that time. Otherwise it can be reached on the reception of a <em>Measure Polarization Offsets</em> command. In that case, the state machine goes back to IDLE when the measurements are done.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>CHARGE BOOT CAP</code>   </td><td class="markdownTableBodyNone">In this state, the gate driver boot capacitors are charged. The system remains in this state for a fixed and configurable period and then transitions to one of the ALIGNMENT, START or RUN states.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ALIGNMENT</code>   </td><td class="markdownTableBodyNone">This state only exists if a quadrature encoder is used for measuring the speed and the position of the rotor. In this state, the encoder sensors are properly aligned to set the mechanical angle of the rotor. When this alignment is done, the state machine goes to the WAIT STOP MOTOR state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>WAIT STOP MOTOR</code>   </td><td class="markdownTableBodyNone">The encoder attached to the motor has been aligned and may not be back to standing still yet. The system remains in this state for a fixed and configurable period of time after which the motor is considered still. Then, it transitions to the RUN state if either a quadrature encoder or a set of Hall sensors are used as the primary speed and position feedback method or to the START state otherwise. In that latter case, the encoder is only used as the "secondary" speed and position feedback method.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>START</code>   </td><td class="markdownTableBodyNone">The system is executing the motor start-up procedure. When the procedure completes, the state machine transitions to the SWITCH OVER state. This state only exists if a sensorless algorithm is used to estimate the position and the rotation speed of the rotor.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SWITCH OVER</code>   </td><td class="markdownTableBodyNone">In this state, the system transitions from the open loop mode of operation that is used during the motor start-up procedure to the closed loop mode in which the motor is under control. The system then goes to the RUN state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>RUN</code>   </td><td class="markdownTableBodyNone">The motor is under control. It will remain so until either a fault occurs or a <em>Motor Control Stop</em> command is received. In this last case, the system goes to the STOP state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>STOP</code>   </td><td class="markdownTableBodyNone">The control on the motor is released. This state is entered on reception of a <em>Motor Control Stop</em> command. The system remains in this state for a fixed and configurable period of time after which the motor is considered still. The system then goes to the IDLE or to the ICL WAIT state (if this feature is enabled).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>FAULT NOW</code>   </td><td class="markdownTableBodyNone">This state is entered from any other state on the occurrence of a fault. The system remains in this state as long as there is one active fault condition. The state machine moves to the FAULT OVER state when the last active fault condition disappear.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>FAULT OVER</code>   </td><td class="markdownTableBodyNone">The system enters this state when there is no active fault condition any more while at least one has been active. It remains in it until it receives an <em>Acknowledge Faults</em> command. It then goes back to either the IDLE or the ICL WAIT states.   </td></tr>
</table>
<p >See the documentation of the <a class="el" href="group___m_c_interface.html#gaf9c63cc62b4961a5e4ae805cac0abf0c">MCI_State_t</a> structure for additional details on the implementation of these states.</p>
<p >The state machine is executed by the <a class="el" href="mc__tasks_8c.html#ae66a3f6dc67830ff22319890739f87f9">Medium Frequency Task</a> of the Motor Control library.</p>
<p >In a typical application, all the states described here are not present. The state machine presented in the figure above is the taking all the situations managed by the MC SDK into account. However, an actual application does face all them. For instance, the <code>START</code> and <code>SWITCH OVER</code> states are not present in the sate machine of an application that does not use a <a class="el" href="md_docs_speed_pos_sensorless_bemf_reconstruction.html">sensorless method</a> for measuring the speed and position of the rotor. All the same, the <code>ALIGNMENT</code> and <code>WAIT STOP MOTOR</code> states are present only if a quadrature encoder is used. And also, The ICL WAIT state only exists if the Inrush Current Limiter feature is used...</p>
<p >The current state can be retrieved for each motor with a call to the <a class="el" href="group___m_c_i_a_p_i.html#ga4960f7bf643c9d5aff481df0cf9c0756">MC_GetSTMStateMotor*()</a> function.</p>
<h1>Command passing mechanism</h1>
<p >The motor control application is designed by the user. It uses the motor control library for actually controlling the motor. Both do not run on the same execution thread.</p>
<p >The state machine of the Motor Control library is run by the <a class="el" href="mc__tasks_8c.html#ae66a3f6dc67830ff22319890739f87f9">Medium Frequency Task</a> that is executed on the SysTick interrupt (except when FreeRTOS is used, see the <a class="el" href="md_docs_freertos.html">FreeRTOS documentation for MCSDK</a> for this special case). The application is unlikely to run on this same thread. It is rather expected to run in the STM32 User Mode (the <code>main()</code> function generated by the Workbench), although this is not mandatory. However, commanding the motor control library requires to take care about interthread communication.</p>
<p >The <a class="el" href="group___m_c_i_a_p_i.html">Motor Control API</a> provided by the MCSDK does this for the user. There is one constraint to respect though when using it: the functions it provides should not be called concurrently.</p>
<p >Using this API, the firmware provides two mechanisms to exchange commands between the application and the Medium Frequency Task:</p>
<ul>
<li>The direct commands mechanism</li>
<li>The buffered commands mechanism</li>
</ul>
<h2>Direct Commands</h2>
<p >Direct commands are called so because they are executed (almost) as soon as they are requested, whether they succeed or not. There are four Direct commands:</p>
<ul>
<li><em>Motor Control Start</em>. This command instructs the motor control library to set the target motor under control. It is triggered by the application with the <a class="el" href="group___m_c_i_a_p_i.html#ga42e5fb747722e38d753b3c5aa8cfa478">MC_StartMotor*()</a> function. This command can be executed only if the state machine is in the <code>IDLE</code> state.</li>
<li><em>Motor Control Stop</em>. This command instructs the motor control library to release the control over the target motor. It is triggered by the application with the <a class="el" href="group___m_c_i_a_p_i.html#gad2e6cff9f74f1c8c5dbb315050ff7f8e">MC_StopMotor*()</a> function. This command can be executed in any state except <code>IDLE</code>, <code>FAULT NOW</code> and <code>FAULT OVER</code>.</li>
<li><em>Measure Polarization Offsets</em>. This command instructs the motor control library to execute the Offsets polarization measurements procedure. It is triggered by the application with the <a class="el" href="group___m_c_i_a_p_i.html#gae65543b075f4a089c583c8d7f852837b">MC_StartPolarizationOffsetsMeasurementMotor*</a> function. This command can be executed only if the state machine is in the <code>IDLE</code> state.</li>
<li><em>Acknowledge Faults</em>. This command acknowledges the past faults detected by the motor control library. It is triggered by the <a class="el" href="group___m_c_i_a_p_i.html#gaee5ef9cd0d85a8998d1e635f6cbaf6f7">MC_AcknowledgeFaultMotor*()</a> function. This command only makes sense when the state machine is in the <code>FAULT OVER</code> state.</li>
</ul>
<p >Each of these functions first checks whether the state machine of the target motor allows for its execution. If this is not the case, the command fails and will not be executed. Otherwise, the command is scheduled for execution on the next Medium Frequency Task. If, at that time, the system is still in a compatible state, the command is started and the system switches to a suitable state.</p>
<h2>Buffered Commands</h2>
<p >A Buffered command is a command that may not be executed instantaneously: If the system is not in state allowing for its execution, it is stored in a buffer and will be executed when the state machine reaches a suitable state. Otherwise, it is executed on the next Medium Frequency Task.</p>
<p >The buffer used to store these commands can only store one command. If another command is filed before a preceding one has been executed, the preceding one is replaced in the buffer by the new one.</p>
<p >There are four Buffered commands. All execute in the RUN state:</p>
<ul>
<li><a class="el" href="group___m_c_i_a_p_i.html#gabb40bdb1abfc0d65aa272a44d09363c1">Program Speed Ramp</a>: requests the execution of a rotor speed ramp</li>
<li><a class="el" href="group___m_c_i_a_p_i.html#ga7b597ef87d57c31a0f2dd72e65528ad4">Program Torque Ramp</a>: requests the execution of a rotor speed ramp (FOC)</li>
<li><a class="el" href="group___m_c_i_a_p_i.html#gabea8166031d1b0b5d4d3fc23b0b53d06">Program Position</a>: requests the rotor to reach a given position (only available in a position control configuration).</li>
<li><a class="el" href="group___m_c_i_a_p_i.html#ga160d027fc6b06718292495937e95e6c1">Set Current Reference</a>: Sets the $I_q$ and $I_d$ motor current references (FOC).</li>
</ul>
<h1>Error reporting mechanism</h1>
<p >The motor control library detects a number of fault conditions that can occur to the motor control subsystem. When any such fault condition occurs, the state machine switches to the <code>FAULT NOW</code> state. When reaching this state, the motor is stopped and control over it is released. The state machine remains in this state as long as the fault condition is active. When the fault does not exist anymore, the state machine switches to the <code>FAULT OVER</code> state. Then, the application needs to acknowledge the faults by calling the <a class="el" href="group___m_c_i_a_p_i.html#gaee5ef9cd0d85a8998d1e635f6cbaf6f7">MC_AcknowledgeFaultMotor*()</a> function so that the state machine goes back to the <code>IDLE</code> state and the motor can be used again.</p>
<p >Several faults can be active at the same time. In this case, the state machine goes to <code>FAULT OVER</code> only when none of these faults is active anymore. If a new fault condition arises while the state machine is in the <code>FAULT OVER</code> state, it transitions back to the <code>FAULT NOW</code> state.</p>
<p >The list of active fault conditions can be retrieved with the <a class="el" href="group___m_c_i_a_p_i.html#ga638964d634142640e1e4c94895e743ed">MC_GetCurrentFaultsMotor()</a> function. That of past (but not acknowledged yet) fault can be retrieved with the <a class="el" href="group___m_c_i_a_p_i.html#gaccf1b164487fc23c152be6cd68657a9d">MC_GetOccurredFaultsMotor()</a> function. Both these functions return bitfield values, each bit set to one corresponding to a fault either active of past.</p>
<p >The following table lists fault conditions known to the motor control library along with their flag bitfield value. See <a class="el" href="group___m_c___type.html#fault_codes">Fault codes</a> for code details.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">#   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>0x00</code>   </td><td class="markdownTableBodyNone"><code>NO_FAULTS</code>   </td><td class="markdownTableBodyNone">No error    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>0x01</code>   </td><td class="markdownTableBodyNone"><code>DURATION</code>   </td><td class="markdownTableBodyNone">The high frequency task did not complete on time.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>0x02</code>   </td><td class="markdownTableBodyNone"><code>OVER_VOLT</code>   </td><td class="markdownTableBodyNone">$V_{BUS}$ voltage is or was measured above the over voltage threshold    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>0x04</code>   </td><td class="markdownTableBodyNone"><code>UNDER_VOLT</code>   </td><td class="markdownTableBodyNone">$V_{BUS}$ voltage is or was measured below the under voltage threshold    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>0x08</code>   </td><td class="markdownTableBodyNone"><code>OVER_TEMP</code>   </td><td class="markdownTableBodyNone">System temperature is or was measured above the over heating threshold    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>0x10</code>   </td><td class="markdownTableBodyNone"><code>START_UP</code>   </td><td class="markdownTableBodyNone">The sensorless startup phase failed . The motor could not be set under control in closed loop.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>0x20</code>   </td><td class="markdownTableBodyNone"><code>SPEED_FDBK</code>   </td><td class="markdownTableBodyNone">The rotor speed measurement or estimation was not reliable anymore    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>0x40</code>   </td><td class="markdownTableBodyNone"><code>BREAK_IN</code>   </td><td class="markdownTableBodyNone">Phase current is or was measured above the over current threshold    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>0x80</code>   </td><td class="markdownTableBodyNone"><code>SW_ERROR</code>   </td><td class="markdownTableBodyNone">An internal software error occurred.   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
