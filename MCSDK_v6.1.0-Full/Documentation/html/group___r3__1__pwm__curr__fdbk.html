<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: R3 1 ADC PWM &amp; Current Feedback</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">R3 1 ADC PWM &amp; Current Feedback<div class="ingroups"><a class="el" href="group___m_c_s_d_k.html">MCSDK</a> &raquo; <a class="el" href="group__pwm__curr__fdbk.html">PWM &amp; Current Feedback</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>3-Shunt, 1 ADC, PWM &amp; Current Feedback implementation for F0XX, F30X, F4XX, F7XX, G0XX and L4XX MCUs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r3__1___params__t.html">R3_1_Params_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current feedback component parameters structure definition for 1 ADC configuration. Common to every MCU except G4XX and H7XX.  <a href="struct_r3__1___params__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_w_m_c___r3__1___handle__t.html">PWMC_R3_1_Handle_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used to handle an instance of the PWM and current feedback component.  <a href="struct_p_w_m_c___r3__1___handle__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad9e9474b3352d0dfefb1a35b0f9fbe53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#gad9e9474b3352d0dfefb1a35b0f9fbe53">R3_1_Init</a> (<a class="el" href="struct_p_w_m_c___r3__1___handle__t.html">PWMC_R3_1_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gad9e9474b3352d0dfefb1a35b0f9fbe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes TIMx, ADC, GPIO, DMA1 and NVIC for current reading in three shunt topology using STM32F30X and two ADCs.  <a href="group___r3__1__pwm__curr__fdbk.html#gad9e9474b3352d0dfefb1a35b0f9fbe53">More...</a><br /></td></tr>
<tr class="separator:gad9e9474b3352d0dfefb1a35b0f9fbe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756d2303bba22e6eb1d3be573d991644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga756d2303bba22e6eb1d3be573d991644">R3_1_GetPhaseCurrents</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl, <a class="el" href="structab__t.html">ab_t</a> *Iab)</td></tr>
<tr class="memdesc:ga756d2303bba22e6eb1d3be573d991644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and stores in <code>pHdl</code> handler the latest converted motor phase currents in <code>Iab</code> <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format.  <a href="group___r3__1__pwm__curr__fdbk.html#ga756d2303bba22e6eb1d3be573d991644">More...</a><br /></td></tr>
<tr class="separator:ga756d2303bba22e6eb1d3be573d991644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e8b2ce4241993c836e562a8c68f7fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#gae3e8b2ce4241993c836e562a8c68f7fd">R3_1_GetPhaseCurrents_OVM</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl, <a class="el" href="structab__t.html">ab_t</a> *Iab)</td></tr>
<tr class="memdesc:gae3e8b2ce4241993c836e562a8c68f7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and stores in <code>pHdl</code> handler the latest converted motor phase currents in <code>Iab</code> <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format. Specific to overmodulation.  <a href="group___r3__1__pwm__curr__fdbk.html#gae3e8b2ce4241993c836e562a8c68f7fd">More...</a><br /></td></tr>
<tr class="separator:gae3e8b2ce4241993c836e562a8c68f7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab312475205ccbf9353a29a71672eac3f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#gab312475205ccbf9353a29a71672eac3f">R3_1_SetADCSampPointSectX</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:gab312475205ccbf9353a29a71672eac3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the ADC for the current sampling related to sector X (X = [1..6] ) in case of overmodulation.  <a href="group___r3__1__pwm__curr__fdbk.html#gab312475205ccbf9353a29a71672eac3f">More...</a><br /></td></tr>
<tr class="separator:gab312475205ccbf9353a29a71672eac3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8386d76c2f46b131ac9f4675b5d3fbe2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga8386d76c2f46b131ac9f4675b5d3fbe2">R3_1_SetADCSampPointSectX_OVM</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:ga8386d76c2f46b131ac9f4675b5d3fbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the ADC for the current sampling related to sector X (X = [1..6] ) in case of overmodulation.  <a href="group___r3__1__pwm__curr__fdbk.html#ga8386d76c2f46b131ac9f4675b5d3fbe2">More...</a><br /></td></tr>
<tr class="separator:ga8386d76c2f46b131ac9f4675b5d3fbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374903100a5ef58fbaaab222700268d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga374903100a5ef58fbaaab222700268d5">R3_1_TurnOnLowSides</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl, uint32_t ticks)</td></tr>
<tr class="memdesc:ga374903100a5ef58fbaaab222700268d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on low sides switches.  <a href="group___r3__1__pwm__curr__fdbk.html#ga374903100a5ef58fbaaab222700268d5">More...</a><br /></td></tr>
<tr class="separator:ga374903100a5ef58fbaaab222700268d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e86307ece7070698ff0ab05d7813386"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga6e86307ece7070698ff0ab05d7813386">R3_1_SwitchOnPWM</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:ga6e86307ece7070698ff0ab05d7813386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables PWM generation on the proper Timer peripheral.  <a href="group___r3__1__pwm__curr__fdbk.html#ga6e86307ece7070698ff0ab05d7813386">More...</a><br /></td></tr>
<tr class="separator:ga6e86307ece7070698ff0ab05d7813386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03fa09897906c4095f32bb459b5dc68c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga03fa09897906c4095f32bb459b5dc68c">R3_1_SwitchOffPWM</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:ga03fa09897906c4095f32bb459b5dc68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables PWM generation on the proper Timer peripheral acting on MOE bit.  <a href="group___r3__1__pwm__curr__fdbk.html#ga03fa09897906c4095f32bb459b5dc68c">More...</a><br /></td></tr>
<tr class="separator:ga03fa09897906c4095f32bb459b5dc68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d72fb3e87834728a82854e928f9184"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga86d72fb3e87834728a82854e928f9184">R3_1_IsOverCurrentOccurred</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:ga86d72fb3e87834728a82854e928f9184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an overcurrent occurred since last call.  <a href="group___r3__1__pwm__curr__fdbk.html#ga86d72fb3e87834728a82854e928f9184">More...</a><br /></td></tr>
<tr class="separator:ga86d72fb3e87834728a82854e928f9184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf97fedacc0d11497539ba8df452f01ce"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#gaf97fedacc0d11497539ba8df452f01ce">R3_1_TIMx_UP_IRQHandler</a> (<a class="el" href="struct_p_w_m_c___r3__1___handle__t.html">PWMC_R3_1_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gaf97fedacc0d11497539ba8df452f01ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the TIMx Update event interrupt.  <a href="group___r3__1__pwm__curr__fdbk.html#gaf97fedacc0d11497539ba8df452f01ce">More...</a><br /></td></tr>
<tr class="separator:gaf97fedacc0d11497539ba8df452f01ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9126aaa6075cafa395804f165fd4051d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga9126aaa6075cafa395804f165fd4051d">R3_1_SetOffsetCalib</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *offsets)</td></tr>
<tr class="memdesc:ga9126aaa6075cafa395804f165fd4051d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in <code>pHdl</code> handler the calibrated <code>offsets</code>.  <a href="group___r3__1__pwm__curr__fdbk.html#ga9126aaa6075cafa395804f165fd4051d">More...</a><br /></td></tr>
<tr class="separator:ga9126aaa6075cafa395804f165fd4051d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f499f6b12e14c863ecbecec1c79661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga76f499f6b12e14c863ecbecec1c79661">R3_1_GetOffsetCalib</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl, <a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *offsets)</td></tr>
<tr class="memdesc:ga76f499f6b12e14c863ecbecec1c79661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the calibrated <code>offsets</code> stored in <code>pHdl</code>.  <a href="group___r3__1__pwm__curr__fdbk.html#ga76f499f6b12e14c863ecbecec1c79661">More...</a><br /></td></tr>
<tr class="separator:ga76f499f6b12e14c863ecbecec1c79661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga244caca3bfb6e78d157cd5e180837cdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga244caca3bfb6e78d157cd5e180837cdd">R3_1_HFCurrentsCalibrationAB</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl, <a class="el" href="structab__t.html">ab_t</a> *pStator_Currents)</td></tr>
<tr class="memdesc:ga244caca3bfb6e78d157cd5e180837cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of PWMC_GetPhaseCurrents to be performed during calibration.  <a href="group___r3__1__pwm__curr__fdbk.html#ga244caca3bfb6e78d157cd5e180837cdd">More...</a><br /></td></tr>
<tr class="separator:ga244caca3bfb6e78d157cd5e180837cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga270d86fb46ee3d9c057971155edf4fdf"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga270d86fb46ee3d9c057971155edf4fdf">R3_1_WriteTIMRegisters</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl, uint16_t SamplingPoint)</td></tr>
<tr class="memdesc:ga270d86fb46ee3d9c057971155edf4fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes into peripheral registers the new duty cycle and sampling point.  <a href="group___r3__1__pwm__curr__fdbk.html#ga270d86fb46ee3d9c057971155edf4fdf">More...</a><br /></td></tr>
<tr class="separator:ga270d86fb46ee3d9c057971155edf4fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86388d34cee39fe63553c6f7a81e7975"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga86388d34cee39fe63553c6f7a81e7975">R3_1_BRK_IRQHandler</a> (<a class="el" href="struct_p_w_m_c___r3__1___handle__t.html">PWMC_R3_1_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga86388d34cee39fe63553c6f7a81e7975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the TIMx Break1 event interrupt.  <a href="group___r3__1__pwm__curr__fdbk.html#ga86388d34cee39fe63553c6f7a81e7975">More...</a><br /></td></tr>
<tr class="separator:ga86388d34cee39fe63553c6f7a81e7975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb045a5d3d545809a401f76f40e2198"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#gabdb045a5d3d545809a401f76f40e2198">R3_1_BRK2_IRQHandler</a> (<a class="el" href="struct_p_w_m_c___r3__1___handle__t.html">PWMC_R3_1_Handle_t</a> *pHandle)</td></tr>
<tr class="memdesc:gabdb045a5d3d545809a401f76f40e2198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the TIMx Break2 event interrupt.  <a href="group___r3__1__pwm__curr__fdbk.html#gabdb045a5d3d545809a401f76f40e2198">More...</a><br /></td></tr>
<tr class="separator:gabdb045a5d3d545809a401f76f40e2198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac35f1b4a6e3610ea4b48a20d36d7f75d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#gac35f1b4a6e3610ea4b48a20d36d7f75d">R3_1_RLDetectionModeEnable</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:gac35f1b4a6e3610ea4b48a20d36d7f75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PWM mode for R/L detection.  <a href="group___r3__1__pwm__curr__fdbk.html#gac35f1b4a6e3610ea4b48a20d36d7f75d">More...</a><br /></td></tr>
<tr class="separator:gac35f1b4a6e3610ea4b48a20d36d7f75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga684ef4a290c7535c9a8816cd93b93323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga684ef4a290c7535c9a8816cd93b93323">R3_1_RLDetectionModeDisable</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:ga684ef4a290c7535c9a8816cd93b93323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the PWM mode for R/L detection.  <a href="group___r3__1__pwm__curr__fdbk.html#ga684ef4a290c7535c9a8816cd93b93323">More...</a><br /></td></tr>
<tr class="separator:ga684ef4a290c7535c9a8816cd93b93323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2212b51a084c78aca2f2bff1a67c14b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#gaa2212b51a084c78aca2f2bff1a67c14b">R3_1_RLDetectionModeSetDuty</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl, uint16_t hDuty)</td></tr>
<tr class="memdesc:gaa2212b51a084c78aca2f2bff1a67c14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PWM dutycycle for R/L detection.  <a href="group___r3__1__pwm__curr__fdbk.html#gaa2212b51a084c78aca2f2bff1a67c14b">More...</a><br /></td></tr>
<tr class="separator:gaa2212b51a084c78aca2f2bff1a67c14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec469ef2ad9dcc694eb7aace0513da4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#gaec469ef2ad9dcc694eb7aace0513da4b">R3_1_RLGetPhaseCurrents</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl, <a class="el" href="structab__t.html">ab_t</a> *pStator_Currents)</td></tr>
<tr class="memdesc:gaec469ef2ad9dcc694eb7aace0513da4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and stores into <code>pHandle</code> latest converted motor phase currents during RL detection phase.  <a href="group___r3__1__pwm__curr__fdbk.html#gaec469ef2ad9dcc694eb7aace0513da4b">More...</a><br /></td></tr>
<tr class="separator:gaec469ef2ad9dcc694eb7aace0513da4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fdbc8672c43cd741a32a1334e28ac06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga9fdbc8672c43cd741a32a1334e28ac06">R3_1_RLTurnOnLowSides</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl, uint32_t ticks)</td></tr>
<tr class="memdesc:ga9fdbc8672c43cd741a32a1334e28ac06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on low sides switches.  <a href="group___r3__1__pwm__curr__fdbk.html#ga9fdbc8672c43cd741a32a1334e28ac06">More...</a><br /></td></tr>
<tr class="separator:ga9fdbc8672c43cd741a32a1334e28ac06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8a58e374f7b14eec79d881d9c148a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#gab8a58e374f7b14eec79d881d9c148a36">R3_1_RLSwitchOnPWM</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:gab8a58e374f7b14eec79d881d9c148a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables PWM generation on the proper Timer peripheral.  <a href="group___r3__1__pwm__curr__fdbk.html#gab8a58e374f7b14eec79d881d9c148a36">More...</a><br /></td></tr>
<tr class="separator:gab8a58e374f7b14eec79d881d9c148a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c3a09ec7fd5ae8a6a956f255207082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga71c3a09ec7fd5ae8a6a956f255207082">RLTurnOnLowSidesAndStart</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:ga71c3a09ec7fd5ae8a6a956f255207082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on low sides switches and start ADC triggering.  <a href="group___r3__1__pwm__curr__fdbk.html#ga71c3a09ec7fd5ae8a6a956f255207082">More...</a><br /></td></tr>
<tr class="separator:ga71c3a09ec7fd5ae8a6a956f255207082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb85af138e1a36a998c8be096368e13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#gadeb85af138e1a36a998c8be096368e13">R3_1_CurrentReadingPolarization</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:gadeb85af138e1a36a998c8be096368e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores into the <code>pHdl</code> the voltage present on Ia and Ib current feedback analog channels when no current is flowing into the motor.  <a href="group___r3__1__pwm__curr__fdbk.html#gadeb85af138e1a36a998c8be096368e13">More...</a><br /></td></tr>
<tr class="separator:gadeb85af138e1a36a998c8be096368e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17b31f3875ddb77934a07e0a90755e1a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r3__1__pwm__curr__fdbk.html#ga17b31f3875ddb77934a07e0a90755e1a">R3_1_SetADCSampPointPolarization</a> (<a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *pHdl)</td></tr>
<tr class="memdesc:ga17b31f3875ddb77934a07e0a90755e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the ADC for the current sampling during calibration.  <a href="group___r3__1__pwm__curr__fdbk.html#ga17b31f3875ddb77934a07e0a90755e1a">More...</a><br /></td></tr>
<tr class="separator:ga17b31f3875ddb77934a07e0a90755e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >3-Shunt, 1 ADC, PWM &amp; Current Feedback implementation for F0XX, F30X, F4XX, F7XX, G0XX and L4XX MCUs. </p>
<p >This component is used in applications based on F0XX, F30X, F4XX, F7XX, G0XX and L4XX MCUs, using a three shunt resistors current sensing topology and 1 ADC peripheral to acquire the current values. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabdb045a5d3d545809a401f76f40e2198" name="gabdb045a5d3d545809a401f76f40e2198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdb045a5d3d545809a401f76f40e2198">&#9670;&#160;</a></span>R3_1_BRK2_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * R3_1_BRK2_IRQHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_w_m_c___r3__1___handle__t.html">PWMC_R3_1_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains the TIMx Break2 event interrupt. </p>
<p >Specific to F0XX, F30X, G0XX and L4XX. Also called F0XX_BRK_IRQHandler or R3_1_OVERCURRENT_IRQHandler for G0XX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86388d34cee39fe63553c6f7a81e7975" name="ga86388d34cee39fe63553c6f7a81e7975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86388d34cee39fe63553c6f7a81e7975">&#9670;&#160;</a></span>R3_1_BRK_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void * R3_1_BRK_IRQHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_w_m_c___r3__1___handle__t.html">PWMC_R3_1_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains the TIMx Break1 event interrupt. </p>
<p >Specific to F30X, F4XX, F7XX, G0XX and L4XX. Also called R3_1_OVERVOLTAGE_IRQHandler for G0XX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadeb85af138e1a36a998c8be096368e13" name="gadeb85af138e1a36a998c8be096368e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeb85af138e1a36a998c8be096368e13">&#9670;&#160;</a></span>R3_1_CurrentReadingPolarization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void R3_1_CurrentReadingPolarization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores into the <code>pHdl</code> the voltage present on Ia and Ib current feedback analog channels when no current is flowing into the motor. </p>
<p >Called R3_1_CurrentReadingCalibration in every other MCU. </p>

</div>
</div>
<a id="ga76f499f6b12e14c863ecbecec1c79661" name="ga76f499f6b12e14c863ecbecec1c79661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76f499f6b12e14c863ecbecec1c79661">&#9670;&#160;</a></span>R3_1_GetOffsetCalib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void R3_1_GetOffsetCalib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the calibrated <code>offsets</code> stored in <code>pHdl</code>. </p>

</div>
</div>
<a id="ga756d2303bba22e6eb1d3be573d991644" name="ga756d2303bba22e6eb1d3be573d991644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756d2303bba22e6eb1d3be573d991644">&#9670;&#160;</a></span>R3_1_GetPhaseCurrents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void R3_1_GetPhaseCurrents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structab__t.html">ab_t</a> *&#160;</td>
          <td class="paramname"><em>Iab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and stores in <code>pHdl</code> handler the latest converted motor phase currents in <code>Iab</code> <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format. </p>

</div>
</div>
<a id="gae3e8b2ce4241993c836e562a8c68f7fd" name="gae3e8b2ce4241993c836e562a8c68f7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e8b2ce4241993c836e562a8c68f7fd">&#9670;&#160;</a></span>R3_1_GetPhaseCurrents_OVM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void R3_1_GetPhaseCurrents_OVM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structab__t.html">ab_t</a> *&#160;</td>
          <td class="paramname"><em>Iab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and stores in <code>pHdl</code> handler the latest converted motor phase currents in <code>Iab</code> <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format. Specific to overmodulation. </p>

</div>
</div>
<a id="ga244caca3bfb6e78d157cd5e180837cdd" name="ga244caca3bfb6e78d157cd5e180837cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga244caca3bfb6e78d157cd5e180837cdd">&#9670;&#160;</a></span>R3_1_HFCurrentsCalibrationAB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void R3_1_HFCurrentsCalibrationAB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structab__t.html">ab_t</a> *&#160;</td>
          <td class="paramname"><em>pStator_Currents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of PWMC_GetPhaseCurrents to be performed during calibration. </p>
<p >It sums up injected conversion data into PhaseAOffset and wPhaseBOffset to compute the offset introduced in the current feedback network. It is required to properly configure ADC inputs before in order to enable offset computation. Called R3_1_HFCurrentsPolarizationAB in F30X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Pointer on the target component instance. </td></tr>
    <tr><td class="paramname">pStator_Currents</td><td>Pointer to the structure that will receive motor current of phase A and B in <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9e9474b3352d0dfefb1a35b0f9fbe53" name="gad9e9474b3352d0dfefb1a35b0f9fbe53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9e9474b3352d0dfefb1a35b0f9fbe53">&#9670;&#160;</a></span>R3_1_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void R3_1_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_w_m_c___r3__1___handle__t.html">PWMC_R3_1_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes TIMx, ADC, GPIO, DMA1 and NVIC for current reading in three shunt topology using STM32F30X and two ADCs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86d72fb3e87834728a82854e928f9184" name="ga86d72fb3e87834728a82854e928f9184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d72fb3e87834728a82854e928f9184">&#9670;&#160;</a></span>R3_1_IsOverCurrentOccurred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t R3_1_IsOverCurrentOccurred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an overcurrent occurred since last call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>Returns <a class="el" href="group___m_c___type.html#ga1e85035b6829c4aa817cc7f9c6056a23" title="Error: Emergency input (Over current).">MC_BREAK_IN</a> if an overcurrent has been detected since last method call, <a class="el" href="group___m_c___type.html#ga6d39359a080c884fa7512bc2b444e43e" title="No error.">MC_NO_FAULTS</a> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga684ef4a290c7535c9a8816cd93b93323" name="ga684ef4a290c7535c9a8816cd93b93323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga684ef4a290c7535c9a8816cd93b93323">&#9670;&#160;</a></span>R3_1_RLDetectionModeDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void R3_1_RLDetectionModeDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the PWM mode for R/L detection. </p>
<p >Specific to F30X, F4XX and L4XX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac35f1b4a6e3610ea4b48a20d36d7f75d" name="gac35f1b4a6e3610ea4b48a20d36d7f75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac35f1b4a6e3610ea4b48a20d36d7f75d">&#9670;&#160;</a></span>R3_1_RLDetectionModeEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void R3_1_RLDetectionModeEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the PWM mode for R/L detection. </p>
<p >Specific to F30X, F4XX and L4XX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2212b51a084c78aca2f2bff1a67c14b" name="gaa2212b51a084c78aca2f2bff1a67c14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2212b51a084c78aca2f2bff1a67c14b">&#9670;&#160;</a></span>R3_1_RLDetectionModeSetDuty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t R3_1_RLDetectionModeSetDuty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDuty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the PWM dutycycle for R/L detection. </p>
<p >Specific to F30X, F4XX and L4XX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">hDuty</td><td>Duty cycle to apply, written in uint16_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>Returns <a class="el" href="group___m_c___type.html#ga53baebe4a3ba319ccc2beeebbcc4aefb" title="No error.">MC_NO_ERROR</a> if no error occurred or <a class="el" href="group___m_c___type.html#gae6e765beffae40be17d8676f836fadb2" title="Error: FOC rate to high.">MC_DURATION</a> if the duty cycles were set too late for being taken into account in the next PWM cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec469ef2ad9dcc694eb7aace0513da4b" name="gaec469ef2ad9dcc694eb7aace0513da4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec469ef2ad9dcc694eb7aace0513da4b">&#9670;&#160;</a></span>R3_1_RLGetPhaseCurrents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void R3_1_RLGetPhaseCurrents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structab__t.html">ab_t</a> *&#160;</td>
          <td class="paramname"><em>pStator_Currents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and stores into <code>pHandle</code> latest converted motor phase currents during RL detection phase. </p>
<p >Specific to F30X, F4XX and L4XX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">pStator_Currents</td><td>Pointer to the structure that will receive motor current of phase A and B in <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab8a58e374f7b14eec79d881d9c148a36" name="gab8a58e374f7b14eec79d881d9c148a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8a58e374f7b14eec79d881d9c148a36">&#9670;&#160;</a></span>R3_1_RLSwitchOnPWM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void R3_1_RLSwitchOnPWM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables PWM generation on the proper Timer peripheral. </p>
<p >This function is specific for RL detection phase. Specific to F30X, F4XX and L4XX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fdbc8672c43cd741a32a1334e28ac06" name="ga9fdbc8672c43cd741a32a1334e28ac06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fdbc8672c43cd741a32a1334e28ac06">&#9670;&#160;</a></span>R3_1_RLTurnOnLowSides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void R3_1_RLTurnOnLowSides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns on low sides switches. </p>
<p >This function is intended to be used for charging boot capacitors of driving section. It has to be called at each motor start-up when using high voltage drivers. This function is specific for RL detection phase. Specific to F30X, F4XX and L4XX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">ticks</td><td>Duty cycle of the boot capacitors charge, specific to motor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17b31f3875ddb77934a07e0a90755e1a" name="ga17b31f3875ddb77934a07e0a90755e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17b31f3875ddb77934a07e0a90755e1a">&#9670;&#160;</a></span>R3_1_SetADCSampPointPolarization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t R3_1_SetADCSampPointPolarization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the ADC for the current sampling during calibration. </p>
<p >It sets the ADC sequence length and channels, and the sampling point via TIMx_Ch4 value and polarity. It then calls the WriteTIMRegisters method. Called R3_1_SetADCSampPointCalibration in every other MCU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>Returns the return value of R3_1_WriteTIMRegisters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab312475205ccbf9353a29a71672eac3f" name="gab312475205ccbf9353a29a71672eac3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab312475205ccbf9353a29a71672eac3f">&#9670;&#160;</a></span>R3_1_SetADCSampPointSectX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t R3_1_SetADCSampPointSectX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the ADC for the current sampling related to sector X (X = [1..6] ) in case of overmodulation. </p>
<p >It sets the ADC sequence length and channels, and the sampling point via TIMx_Ch4 value and polarity. It then calls the WriteTIMRegisters method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>Returns the return value of R3_1_WriteTIMRegisters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8386d76c2f46b131ac9f4675b5d3fbe2" name="ga8386d76c2f46b131ac9f4675b5d3fbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8386d76c2f46b131ac9f4675b5d3fbe2">&#9670;&#160;</a></span>R3_1_SetADCSampPointSectX_OVM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t R3_1_SetADCSampPointSectX_OVM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the ADC for the current sampling related to sector X (X = [1..6] ) in case of overmodulation. </p>
<p >It sets the ADC sequence length and channels, and the sampling point via TIMx_Ch4 value and polarity. It then calls the WriteTIMRegisters method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>Returns the return value of R3_1_WriteTIMRegisters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9126aaa6075cafa395804f165fd4051d" name="ga9126aaa6075cafa395804f165fd4051d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9126aaa6075cafa395804f165fd4051d">&#9670;&#160;</a></span>R3_1_SetOffsetCalib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void R3_1_SetOffsetCalib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores in <code>pHdl</code> handler the calibrated <code>offsets</code>. </p>

</div>
</div>
<a id="ga03fa09897906c4095f32bb459b5dc68c" name="ga03fa09897906c4095f32bb459b5dc68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03fa09897906c4095f32bb459b5dc68c">&#9670;&#160;</a></span>R3_1_SwitchOffPWM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void R3_1_SwitchOffPWM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables PWM generation on the proper Timer peripheral acting on MOE bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e86307ece7070698ff0ab05d7813386" name="ga6e86307ece7070698ff0ab05d7813386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e86307ece7070698ff0ab05d7813386">&#9670;&#160;</a></span>R3_1_SwitchOnPWM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void R3_1_SwitchOnPWM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables PWM generation on the proper Timer peripheral. </p>
<p >This function is specific for RL detection phase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf97fedacc0d11497539ba8df452f01ce" name="gaf97fedacc0d11497539ba8df452f01ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf97fedacc0d11497539ba8df452f01ce">&#9670;&#160;</a></span>R3_1_TIMx_UP_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void * R3_1_TIMx_UP_IRQHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_w_m_c___r3__1___handle__t.html">PWMC_R3_1_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains the TIMx Update event interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga374903100a5ef58fbaaab222700268d5" name="ga374903100a5ef58fbaaab222700268d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga374903100a5ef58fbaaab222700268d5">&#9670;&#160;</a></span>R3_1_TurnOnLowSides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void R3_1_TurnOnLowSides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns on low sides switches. </p>
<p >This function is intended to be used for charging boot capacitors of driving section. It has to be called on each motor start-up when using high voltage drivers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">ticks</td><td>Timer ticks value to be applied Min value: 0 (low sides ON) Max value: PWM_PERIOD_CYCLES/2 (low sides OFF) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga270d86fb46ee3d9c057971155edf4fdf" name="ga270d86fb46ee3d9c057971155edf4fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga270d86fb46ee3d9c057971155edf4fdf">&#9670;&#160;</a></span>R3_1_WriteTIMRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint16_t R3_1_WriteTIMRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>SamplingPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes into peripheral registers the new duty cycle and sampling point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
    <tr><td class="paramname">SamplingPoint</td><td>Point at which the ADC will be triggered, written in timer clock counts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>Returns <a class="el" href="group___m_c___type.html#ga53baebe4a3ba319ccc2beeebbcc4aefb" title="No error.">MC_NO_ERROR</a> if no error occurred or <a class="el" href="group___m_c___type.html#gae6e765beffae40be17d8676f836fadb2" title="Error: FOC rate to high.">MC_DURATION</a> if the duty cycles were set too late for being taken into account in the next PWM cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga71c3a09ec7fd5ae8a6a956f255207082" name="ga71c3a09ec7fd5ae8a6a956f255207082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71c3a09ec7fd5ae8a6a956f255207082">&#9670;&#160;</a></span>RLTurnOnLowSidesAndStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RLTurnOnLowSidesAndStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pwm__curr__fdbk.html#ga5febe836591f0388113c624ad3e1a16a">PWMC_Handle_t</a> *&#160;</td>
          <td class="paramname"><em>pHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns on low sides switches and start ADC triggering. </p>
<p >This function is specific for MP phase. Specific to F30X, F4XX and L4XX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHdl</td><td>Handler of the current instance of the PWM component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
