<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: Hall sensor feedback processing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Hall sensor feedback processing </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Speed measurement implementation</h1>
<p >Thanks to the STM32 general-purpose timer (TIMx) features, it is very simple to interface the microcontroller with three Hall sensors. When the TI1S bit in the TIMx_CR2 register is set, the three signals on the TIMx_CH1, TIMx_CH2 and TIMx_CH3 pins are XORed and the resulting signal is connected to the TIMx input capture.</p>
<p >Thus, the speed measurement is converted into the period measurement of a square wave with a frequency six times higher than the real electrical frequency. The only exception is that the rolling direction, which is not extractable from the XORed signal, is performed by a direct access to the three Hall sensor outputs.</p>
<h2>Rolling direction identification</h2>
<p >As shown in the Figure below, it is possible to associate any of Hall sensor output combinations with a state whose number is obtainable by considering H3-H2-H1 as a three-digit binary number (H3 is the most significant bit).</p>
<div class="image">
<object type="image/svg+xml" data="hall_sensor_states.svg" style="pointer-events: none;"></object>
<div class="caption">
Hall sensors, output-state correspondence</div></div>
    <p >Consequently, it is possible to reconstruct the rolling direction of the rotor by comparing the present state with the previous one. In the presence of a positive speed, the sequence must be as illustrated in the Figure above.</p>
<h2>Period measurement</h2>
<p >Although the principle for measuring a period with a timer is quite simple, it is important to keep the best resolution, in particular for signals, such as the one under consideration, that can vary with a ratio easily reaching 1:1000.</p>
<p >In order to always have the best resolution, the timer clock prescaler is constantly adjusted in the current implementation.</p>
<p >The basic principle is to speed up the timer if the captured values are too low, and to slow it down when the timer overflows between two consecutive captures. This is illustrated with the figures below.</p>
<div class="image">
<object type="image/svg+xml" data="hall_timer_prescaler_decrease.svg" style="pointer-events: none;"></object>
<div class="caption">
Hall sensor timer interface prescaler decrease</div></div>
    <div class="image">
<object type="image/svg+xml" data="hall_timer_prescaler_increase.svg" style="pointer-events: none;"></object>
<div class="caption">
Hall sensor timer interface prescaler increase</div></div>
    <p >The prescaler modification is done in the capture interrupt, taking advantage of the buffered registers: the new prescaler value is taken into account only on the next capture event, by the hardware, without disturbing the measurement.</p>
<p >Further details are provided in the flowchart shown in the Figure below, which summarizes the actions taken into the <code>TIMx_IRQHandler</code>.</p>
<div class="image">
<object type="image/svg+xml" data="hall_timer_irq_flowchart.svg" style="pointer-events: none;"></object>
<div class="caption">
TIMx_IRQHandler flowchart</div></div>
    <h1>Electrical angle extrapolation implementation</h1>
<p >As shown in the figure bove, the speed measurement is not the only task performed in <code>TIMx_IRQHandler</code>. As well as the speed measurement, the high-to-low or low-to-high transition of the XORed signal also gives the possibility of synchronizing the software variable that contains the present electrical angle.</p>
<p >The synchronization is performed avoiding abrupt changes in the measured electrical angles. In order to do this, the difference between the expected electrical angle, computed from the last speed measurement, and the real electrical angle, coming from the Hall sensor signals (see ) is computed. The new speed measurement is adjusted with this information in order to compensate for the difference.</p>
<p >As can be seen in the Figurebelow, any Hall sensor transition gives very precise information about the rotor position.</p>
<div class="image">
<object type="image/svg+xml" data="hall_sensor_transitions.svg" style="pointer-events: none;"></object>
<div class="caption">
Hall sensor output transitions</div></div>
    <p >Furthermore, the utilisation of the FOC algorithm implies the need for a good and constant rotor position accuracy, including between two consecutive falling edges of the XORed signal (which occurs each 60 electrical degrees). For this reason, it is clearly necessary to interpolate rotor electrical angle information. For this purpose, the latest available speed measurement (see <a class="el" href="md_docs_measurement_units.html">Measurement units</a>) in dpp format (adjusted as described above) is added to the present electrical angle software variable value, any time the FOC algorithm is executed. See <a class="el" href="md_docs_measurement_units.html">Measurement units</a>.</p>
<h1>Setting up the system when using Hall-effect sensors</h1>
<p >Hall-effect sensors are devices capable of sensing the polarity of the rotor’s magnetic field. They provide a logic output, which is 0 or 1 depending on the magnetic pole they face and thus, on the rotor position.</p>
<p >Typically, in a three-phase PM motor, three Hall-effect sensors are used to feed back the rotor position information. They are usually mechanically displaced by either 120° or 60° and the presented firmware library was designed to support both possibilities.</p>
<p >As shown in the following figure, the typical waveforms can be visualized at the sensor outputs in case of 60° and 120° displaced Hall sensors. More particularly, this figure refers to an electrical period (that is, one mechanical revolution, in case of one pole pair motor).</p>
<div class="image">
<object type="image/svg+xml" data="hall_60_120_displacement.svg" style="pointer-events: none;"></object>
<div class="caption">
60° and 120° displaced Hall sensor output waveforms</div></div>
    <p ><b>Because the rotor position information they provide is absolute, there is no need for any</b> initial rotor prepositioning. Particular attention must be paid, however, when connecting the sensors to the proper microcontroller inputs.</p>
<p >This software library assumes that the positive rolling direction is the rolling direction of a machine that is fed with a three-phase system of positive sequence. In this case, to work correctly, the software library expects the Hall sensor signal transitions to be in the sequence shown in the figure above for both 60° and 120° displaced Hall sensors.</p>
<p >For these reasons, it is suggested to follow the instructions given below when connecting a Hall-sensor equipped PM motor to your board:</p>
<ol type="1">
<li>Turn the rotor by hand in the direction assumed to be positive and look at the B-emf induced on the three motor phases. If the real neutral point is not available, it can be reconstructed by means of three resistors, for instance.</li>
<li>Connect the motor phases to the hardware respecting the positive sequence. Let “phase A”, “phase B” and “phase C” be the motor phases driven by <code>TIM1_CH1</code>, <code>TIM1_CH2</code> and <code>TIM1_CH3</code>, respectively (for example, when using the MB459 board, a positive sequence of the motor phases could be connected to J5 2,1 and 3).</li>
<li>Turn the rotor by hand in the direction assumed to be positive, look at the three Hall sensor outputs (H1, H2 and H3) and connect them to the selected timer on channels 1, 2 and 3, respectively, making sure that the sequence shown in the figure above is respected.</li>
<li>Measure the delay in electrical degrees between the maximum of the B-emf induced on phase A and the first rising edge of signal H1.</li>
<li>Enter two parameters displacement and delay found in the ST MC Workbench GUI, inside the window related to motor speed and position sensor. An example with delay equal to 270° is illustrated in the following figure.</li>
</ol>
<div class="image">
<object type="image/svg+xml" data="hall_phase_shift_determination.svg" style="pointer-events: none;"></object>
<div class="caption">
Determination of Hall electrical phase shift</div></div>
    <p ><a class="el" href="md_docs_rotor_speed_pos_feedback_qenc.html">Next: Quadrature Encoder sensor speed &amp; position feedback processing</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
