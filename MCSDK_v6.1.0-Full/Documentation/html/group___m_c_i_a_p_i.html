<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: Motor Control API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Motor Control API<div class="ingroups"><a class="el" href="group___m_c_s_d_k.html">MCSDK</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>High level Programming Interface of the Motor Control SDK.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:mc__api_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mc__api_8h.html">mc_api.h</a></td></tr>
<tr class="memdesc:mc__api_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines the high level interface of the Motor Control SDK. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga42e5fb747722e38d753b3c5aa8cfa478"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga42e5fb747722e38d753b3c5aa8cfa478">MC_StartMotor1</a> (void)</td></tr>
<tr class="memdesc:ga42e5fb747722e38d753b3c5aa8cfa478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the start-up procedure for Motor 1.  <a href="group___m_c_i_a_p_i.html#ga42e5fb747722e38d753b3c5aa8cfa478">More...</a><br /></td></tr>
<tr class="separator:ga42e5fb747722e38d753b3c5aa8cfa478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2e6cff9f74f1c8c5dbb315050ff7f8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gad2e6cff9f74f1c8c5dbb315050ff7f8e">MC_StopMotor1</a> (void)</td></tr>
<tr class="memdesc:gad2e6cff9f74f1c8c5dbb315050ff7f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the stop procedure for Motor 1.  <a href="group___m_c_i_a_p_i.html#gad2e6cff9f74f1c8c5dbb315050ff7f8e">More...</a><br /></td></tr>
<tr class="separator:gad2e6cff9f74f1c8c5dbb315050ff7f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb40bdb1abfc0d65aa272a44d09363c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gabb40bdb1abfc0d65aa272a44d09363c1">MC_ProgramSpeedRampMotor1</a> (int16_t hFinalSpeed, uint16_t hDurationms)</td></tr>
<tr class="memdesc:gabb40bdb1abfc0d65aa272a44d09363c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs a speed ramp for Motor 1 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#gabb40bdb1abfc0d65aa272a44d09363c1">More...</a><br /></td></tr>
<tr class="separator:gabb40bdb1abfc0d65aa272a44d09363c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde6e90156b113f378821b578901b462"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gadde6e90156b113f378821b578901b462">MC_ProgramSpeedRampMotor1_F</a> (float FinalSpeed, uint16_t hDurationms)</td></tr>
<tr class="memdesc:gadde6e90156b113f378821b578901b462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs a speed ramp for Motor 1 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#gadde6e90156b113f378821b578901b462">More...</a><br /></td></tr>
<tr class="separator:gadde6e90156b113f378821b578901b462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b597ef87d57c31a0f2dd72e65528ad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga7b597ef87d57c31a0f2dd72e65528ad4">MC_ProgramTorqueRampMotor1</a> (int16_t hFinalTorque, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga7b597ef87d57c31a0f2dd72e65528ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs a torque ramp for Motor 1 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#ga7b597ef87d57c31a0f2dd72e65528ad4">More...</a><br /></td></tr>
<tr class="separator:ga7b597ef87d57c31a0f2dd72e65528ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c953c9501378078b3a5b4e8f71b266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gab7c953c9501378078b3a5b4e8f71b266">MC_ProgramTorqueRampMotor1_F</a> (float FinalTorque, uint16_t hDurationms)</td></tr>
<tr class="memdesc:gab7c953c9501378078b3a5b4e8f71b266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs a torque ramp for Motor 1 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#gab7c953c9501378078b3a5b4e8f71b266">More...</a><br /></td></tr>
<tr class="separator:gab7c953c9501378078b3a5b4e8f71b266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabea8166031d1b0b5d4d3fc23b0b53d06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gabea8166031d1b0b5d4d3fc23b0b53d06">MC_ProgramPositionCommandMotor1</a> (float fTargetPosition, float fDuration)</td></tr>
<tr class="memdesc:gabea8166031d1b0b5d4d3fc23b0b53d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs a position command for Motor 1 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#gabea8166031d1b0b5d4d3fc23b0b53d06">More...</a><br /></td></tr>
<tr class="separator:gabea8166031d1b0b5d4d3fc23b0b53d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160d027fc6b06718292495937e95e6c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga160d027fc6b06718292495937e95e6c1">MC_SetCurrentReferenceMotor1</a> (<a class="el" href="structqd__t.html">qd_t</a> Iqdref)</td></tr>
<tr class="memdesc:ga160d027fc6b06718292495937e95e6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs the current reference to Motor 1 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#ga160d027fc6b06718292495937e95e6c1">More...</a><br /></td></tr>
<tr class="separator:ga160d027fc6b06718292495937e95e6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c75f1af4071aa0cca3f698d35c2d26a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga4c75f1af4071aa0cca3f698d35c2d26a">MC_SetCurrentReferenceMotor1_F</a> (<a class="el" href="structqd__f__t.html">qd_f_t</a> IqdRef)</td></tr>
<tr class="memdesc:ga4c75f1af4071aa0cca3f698d35c2d26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs the current reference to Motor 1 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#ga4c75f1af4071aa0cca3f698d35c2d26a">More...</a><br /></td></tr>
<tr class="separator:ga4c75f1af4071aa0cca3f698d35c2d26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21dc1a07d794b7a13ac515bfd34ea383"><td class="memItemLeft" align="right" valign="top"><a id="ga21dc1a07d794b7a13ac515bfd34ea383" name="ga21dc1a07d794b7a13ac515bfd34ea383"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MCI_GetDutyCycleRefMotor1</b> (void)</td></tr>
<tr class="memdesc:ga21dc1a07d794b7a13ac515bfd34ea383"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the electrical torque reference for Motor 1 <br /></td></tr>
<tr class="separator:ga21dc1a07d794b7a13ac515bfd34ea383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff5c0d063001cb2e48e1bcfeb5e6c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gabff5c0d063001cb2e48e1bcfeb5e6c00">MC_GetCommandStateMotor1</a> (void)</td></tr>
<tr class="memdesc:gabff5c0d063001cb2e48e1bcfeb5e6c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of the last buffered command for Motor 1. The status can be one of the following values:  <a href="group___m_c_i_a_p_i.html#gabff5c0d063001cb2e48e1bcfeb5e6c00">More...</a><br /></td></tr>
<tr class="separator:gabff5c0d063001cb2e48e1bcfeb5e6c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bdf135d4e761f0afb9118966b5aa5d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga8bdf135d4e761f0afb9118966b5aa5d6">MC_StopSpeedRampMotor1</a> (void)</td></tr>
<tr class="memdesc:ga8bdf135d4e761f0afb9118966b5aa5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the execution of the on-going speed ramp for Motor 1, if any.  <a href="group___m_c_i_a_p_i.html#ga8bdf135d4e761f0afb9118966b5aa5d6">More...</a><br /></td></tr>
<tr class="separator:ga8bdf135d4e761f0afb9118966b5aa5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33cc4d83a5a038b41d03d9a73e8bab6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga33cc4d83a5a038b41d03d9a73e8bab6f">MC_StopRampMotor1</a> (void)</td></tr>
<tr class="memdesc:ga33cc4d83a5a038b41d03d9a73e8bab6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the execution of the on-going ramp for Motor 1, if any.  <a href="group___m_c_i_a_p_i.html#ga33cc4d83a5a038b41d03d9a73e8bab6f">More...</a><br /></td></tr>
<tr class="separator:ga33cc4d83a5a038b41d03d9a73e8bab6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada6da7e5ae1bcc9f22d23b51f2f0eca"><td class="memItemLeft" align="right" valign="top"><a id="gaada6da7e5ae1bcc9f22d23b51f2f0eca" name="gaada6da7e5ae1bcc9f22d23b51f2f0eca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MC_HasRampCompletedMotor1</b> (void)</td></tr>
<tr class="memdesc:gaada6da7e5ae1bcc9f22d23b51f2f0eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the last ramp submited for Motor 1 has completed, false otherwise. <br /></td></tr>
<tr class="separator:gaada6da7e5ae1bcc9f22d23b51f2f0eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2e1de204668c5929f04b09eb8f61bc"><td class="memItemLeft" align="right" valign="top"><a id="ga0b2e1de204668c5929f04b09eb8f61bc" name="ga0b2e1de204668c5929f04b09eb8f61bc"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetMecSpeedReferenceMotor1</b> (void)</td></tr>
<tr class="memdesc:ga0b2e1de204668c5929f04b09eb8f61bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mechanical rotor speed reference set for Motor 1, expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. <br /></td></tr>
<tr class="separator:ga0b2e1de204668c5929f04b09eb8f61bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa81a6e618cbd5039e0caca329771d272"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gaa81a6e618cbd5039e0caca329771d272">MC_GetMecSpeedAverageMotor1</a> (void)</td></tr>
<tr class="memdesc:gaa81a6e618cbd5039e0caca329771d272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mechanical rotor speed reference set for Motor 1, expressed in rpm.  <a href="group___m_c_i_a_p_i.html#gaa81a6e618cbd5039e0caca329771d272">More...</a><br /></td></tr>
<tr class="separator:gaa81a6e618cbd5039e0caca329771d272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7bf973e7cc5d4948593e45f4f877f46"><td class="memItemLeft" align="right" valign="top"><a id="gac7bf973e7cc5d4948593e45f4f877f46" name="gac7bf973e7cc5d4948593e45f4f877f46"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetMecAuxiliarySpeedAverageMotor1</b> (void)</td></tr>
<tr class="memdesc:gac7bf973e7cc5d4948593e45f4f877f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical rotor speed from auxiliary sensor for Motor 1, expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. <br /></td></tr>
<tr class="separator:gac7bf973e7cc5d4948593e45f4f877f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4a28b3068f3b30daec3907a4d3527e3"><td class="memItemLeft" align="right" valign="top"><a id="gaa4a28b3068f3b30daec3907a4d3527e3" name="gaa4a28b3068f3b30daec3907a4d3527e3"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetAuxiliaryElAngledppMotor1</b> (void)</td></tr>
<tr class="memdesc:gaa4a28b3068f3b30daec3907a4d3527e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the electrical angle of the rotor from auxiliary sensor of Motor 1, in DDP format. <br /></td></tr>
<tr class="separator:gaa4a28b3068f3b30daec3907a4d3527e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f34499b0647824ba6ad8caf2844efc6"><td class="memItemLeft" align="right" valign="top"><a id="ga1f34499b0647824ba6ad8caf2844efc6" name="ga1f34499b0647824ba6ad8caf2844efc6"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetAuxiliaryElAngleMotor1_F</b> (void)</td></tr>
<tr class="memdesc:ga1f34499b0647824ba6ad8caf2844efc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the electrical angle of the rotor from auxiliary sensor of Motor 1, expressed in radians. <br /></td></tr>
<tr class="separator:ga1f34499b0647824ba6ad8caf2844efc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346bec028d34435a5becba8146c5e3c4"><td class="memItemLeft" align="right" valign="top"><a id="ga346bec028d34435a5becba8146c5e3c4" name="ga346bec028d34435a5becba8146c5e3c4"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetMecAuxiliarySpeedAverageMotor2</b> (void)</td></tr>
<tr class="memdesc:ga346bec028d34435a5becba8146c5e3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical rotor speed from auxiliary sensor for Motor 2, expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. <br /></td></tr>
<tr class="separator:ga346bec028d34435a5becba8146c5e3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00da78979ee44610d4722f9fa9781a3"><td class="memItemLeft" align="right" valign="top"><a id="gaa00da78979ee44610d4722f9fa9781a3" name="gaa00da78979ee44610d4722f9fa9781a3"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetMecAuxiliarySpeedAverageMotor2_F</b> (void)</td></tr>
<tr class="memdesc:gaa00da78979ee44610d4722f9fa9781a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical rotor speed from auxiliary sensor for Motor 2, expressed in RPM. <br /></td></tr>
<tr class="separator:gaa00da78979ee44610d4722f9fa9781a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e2e5ee406b0f48516fc13ed88917e4"><td class="memItemLeft" align="right" valign="top"><a id="gae6e2e5ee406b0f48516fc13ed88917e4" name="gae6e2e5ee406b0f48516fc13ed88917e4"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetAuxiliaryElAngledppMotor2</b> (void)</td></tr>
<tr class="memdesc:gae6e2e5ee406b0f48516fc13ed88917e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the electrical angle of the rotor from auxiliary sensor of Motor 2, in DDP format. <br /></td></tr>
<tr class="separator:gae6e2e5ee406b0f48516fc13ed88917e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db47c7f8dfb77d844d29d7a440b19e8"><td class="memItemLeft" align="right" valign="top"><a id="ga9db47c7f8dfb77d844d29d7a440b19e8" name="ga9db47c7f8dfb77d844d29d7a440b19e8"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetAuxiliaryElAngleMotor2_F</b> (void)</td></tr>
<tr class="memdesc:ga9db47c7f8dfb77d844d29d7a440b19e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the electrical angle of the rotor from auxiliary sensor of Motor 2, expressed in radians. <br /></td></tr>
<tr class="separator:ga9db47c7f8dfb77d844d29d7a440b19e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab51f9d2fb7350b099a94e1ae2a0a5679"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gab51f9d2fb7350b099a94e1ae2a0a5679">MC_GetLastRampFinalSpeedMotor1</a> (void)</td></tr>
<tr class="memdesc:gab51f9d2fb7350b099a94e1ae2a0a5679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical rotor speed for Motor 1, expressed in rpm.  <a href="group___m_c_i_a_p_i.html#gab51f9d2fb7350b099a94e1ae2a0a5679">More...</a><br /></td></tr>
<tr class="separator:gab51f9d2fb7350b099a94e1ae2a0a5679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541a58858ab8da66ff617a735e6a2a23"><td class="memItemLeft" align="right" valign="top"><a id="ga541a58858ab8da66ff617a735e6a2a23" name="ga541a58858ab8da66ff617a735e6a2a23"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetLastRampFinalSpeedMotor1_F</b> (void)</td></tr>
<tr class="memdesc:ga541a58858ab8da66ff617a735e6a2a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the final speed of the last ramp programmed for Motor 1 if this ramp was a speed ramp, 0 otherwise. <br /></td></tr>
<tr class="separator:ga541a58858ab8da66ff617a735e6a2a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga085a7dc5c638012df6213194f056dc9d"><td class="memItemLeft" align="right" valign="top"><a id="ga085a7dc5c638012df6213194f056dc9d" name="ga085a7dc5c638012df6213194f056dc9d"></a>
<a class="el" href="group___m_c___type.html#ga93791db1e1974fe42cab1e0a9c35e21e">MC_ControlMode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetControlModeMotor1</b> (void)</td></tr>
<tr class="memdesc:ga085a7dc5c638012df6213194f056dc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Control Mode used for Motor 1 (either Speed or Torque) <br /></td></tr>
<tr class="separator:ga085a7dc5c638012df6213194f056dc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81255845ad783b18a5c8320364bddce5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga81255845ad783b18a5c8320364bddce5">MC_GetImposedDirectionMotor1</a> (void)</td></tr>
<tr class="memdesc:ga81255845ad783b18a5c8320364bddce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rotation direction imposed by the last command on Motor 1.  <a href="group___m_c_i_a_p_i.html#ga81255845ad783b18a5c8320364bddce5">More...</a><br /></td></tr>
<tr class="separator:ga81255845ad783b18a5c8320364bddce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb8ff46b9093a12296074ba366aa8da"><td class="memItemLeft" align="right" valign="top"><a id="gaacb8ff46b9093a12296074ba366aa8da" name="gaacb8ff46b9093a12296074ba366aa8da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetSpeedSensorReliabilityMotor1</b> (void)</td></tr>
<tr class="memdesc:gaacb8ff46b9093a12296074ba366aa8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the speed sensor used for Motor 1 is reliable, false otherwise. <br /></td></tr>
<tr class="separator:gaacb8ff46b9093a12296074ba366aa8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7c51bdba77128238e1c837645718f9a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gad7c51bdba77128238e1c837645718f9a">MC_GetPhaseCurrentAmplitudeMotor1</a> (void)</td></tr>
<tr class="memdesc:gad7c51bdba77128238e1c837645718f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the amplitude of the phase current injected in Motor 1  <a href="group___m_c_i_a_p_i.html#gad7c51bdba77128238e1c837645718f9a">More...</a><br /></td></tr>
<tr class="separator:gad7c51bdba77128238e1c837645718f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d97aa529a94937fca40fbf0d1bc7bd8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga0d97aa529a94937fca40fbf0d1bc7bd8">MC_GetPhaseVoltageAmplitudeMotor1</a> (void)</td></tr>
<tr class="memdesc:ga0d97aa529a94937fca40fbf0d1bc7bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the amplitude of the phase voltage applied to Motor 1  <a href="group___m_c_i_a_p_i.html#ga0d97aa529a94937fca40fbf0d1bc7bd8">More...</a><br /></td></tr>
<tr class="separator:ga0d97aa529a94937fca40fbf0d1bc7bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae17592fca0ad3cd5f66bfa744ae9a600"><td class="memItemLeft" align="right" valign="top"><a id="gae17592fca0ad3cd5f66bfa744ae9a600" name="gae17592fca0ad3cd5f66bfa744ae9a600"></a>
<a class="el" href="structab__t.html">ab_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIabMotor1</b> (void)</td></tr>
<tr class="memdesc:gae17592fca0ad3cd5f66bfa744ae9a600"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Ia and Ib current values for Motor 1 in <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format <br /></td></tr>
<tr class="separator:gae17592fca0ad3cd5f66bfa744ae9a600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb2a21dcaf933b08b3461324482c4238"><td class="memItemLeft" align="right" valign="top"><a id="gadb2a21dcaf933b08b3461324482c4238" name="gadb2a21dcaf933b08b3461324482c4238"></a>
<a class="el" href="structab__f__t.html">ab_f_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIabMotor1_F</b> (void)</td></tr>
<tr class="memdesc:gadb2a21dcaf933b08b3461324482c4238"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Ia and Ib current values for Motor 1 in <a class="el" href="structab__f__t.html" title="Two components a,b in float type.">ab_f_t</a> format <br /></td></tr>
<tr class="separator:gadb2a21dcaf933b08b3461324482c4238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeda853fb7a54b0227dc4993c74266aa5"><td class="memItemLeft" align="right" valign="top"><a id="gaeda853fb7a54b0227dc4993c74266aa5" name="gaeda853fb7a54b0227dc4993c74266aa5"></a>
<a class="el" href="structalphabeta__t.html">alphabeta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIalphabetaMotor1</b> (void)</td></tr>
<tr class="memdesc:gaeda853fb7a54b0227dc4993c74266aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Ialpha and Ibeta current values for Motor 1 in <a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a> format <br /></td></tr>
<tr class="separator:gaeda853fb7a54b0227dc4993c74266aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb0eea3ab89e70e68aa46471c99a13e"><td class="memItemLeft" align="right" valign="top"><a id="ga8eb0eea3ab89e70e68aa46471c99a13e" name="ga8eb0eea3ab89e70e68aa46471c99a13e"></a>
<a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIqdMotor1</b> (void)</td></tr>
<tr class="memdesc:ga8eb0eea3ab89e70e68aa46471c99a13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Iq and Id current values for Motor 1 in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format <br /></td></tr>
<tr class="separator:ga8eb0eea3ab89e70e68aa46471c99a13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db324db06ae1b58a03093bf6e5041eb"><td class="memItemLeft" align="right" valign="top"><a id="ga3db324db06ae1b58a03093bf6e5041eb" name="ga3db324db06ae1b58a03093bf6e5041eb"></a>
<a class="el" href="structqd__f__t.html">qd_f_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIqdMotor1_F</b> (void)</td></tr>
<tr class="memdesc:ga3db324db06ae1b58a03093bf6e5041eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Iq and Id current values for Motor 1 in float type <br /></td></tr>
<tr class="separator:ga3db324db06ae1b58a03093bf6e5041eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83649c19b5044bc43026cb0496558be7"><td class="memItemLeft" align="right" valign="top"><a id="ga83649c19b5044bc43026cb0496558be7" name="ga83649c19b5044bc43026cb0496558be7"></a>
<a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIqdrefMotor1</b> (void)</td></tr>
<tr class="memdesc:ga83649c19b5044bc43026cb0496558be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Iq and Id reference current values for Motor 1 in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format <br /></td></tr>
<tr class="separator:ga83649c19b5044bc43026cb0496558be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf07b8595eacbe79e3770c524a11493"><td class="memItemLeft" align="right" valign="top"><a id="gaadf07b8595eacbe79e3770c524a11493" name="gaadf07b8595eacbe79e3770c524a11493"></a>
<a class="el" href="structqd__f__t.html">qd_f_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIqdrefMotor1_F</b> (void)</td></tr>
<tr class="memdesc:gaadf07b8595eacbe79e3770c524a11493"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Iq and Id reference current values for Motor 1 in float type <br /></td></tr>
<tr class="separator:gaadf07b8595eacbe79e3770c524a11493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8389464758e8987915b14c9f0d6fef06"><td class="memItemLeft" align="right" valign="top"><a id="ga8389464758e8987915b14c9f0d6fef06" name="ga8389464758e8987915b14c9f0d6fef06"></a>
<a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetVqdMotor1</b> (void)</td></tr>
<tr class="memdesc:ga8389464758e8987915b14c9f0d6fef06"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Vq and Vd voltage values for Motor 1 in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format <br /></td></tr>
<tr class="separator:ga8389464758e8987915b14c9f0d6fef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e50f7c90b107cef33f650aaa28c2537"><td class="memItemLeft" align="right" valign="top"><a id="ga4e50f7c90b107cef33f650aaa28c2537" name="ga4e50f7c90b107cef33f650aaa28c2537"></a>
<a class="el" href="structalphabeta__t.html">alphabeta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetValphabetaMotor1</b> (void)</td></tr>
<tr class="memdesc:ga4e50f7c90b107cef33f650aaa28c2537"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Valpha and Vbeta voltage values for Motor 1 in <a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a> format <br /></td></tr>
<tr class="separator:ga4e50f7c90b107cef33f650aaa28c2537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08eeab345a77b7bf42647c4832b7afca"><td class="memItemLeft" align="right" valign="top"><a id="ga08eeab345a77b7bf42647c4832b7afca" name="ga08eeab345a77b7bf42647c4832b7afca"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetElAngledppMotor1</b> (void)</td></tr>
<tr class="memdesc:ga08eeab345a77b7bf42647c4832b7afca"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the electrical angle of the rotor of Motor 1, in DDP format <br /></td></tr>
<tr class="separator:ga08eeab345a77b7bf42647c4832b7afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf9297e93400b202c021a660527e6555"><td class="memItemLeft" align="right" valign="top"><a id="gaaf9297e93400b202c021a660527e6555" name="gaaf9297e93400b202c021a660527e6555"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetTerefMotor1</b> (void)</td></tr>
<tr class="memdesc:gaaf9297e93400b202c021a660527e6555"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the electrical torque reference for Motor 1 <br /></td></tr>
<tr class="separator:gaaf9297e93400b202c021a660527e6555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797aca2cc0ceaf21b5a9201146bdc4a2"><td class="memItemLeft" align="right" valign="top"><a id="ga797aca2cc0ceaf21b5a9201146bdc4a2" name="ga797aca2cc0ceaf21b5a9201146bdc4a2"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetTerefMotor1_F</b> (void)</td></tr>
<tr class="memdesc:ga797aca2cc0ceaf21b5a9201146bdc4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the electrical torque reference for Motor 1 <br /></td></tr>
<tr class="separator:ga797aca2cc0ceaf21b5a9201146bdc4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa585d3ebb0612f20e1b3b2a87cf4705d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gaa585d3ebb0612f20e1b3b2a87cf4705d">MC_Clear_IqdrefMotor1</a> (void)</td></tr>
<tr class="memdesc:gaa585d3ebb0612f20e1b3b2a87cf4705d"><td class="mdescLeft">&#160;</td><td class="mdescRight">re-initializes Iq and Id references to their default values for Motor 1  <a href="group___m_c_i_a_p_i.html#gaa585d3ebb0612f20e1b3b2a87cf4705d">More...</a><br /></td></tr>
<tr class="separator:gaa585d3ebb0612f20e1b3b2a87cf4705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdd9cbe06a5472bd6a164944bdf3fa7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga7fdd9cbe06a5472bd6a164944bdf3fa7">MC_SetPolarizationOffsetsMotor1</a> (<a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *PolarizationOffsets)</td></tr>
<tr class="memdesc:ga7fdd9cbe06a5472bd6a164944bdf3fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the polarization offset values to use for Motor 1.  <a href="group___m_c_i_a_p_i.html#ga7fdd9cbe06a5472bd6a164944bdf3fa7">More...</a><br /></td></tr>
<tr class="separator:ga7fdd9cbe06a5472bd6a164944bdf3fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d338d34aa4ab1d36b898e15ef674d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga50d338d34aa4ab1d36b898e15ef674d3">MC_GetPolarizationOffsetsMotor1</a> (<a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *PolarizationOffsets)</td></tr>
<tr class="memdesc:ga50d338d34aa4ab1d36b898e15ef674d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the polarization offset values measured or set for Motor 1.  <a href="group___m_c_i_a_p_i.html#ga50d338d34aa4ab1d36b898e15ef674d3">More...</a><br /></td></tr>
<tr class="separator:ga50d338d34aa4ab1d36b898e15ef674d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65543b075f4a089c583c8d7f852837b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gae65543b075f4a089c583c8d7f852837b">MC_StartPolarizationOffsetsMeasurementMotor1</a> (void)</td></tr>
<tr class="memdesc:gae65543b075f4a089c583c8d7f852837b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the polarization offsets measurement procedure.  <a href="group___m_c_i_a_p_i.html#gae65543b075f4a089c583c8d7f852837b">More...</a><br /></td></tr>
<tr class="separator:gae65543b075f4a089c583c8d7f852837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5ef9cd0d85a8998d1e635f6cbaf6f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gaee5ef9cd0d85a8998d1e635f6cbaf6f7">MC_AcknowledgeFaultMotor1</a> (void)</td></tr>
<tr class="memdesc:gaee5ef9cd0d85a8998d1e635f6cbaf6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge a Motor Control fault that occured on Motor 1.  <a href="group___m_c_i_a_p_i.html#gaee5ef9cd0d85a8998d1e635f6cbaf6f7">More...</a><br /></td></tr>
<tr class="separator:gaee5ef9cd0d85a8998d1e635f6cbaf6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccf1b164487fc23c152be6cd68657a9d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gaccf1b164487fc23c152be6cd68657a9d">MC_GetOccurredFaultsMotor1</a> (void)</td></tr>
<tr class="memdesc:gaccf1b164487fc23c152be6cd68657a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitfiled showing "new" faults that occured on Motor 1.  <a href="group___m_c_i_a_p_i.html#gaccf1b164487fc23c152be6cd68657a9d">More...</a><br /></td></tr>
<tr class="separator:gaccf1b164487fc23c152be6cd68657a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga638964d634142640e1e4c94895e743ed"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga638964d634142640e1e4c94895e743ed">MC_GetCurrentFaultsMotor1</a> (void)</td></tr>
<tr class="memdesc:ga638964d634142640e1e4c94895e743ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a bitfield showing all current faults on Motor 1  <a href="group___m_c_i_a_p_i.html#ga638964d634142640e1e4c94895e743ed">More...</a><br /></td></tr>
<tr class="separator:ga638964d634142640e1e4c94895e743ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4960f7bf643c9d5aff481df0cf9c0756"><td class="memItemLeft" align="right" valign="top"><a id="ga4960f7bf643c9d5aff481df0cf9c0756" name="ga4960f7bf643c9d5aff481df0cf9c0756"></a>
<a class="el" href="group___m_c_interface.html#gaf9c63cc62b4961a5e4ae805cac0abf0c">MCI_State_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetSTMStateMotor1</b> (void)</td></tr>
<tr class="memdesc:ga4960f7bf643c9d5aff481df0cf9c0756"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current state of Motor 1 state machine <br /></td></tr>
<tr class="separator:ga4960f7bf643c9d5aff481df0cf9c0756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga414ef578247f1bdc6580bcd82b7862d8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga414ef578247f1bdc6580bcd82b7862d8">MC_GetAveragePowerMotor1_F</a> (void)</td></tr>
<tr class="memdesc:ga414ef578247f1bdc6580bcd82b7862d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to get the average measured motor power expressed in watt for Motor 1.  <a href="group___m_c_i_a_p_i.html#ga414ef578247f1bdc6580bcd82b7862d8">More...</a><br /></td></tr>
<tr class="separator:ga414ef578247f1bdc6580bcd82b7862d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02bc4c4589901cd5f6ddb3bab7a2e2b2"><td class="memItemLeft" align="right" valign="top">PosCtrlStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga02bc4c4589901cd5f6ddb3bab7a2e2b2">MC_GetControlPositionStatusMotor1</a> (void)</td></tr>
<tr class="memdesc:ga02bc4c4589901cd5f6ddb3bab7a2e2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current control position state of Motor 1.  <a href="group___m_c_i_a_p_i.html#ga02bc4c4589901cd5f6ddb3bab7a2e2b2">More...</a><br /></td></tr>
<tr class="separator:ga02bc4c4589901cd5f6ddb3bab7a2e2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga623c1ad56239c38568babd07edf51a04"><td class="memItemLeft" align="right" valign="top">AlignStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga623c1ad56239c38568babd07edf51a04">MC_GetAlignmentStatusMotor1</a> (void)</td></tr>
<tr class="memdesc:ga623c1ad56239c38568babd07edf51a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the alignment state of Motor 1.  <a href="group___m_c_i_a_p_i.html#ga623c1ad56239c38568babd07edf51a04">More...</a><br /></td></tr>
<tr class="separator:ga623c1ad56239c38568babd07edf51a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae413bdde9c24d55a77c179517aa11064"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gae413bdde9c24d55a77c179517aa11064">MC_GetCurrentPosition1</a> (void)</td></tr>
<tr class="memdesc:gae413bdde9c24d55a77c179517aa11064"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current position of Motor 1.  <a href="group___m_c_i_a_p_i.html#gae413bdde9c24d55a77c179517aa11064">More...</a><br /></td></tr>
<tr class="separator:gae413bdde9c24d55a77c179517aa11064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4e549359099a2aa88e78b6608a52b87"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gac4e549359099a2aa88e78b6608a52b87">MC_GetTargetPosition1</a> (void)</td></tr>
<tr class="memdesc:gac4e549359099a2aa88e78b6608a52b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the target position of Motor 1.  <a href="group___m_c_i_a_p_i.html#gac4e549359099a2aa88e78b6608a52b87">More...</a><br /></td></tr>
<tr class="separator:gac4e549359099a2aa88e78b6608a52b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a90398d61f38c0714b81da3df32e433"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga4a90398d61f38c0714b81da3df32e433">MC_GetMoveDuration1</a> (void)</td></tr>
<tr class="memdesc:ga4a90398d61f38c0714b81da3df32e433"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the total movement duration to reach the target position of Motor 1.  <a href="group___m_c_i_a_p_i.html#ga4a90398d61f38c0714b81da3df32e433">More...</a><br /></td></tr>
<tr class="separator:ga4a90398d61f38c0714b81da3df32e433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc4d9e892723e5769184e165ec8496d4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gafc4d9e892723e5769184e165ec8496d4">MC_ProfilerCommand</a> (uint16_t rxLength, uint8_t *rxBuffer, int16_t txSyncFreeSpace, uint16_t *txLength, uint8_t *txBuffer)</td></tr>
<tr class="memdesc:gafc4d9e892723e5769184e165ec8496d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">call the correct profiler command. Interface is generic MCPV2 interface :  <a href="group___m_c_i_a_p_i.html#gafc4d9e892723e5769184e165ec8496d4">More...</a><br /></td></tr>
<tr class="separator:gafc4d9e892723e5769184e165ec8496d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e199ce97fe67cba8622e5a7b2521f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gab7e199ce97fe67cba8622e5a7b2521f5">MC_StartMotor2</a> (void)</td></tr>
<tr class="memdesc:gab7e199ce97fe67cba8622e5a7b2521f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the start-up procedure for Motor 2.  <a href="group___m_c_i_a_p_i.html#gab7e199ce97fe67cba8622e5a7b2521f5">More...</a><br /></td></tr>
<tr class="separator:gab7e199ce97fe67cba8622e5a7b2521f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa985abf29c62a7ca64b3eb68ea920d49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gaa985abf29c62a7ca64b3eb68ea920d49">MC_StopMotor2</a> (void)</td></tr>
<tr class="memdesc:gaa985abf29c62a7ca64b3eb68ea920d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the stop procedure for Motor 2.  <a href="group___m_c_i_a_p_i.html#gaa985abf29c62a7ca64b3eb68ea920d49">More...</a><br /></td></tr>
<tr class="separator:gaa985abf29c62a7ca64b3eb68ea920d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2afb28fa66f813cfaf3e4e5e827882d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga2afb28fa66f813cfaf3e4e5e827882d2">MC_ProgramSpeedRampMotor2</a> (int16_t hFinalSpeed, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga2afb28fa66f813cfaf3e4e5e827882d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs a speed ramp for Motor 2 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#ga2afb28fa66f813cfaf3e4e5e827882d2">More...</a><br /></td></tr>
<tr class="separator:ga2afb28fa66f813cfaf3e4e5e827882d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f0280fe2c9a76c706e023415765933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gaf6f0280fe2c9a76c706e023415765933">MC_ProgramSpeedRampMotor2_F</a> (float FinalSpeed, uint16_t hDurationms)</td></tr>
<tr class="memdesc:gaf6f0280fe2c9a76c706e023415765933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs a speed ramp for Motor 2 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#gaf6f0280fe2c9a76c706e023415765933">More...</a><br /></td></tr>
<tr class="separator:gaf6f0280fe2c9a76c706e023415765933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ffea985358843aa7c087ae7714a1f53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga3ffea985358843aa7c087ae7714a1f53">MC_ProgramTorqueRampMotor2</a> (int16_t hFinalTorque, uint16_t hDurationms)</td></tr>
<tr class="memdesc:ga3ffea985358843aa7c087ae7714a1f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs a torque ramp for Motor 2 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#ga3ffea985358843aa7c087ae7714a1f53">More...</a><br /></td></tr>
<tr class="separator:ga3ffea985358843aa7c087ae7714a1f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa734fa35ed0f523630b83ada65dce0c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gaa734fa35ed0f523630b83ada65dce0c1">MC_ProgramTorqueRampMotor2_F</a> (float FinalTorque, uint16_t hDurationms)</td></tr>
<tr class="memdesc:gaa734fa35ed0f523630b83ada65dce0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs a torque ramp for Motor 2 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#gaa734fa35ed0f523630b83ada65dce0c1">More...</a><br /></td></tr>
<tr class="separator:gaa734fa35ed0f523630b83ada65dce0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad8878f43ccfe53521d3f64a3325e92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga0ad8878f43ccfe53521d3f64a3325e92">MC_ProgramPositionCommandMotor2</a> (float fTargetPosition, float fDuration)</td></tr>
<tr class="memdesc:ga0ad8878f43ccfe53521d3f64a3325e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs a position command for Motor 2 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#ga0ad8878f43ccfe53521d3f64a3325e92">More...</a><br /></td></tr>
<tr class="separator:ga0ad8878f43ccfe53521d3f64a3325e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb4d4c377a50700e3498fda348c571c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gaedb4d4c377a50700e3498fda348c571c">MC_SetCurrentReferenceMotor2</a> (<a class="el" href="structqd__t.html">qd_t</a> Iqdref)</td></tr>
<tr class="memdesc:gaedb4d4c377a50700e3498fda348c571c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs the current reference to Motor 2 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#gaedb4d4c377a50700e3498fda348c571c">More...</a><br /></td></tr>
<tr class="separator:gaedb4d4c377a50700e3498fda348c571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga209ce8254d6a5cb3bfe9eddd22cb3298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga209ce8254d6a5cb3bfe9eddd22cb3298">MC_SetCurrentReferenceMotor2_F</a> (<a class="el" href="structqd__f__t.html">qd_f_t</a> IqdRef)</td></tr>
<tr class="memdesc:ga209ce8254d6a5cb3bfe9eddd22cb3298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs the current reference to Motor 2 for later or immediate execution.  <a href="group___m_c_i_a_p_i.html#ga209ce8254d6a5cb3bfe9eddd22cb3298">More...</a><br /></td></tr>
<tr class="separator:ga209ce8254d6a5cb3bfe9eddd22cb3298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf77d5671bfaace7e29f92171980f3050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gaf77d5671bfaace7e29f92171980f3050">MC_GetCommandStateMotor2</a> (void)</td></tr>
<tr class="memdesc:gaf77d5671bfaace7e29f92171980f3050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of the last buffered command for Motor 2. The status can be one of the following values:  <a href="group___m_c_i_a_p_i.html#gaf77d5671bfaace7e29f92171980f3050">More...</a><br /></td></tr>
<tr class="separator:gaf77d5671bfaace7e29f92171980f3050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe62db3a0a7a8afa28ae519b1ef97114"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gabe62db3a0a7a8afa28ae519b1ef97114">MC_StopSpeedRampMotor2</a> (void)</td></tr>
<tr class="memdesc:gabe62db3a0a7a8afa28ae519b1ef97114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the execution of the on-going speed ramp for Motor 2, if any.  <a href="group___m_c_i_a_p_i.html#gabe62db3a0a7a8afa28ae519b1ef97114">More...</a><br /></td></tr>
<tr class="separator:gabe62db3a0a7a8afa28ae519b1ef97114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e43508fcf9c8b3d2e908e1cf12c2d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga81e43508fcf9c8b3d2e908e1cf12c2d9">MC_StopRampMotor2</a> (void)</td></tr>
<tr class="memdesc:ga81e43508fcf9c8b3d2e908e1cf12c2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the execution of the on-going ramp for Motor 2, if any.  <a href="group___m_c_i_a_p_i.html#ga81e43508fcf9c8b3d2e908e1cf12c2d9">More...</a><br /></td></tr>
<tr class="separator:ga81e43508fcf9c8b3d2e908e1cf12c2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga621e0f87760bdcbd37a61de4648f2463"><td class="memItemLeft" align="right" valign="top"><a id="ga621e0f87760bdcbd37a61de4648f2463" name="ga621e0f87760bdcbd37a61de4648f2463"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MC_HasRampCompletedMotor2</b> (void)</td></tr>
<tr class="memdesc:ga621e0f87760bdcbd37a61de4648f2463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the last ramp submited for Motor 2 has completed, false otherwise. <br /></td></tr>
<tr class="separator:ga621e0f87760bdcbd37a61de4648f2463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa53879896f526997297e0e5cca9064c9"><td class="memItemLeft" align="right" valign="top"><a id="gaa53879896f526997297e0e5cca9064c9" name="gaa53879896f526997297e0e5cca9064c9"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetMecSpeedReferenceMotor2</b> (void)</td></tr>
<tr class="memdesc:gaa53879896f526997297e0e5cca9064c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mechanical rotor speed reference set for Motor 2, expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. <br /></td></tr>
<tr class="separator:gaa53879896f526997297e0e5cca9064c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga853e51bd2176d1a2be39f54758843b65"><td class="memItemLeft" align="right" valign="top"><a id="ga853e51bd2176d1a2be39f54758843b65" name="ga853e51bd2176d1a2be39f54758843b65"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetMecSpeedReferenceMotor2_F</b> (void)</td></tr>
<tr class="memdesc:ga853e51bd2176d1a2be39f54758843b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mechanical rotor speed reference set for Motor 2, expressed in rpm. <br /></td></tr>
<tr class="separator:ga853e51bd2176d1a2be39f54758843b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad63d03f85d6c0d689624b58256de7bb"><td class="memItemLeft" align="right" valign="top"><a id="gaad63d03f85d6c0d689624b58256de7bb" name="gaad63d03f85d6c0d689624b58256de7bb"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetMecSpeedAverageMotor2</b> (void)</td></tr>
<tr class="memdesc:gaad63d03f85d6c0d689624b58256de7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical rotor speed for Motor 2, expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. <br /></td></tr>
<tr class="separator:gaad63d03f85d6c0d689624b58256de7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65dfb228455b37553586caa59ca0885f"><td class="memItemLeft" align="right" valign="top"><a id="ga65dfb228455b37553586caa59ca0885f" name="ga65dfb228455b37553586caa59ca0885f"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetAverageMecSpeedMotor2_F</b> (void)</td></tr>
<tr class="memdesc:ga65dfb228455b37553586caa59ca0885f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical rotor speed for Motor 2, expressed in rpm. <br /></td></tr>
<tr class="separator:ga65dfb228455b37553586caa59ca0885f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0963eb3c9635f7ad3ef8957d26c243f8"><td class="memItemLeft" align="right" valign="top"><a id="ga0963eb3c9635f7ad3ef8957d26c243f8" name="ga0963eb3c9635f7ad3ef8957d26c243f8"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetLastRampFinalSpeedMotor2</b> (void)</td></tr>
<tr class="memdesc:ga0963eb3c9635f7ad3ef8957d26c243f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the final speed of the last ramp programmed for Motor 2 if this ramp was a speed ramp, 0 otherwise. <br /></td></tr>
<tr class="separator:ga0963eb3c9635f7ad3ef8957d26c243f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e27adee367769018e6a7acff4534e51"><td class="memItemLeft" align="right" valign="top"><a id="ga4e27adee367769018e6a7acff4534e51" name="ga4e27adee367769018e6a7acff4534e51"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetLastRampFinalSpeedMotor2_F</b> (void)</td></tr>
<tr class="memdesc:ga4e27adee367769018e6a7acff4534e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the final speed of the last ramp programmed for Motor 2 if this ramp was a speed ramp, 0 otherwise. <br /></td></tr>
<tr class="separator:ga4e27adee367769018e6a7acff4534e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ca406a17ed461517d8493b15376911"><td class="memItemLeft" align="right" valign="top"><a id="ga92ca406a17ed461517d8493b15376911" name="ga92ca406a17ed461517d8493b15376911"></a>
<a class="el" href="group___m_c___type.html#ga93791db1e1974fe42cab1e0a9c35e21e">MC_ControlMode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetControlModeMotor2</b> (void)</td></tr>
<tr class="memdesc:ga92ca406a17ed461517d8493b15376911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Control Mode used for Motor 2 (either Speed or Torque) <br /></td></tr>
<tr class="separator:ga92ca406a17ed461517d8493b15376911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a290400c01aee7e348358a0ea7a3eb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gab1a290400c01aee7e348358a0ea7a3eb">MC_GetImposedDirectionMotor2</a> (void)</td></tr>
<tr class="memdesc:gab1a290400c01aee7e348358a0ea7a3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rotation direction imposed by the last command on Motor 2.  <a href="group___m_c_i_a_p_i.html#gab1a290400c01aee7e348358a0ea7a3eb">More...</a><br /></td></tr>
<tr class="separator:gab1a290400c01aee7e348358a0ea7a3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9115aaf479611d8a49dba3c2e59be53c"><td class="memItemLeft" align="right" valign="top"><a id="ga9115aaf479611d8a49dba3c2e59be53c" name="ga9115aaf479611d8a49dba3c2e59be53c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetSpeedSensorReliabilityMotor2</b> (void)</td></tr>
<tr class="memdesc:ga9115aaf479611d8a49dba3c2e59be53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the speed sensor used for Motor 2 is reliable, false otherwise. <br /></td></tr>
<tr class="separator:ga9115aaf479611d8a49dba3c2e59be53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2939080df9cfd99803d5228275943997"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga2939080df9cfd99803d5228275943997">MC_GetPhaseCurrentAmplitudeMotor2</a> (void)</td></tr>
<tr class="memdesc:ga2939080df9cfd99803d5228275943997"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the amplitude of the phase current injected in Motor 2  <a href="group___m_c_i_a_p_i.html#ga2939080df9cfd99803d5228275943997">More...</a><br /></td></tr>
<tr class="separator:ga2939080df9cfd99803d5228275943997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501d6ca588489e64728ca92c4714bee0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga501d6ca588489e64728ca92c4714bee0">MC_GetPhaseVoltageAmplitudeMotor2</a> (void)</td></tr>
<tr class="memdesc:ga501d6ca588489e64728ca92c4714bee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the amplitude of the phase voltage applied to Motor 2  <a href="group___m_c_i_a_p_i.html#ga501d6ca588489e64728ca92c4714bee0">More...</a><br /></td></tr>
<tr class="separator:ga501d6ca588489e64728ca92c4714bee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb676fb3c6ca850e4499617d1ae1eb1d"><td class="memItemLeft" align="right" valign="top"><a id="gaeb676fb3c6ca850e4499617d1ae1eb1d" name="gaeb676fb3c6ca850e4499617d1ae1eb1d"></a>
<a class="el" href="structab__t.html">ab_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIabMotor2</b> (void)</td></tr>
<tr class="memdesc:gaeb676fb3c6ca850e4499617d1ae1eb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Ia and Ib current values for Motor 2 in <a class="el" href="structab__t.html" title="Two components a,b type definition.">ab_t</a> format <br /></td></tr>
<tr class="separator:gaeb676fb3c6ca850e4499617d1ae1eb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5dd87d8443d688e1077d56f22a2b4c"><td class="memItemLeft" align="right" valign="top"><a id="ga6a5dd87d8443d688e1077d56f22a2b4c" name="ga6a5dd87d8443d688e1077d56f22a2b4c"></a>
<a class="el" href="structalphabeta__t.html">alphabeta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIalphabetaMotor2</b> (void)</td></tr>
<tr class="memdesc:ga6a5dd87d8443d688e1077d56f22a2b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Ialpha and Ibeta current values for Motor 2 in <a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a> format <br /></td></tr>
<tr class="separator:ga6a5dd87d8443d688e1077d56f22a2b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab15fba42e12926383bf31df265e1b8ed"><td class="memItemLeft" align="right" valign="top"><a id="gab15fba42e12926383bf31df265e1b8ed" name="gab15fba42e12926383bf31df265e1b8ed"></a>
<a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIqdMotor2</b> (void)</td></tr>
<tr class="memdesc:gab15fba42e12926383bf31df265e1b8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Iq and Id current values for Motor 2 in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format <br /></td></tr>
<tr class="separator:gab15fba42e12926383bf31df265e1b8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3370fbff42dd1aaf18fb755da11a34b"><td class="memItemLeft" align="right" valign="top"><a id="gac3370fbff42dd1aaf18fb755da11a34b" name="gac3370fbff42dd1aaf18fb755da11a34b"></a>
<a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIqdrefMotor2</b> (void)</td></tr>
<tr class="memdesc:gac3370fbff42dd1aaf18fb755da11a34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Iq and Id reference current values for Motor 2 in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format <br /></td></tr>
<tr class="separator:gac3370fbff42dd1aaf18fb755da11a34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1163f4d8177e40d994f7d6f9b80580e5"><td class="memItemLeft" align="right" valign="top"><a id="ga1163f4d8177e40d994f7d6f9b80580e5" name="ga1163f4d8177e40d994f7d6f9b80580e5"></a>
<a class="el" href="structqd__t.html">qd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetVqdMotor2</b> (void)</td></tr>
<tr class="memdesc:ga1163f4d8177e40d994f7d6f9b80580e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Vq and Vd voltage values for Motor 2 in <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format <br /></td></tr>
<tr class="separator:ga1163f4d8177e40d994f7d6f9b80580e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e71083491985cb3ff79312029f706a"><td class="memItemLeft" align="right" valign="top"><a id="ga65e71083491985cb3ff79312029f706a" name="ga65e71083491985cb3ff79312029f706a"></a>
<a class="el" href="structalphabeta__t.html">alphabeta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetValphabetaMotor2</b> (void)</td></tr>
<tr class="memdesc:ga65e71083491985cb3ff79312029f706a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Valpha and Vbeta voltage values for Motor 2 in <a class="el" href="structalphabeta__t.html" title="Two components alpha, beta type definition.">alphabeta_t</a> format <br /></td></tr>
<tr class="separator:ga65e71083491985cb3ff79312029f706a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca2f9a4dc6064d0e5aef56b5a27d057"><td class="memItemLeft" align="right" valign="top"><a id="ga4ca2f9a4dc6064d0e5aef56b5a27d057" name="ga4ca2f9a4dc6064d0e5aef56b5a27d057"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetElAngledppMotor2</b> (void)</td></tr>
<tr class="memdesc:ga4ca2f9a4dc6064d0e5aef56b5a27d057"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the electrical angle of the rotor of Motor 2, in DDP format <br /></td></tr>
<tr class="separator:ga4ca2f9a4dc6064d0e5aef56b5a27d057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bd789a138e6480198d2eb5fc507aaa8"><td class="memItemLeft" align="right" valign="top"><a id="ga9bd789a138e6480198d2eb5fc507aaa8" name="ga9bd789a138e6480198d2eb5fc507aaa8"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetTerefMotor2</b> (void)</td></tr>
<tr class="memdesc:ga9bd789a138e6480198d2eb5fc507aaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the electrical torque reference for Motor 2 <br /></td></tr>
<tr class="separator:ga9bd789a138e6480198d2eb5fc507aaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26b36ef4072c5c3950db6516ff1c6d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga26b36ef4072c5c3950db6516ff1c6d89">MC_Clear_IqdrefMotor2</a> (void)</td></tr>
<tr class="memdesc:ga26b36ef4072c5c3950db6516ff1c6d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">re-initializes Iq and Id references to their default values for Motor 2  <a href="group___m_c_i_a_p_i.html#ga26b36ef4072c5c3950db6516ff1c6d89">More...</a><br /></td></tr>
<tr class="separator:ga26b36ef4072c5c3950db6516ff1c6d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4319ac254d4306ed42c05cd748f729"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga6c4319ac254d4306ed42c05cd748f729">MC_AcknowledgeFaultMotor2</a> (void)</td></tr>
<tr class="memdesc:ga6c4319ac254d4306ed42c05cd748f729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge a Motor Control fault that occured on Motor 2.  <a href="group___m_c_i_a_p_i.html#ga6c4319ac254d4306ed42c05cd748f729">More...</a><br /></td></tr>
<tr class="separator:ga6c4319ac254d4306ed42c05cd748f729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3468a84f53f9611c90de6219b3a5c4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga2c3468a84f53f9611c90de6219b3a5c4">MC_GetOccurredFaultsMotor2</a> (void)</td></tr>
<tr class="memdesc:ga2c3468a84f53f9611c90de6219b3a5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitfiled showing "new" faults that occured on Motor 2.  <a href="group___m_c_i_a_p_i.html#ga2c3468a84f53f9611c90de6219b3a5c4">More...</a><br /></td></tr>
<tr class="separator:ga2c3468a84f53f9611c90de6219b3a5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b79c1ef8084c47c7da26bc024327b29"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga6b79c1ef8084c47c7da26bc024327b29">MC_GetCurrentFaultsMotor2</a> (void)</td></tr>
<tr class="memdesc:ga6b79c1ef8084c47c7da26bc024327b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a bitfield showing all current faults on Motor 2  <a href="group___m_c_i_a_p_i.html#ga6b79c1ef8084c47c7da26bc024327b29">More...</a><br /></td></tr>
<tr class="separator:ga6b79c1ef8084c47c7da26bc024327b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7449fd926b607ad9cc4dcd5a88453c0"><td class="memItemLeft" align="right" valign="top"><a id="gae7449fd926b607ad9cc4dcd5a88453c0" name="gae7449fd926b607ad9cc4dcd5a88453c0"></a>
State_t&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetSTMStateMotor2</b> (void)</td></tr>
<tr class="memdesc:gae7449fd926b607ad9cc4dcd5a88453c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current state of Motor 2 state machine <br /></td></tr>
<tr class="separator:gae7449fd926b607ad9cc4dcd5a88453c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf677d7fb819876147617a86f2de01e09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gaf677d7fb819876147617a86f2de01e09">MC_SetPolarizationOffsetsMotor2</a> (<a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *PolarizationOffsets)</td></tr>
<tr class="memdesc:gaf677d7fb819876147617a86f2de01e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the polarization offset values to use for Motor 2.  <a href="group___m_c_i_a_p_i.html#gaf677d7fb819876147617a86f2de01e09">More...</a><br /></td></tr>
<tr class="separator:gaf677d7fb819876147617a86f2de01e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3917a644b567cc7345ed2172b34aaf99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga3917a644b567cc7345ed2172b34aaf99">MC_GetPolarizationOffsetsMotor2</a> (<a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *PolarizationOffsets)</td></tr>
<tr class="memdesc:ga3917a644b567cc7345ed2172b34aaf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the polarization offset values measured or set for Motor 2.  <a href="group___m_c_i_a_p_i.html#ga3917a644b567cc7345ed2172b34aaf99">More...</a><br /></td></tr>
<tr class="separator:ga3917a644b567cc7345ed2172b34aaf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad235bd8b3f93f0f0be64d5b70e5039de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gad235bd8b3f93f0f0be64d5b70e5039de">MC_StartPolarizationOffsetsMeasurementMotor2</a> (void)</td></tr>
<tr class="memdesc:gad235bd8b3f93f0f0be64d5b70e5039de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the polarization offsets measurement procedure for Motor 2.  <a href="group___m_c_i_a_p_i.html#gad235bd8b3f93f0f0be64d5b70e5039de">More...</a><br /></td></tr>
<tr class="separator:gad235bd8b3f93f0f0be64d5b70e5039de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14063c51d8ad5b25c76944222fe1e874"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga14063c51d8ad5b25c76944222fe1e874">MC_GetAveragePowerMotor2_F</a> (void)</td></tr>
<tr class="memdesc:ga14063c51d8ad5b25c76944222fe1e874"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to get the average measured motor power expressed in watt for Motor 2.  <a href="group___m_c_i_a_p_i.html#ga14063c51d8ad5b25c76944222fe1e874">More...</a><br /></td></tr>
<tr class="separator:ga14063c51d8ad5b25c76944222fe1e874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b2788b90bd9844e4224a17e8f59778"><td class="memItemLeft" align="right" valign="top">PosCtrlStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga83b2788b90bd9844e4224a17e8f59778">MC_GetControlPositionStatusMotor2</a> (void)</td></tr>
<tr class="memdesc:ga83b2788b90bd9844e4224a17e8f59778"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current control position state of Motor 2.  <a href="group___m_c_i_a_p_i.html#ga83b2788b90bd9844e4224a17e8f59778">More...</a><br /></td></tr>
<tr class="separator:ga83b2788b90bd9844e4224a17e8f59778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3424ad1652344114469ddefb31f0975"><td class="memItemLeft" align="right" valign="top">AlignStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gab3424ad1652344114469ddefb31f0975">MC_GetAlignmentStatusMotor2</a> (void)</td></tr>
<tr class="memdesc:gab3424ad1652344114469ddefb31f0975"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the alignment state of Motor 2.  <a href="group___m_c_i_a_p_i.html#gab3424ad1652344114469ddefb31f0975">More...</a><br /></td></tr>
<tr class="separator:gab3424ad1652344114469ddefb31f0975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d966590ce899672007581e2a7d96818"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga9d966590ce899672007581e2a7d96818">MC_GetCurrentPosition2</a> (void)</td></tr>
<tr class="memdesc:ga9d966590ce899672007581e2a7d96818"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current position of Motor 2.  <a href="group___m_c_i_a_p_i.html#ga9d966590ce899672007581e2a7d96818">More...</a><br /></td></tr>
<tr class="separator:ga9d966590ce899672007581e2a7d96818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae229ae16dd2252b3f82efafff5b41e15"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#gae229ae16dd2252b3f82efafff5b41e15">MC_GetTargetPosition2</a> (void)</td></tr>
<tr class="memdesc:gae229ae16dd2252b3f82efafff5b41e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the target position of Motor 2.  <a href="group___m_c_i_a_p_i.html#gae229ae16dd2252b3f82efafff5b41e15">More...</a><br /></td></tr>
<tr class="separator:gae229ae16dd2252b3f82efafff5b41e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b12cfaf851871f6ea2b66bf02402aa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_c_i_a_p_i.html#ga49b12cfaf851871f6ea2b66bf02402aa">MC_GetMoveDuration2</a> (void)</td></tr>
<tr class="memdesc:ga49b12cfaf851871f6ea2b66bf02402aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the total movement duration to reach the target position of Motor 2.  <a href="group___m_c_i_a_p_i.html#ga49b12cfaf851871f6ea2b66bf02402aa">More...</a><br /></td></tr>
<tr class="separator:ga49b12cfaf851871f6ea2b66bf02402aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45f77fce05256380eb99281dc02c689"><td class="memItemLeft" align="right" valign="top"><a id="gad45f77fce05256380eb99281dc02c689" name="gad45f77fce05256380eb99281dc02c689"></a>
__weak float&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetMecAuxiliarySpeedAverageMotor1_F</b> (void)</td></tr>
<tr class="memdesc:gad45f77fce05256380eb99281dc02c689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last computed average mechanical rotor speed from auxiliary sensor for Motor 1, expressed in RPM. <br /></td></tr>
<tr class="separator:gad45f77fce05256380eb99281dc02c689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeba87cbcd46a9e8ad302a6ee5948d05"><td class="memItemLeft" align="right" valign="top"><a id="gadeba87cbcd46a9e8ad302a6ee5948d05" name="gadeba87cbcd46a9e8ad302a6ee5948d05"></a>
__weak <a class="el" href="structqd__f__t.html">qd_f_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MC_GetIqdrefMotor2_F</b> (void)</td></tr>
<tr class="memdesc:gadeba87cbcd46a9e8ad302a6ee5948d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Iq and Id reference current values for Motor 2 in float type <br /></td></tr>
<tr class="separator:gadeba87cbcd46a9e8ad302a6ee5948d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >High level Programming Interface of the Motor Control SDK. </p>
<p >This interface allows for performing basic operations on the motor(s) driven by an Motor Control SDK based application. With it, motors can be started and stopped, speed or torque ramps can be programmed and executed and information on the state of the motors can be retrieved, among others.</p>
<p >This interface consists in functions that target a specific motor, indicated in their name. These functions aims at being the main interface used by an Application to control motors.</p>
<p >The current Motor Control API can cope with up to 2 motors. <br  />
 </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaee5ef9cd0d85a8998d1e635f6cbaf6f7" name="gaee5ef9cd0d85a8998d1e635f6cbaf6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee5ef9cd0d85a8998d1e635f6cbaf6f7">&#9670;&#160;</a></span>MC_AcknowledgeFaultMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MC_AcknowledgeFaultMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge a Motor Control fault that occured on Motor 1. </p>
<p >This function informs Motor 1's state machine that the Application has taken the error condition that occured into account. If no error condition exists when the function is called, nothing is done and false is returned. Otherwise, true is returned. </p>

</div>
</div>
<a id="ga6c4319ac254d4306ed42c05cd748f729" name="ga6c4319ac254d4306ed42c05cd748f729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c4319ac254d4306ed42c05cd748f729">&#9670;&#160;</a></span>MC_AcknowledgeFaultMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MC_AcknowledgeFaultMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge a Motor Control fault that occured on Motor 2. </p>
<p >This function informs Motor 2's state machine that the Application has taken the error condition that occured into account. If no error condition exists when the function is called, nothing is done and false is returned. Otherwise, true is returned. </p>

</div>
</div>
<a id="gaa585d3ebb0612f20e1b3b2a87cf4705d" name="gaa585d3ebb0612f20e1b3b2a87cf4705d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa585d3ebb0612f20e1b3b2a87cf4705d">&#9670;&#160;</a></span>MC_Clear_IqdrefMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_Clear_IqdrefMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>re-initializes Iq and Id references to their default values for Motor 1 </p>
<p >The default values for the Iq and Id references are coming from the Speed or the Torque controller depending on the control mode.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___speedn_torq_ctrl.html" title="Speed &amp; Torque Control component of the Motor Control SDK.">Speed &amp; Torque Control</a> for more details. </dd></dl>

</div>
</div>
<a id="ga26b36ef4072c5c3950db6516ff1c6d89" name="ga26b36ef4072c5c3950db6516ff1c6d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26b36ef4072c5c3950db6516ff1c6d89">&#9670;&#160;</a></span>MC_Clear_IqdrefMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_Clear_IqdrefMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>re-initializes Iq and Id references to their default values for Motor 2 </p>
<p >The default values for the Iq and Id references are comming from the Speed or the Torque controller depending on the control mode.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___speedn_torq_ctrl.html" title="Speed &amp; Torque Control component of the Motor Control SDK.">Speed &amp; Torque Control</a> for more details. </dd></dl>

</div>
</div>
<a id="ga623c1ad56239c38568babd07edf51a04" name="ga623c1ad56239c38568babd07edf51a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga623c1ad56239c38568babd07edf51a04">&#9670;&#160;</a></span>MC_GetAlignmentStatusMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak AlignStatus_t MC_GetAlignmentStatusMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the alignment state of Motor 1. </p>

</div>
</div>
<a id="gab3424ad1652344114469ddefb31f0975" name="gab3424ad1652344114469ddefb31f0975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3424ad1652344114469ddefb31f0975">&#9670;&#160;</a></span>MC_GetAlignmentStatusMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak AlignStatus_t MC_GetAlignmentStatusMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the alignment state of Motor 2. </p>

</div>
</div>
<a id="ga414ef578247f1bdc6580bcd82b7862d8" name="ga414ef578247f1bdc6580bcd82b7862d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga414ef578247f1bdc6580bcd82b7862d8">&#9670;&#160;</a></span>MC_GetAveragePowerMotor1_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MC_GetAveragePowerMotor1_F </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is used to get the average measured motor power expressed in watt for Motor 1. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td>The average measured motor power expressed in watt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14063c51d8ad5b25c76944222fe1e874" name="ga14063c51d8ad5b25c76944222fe1e874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14063c51d8ad5b25c76944222fe1e874">&#9670;&#160;</a></span>MC_GetAveragePowerMotor2_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MC_GetAveragePowerMotor2_F </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is used to get the average measured motor power expressed in watt for Motor 2. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td>The average measured motor power expressed in watt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabff5c0d063001cb2e48e1bcfeb5e6c00" name="gabff5c0d063001cb2e48e1bcfeb5e6c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabff5c0d063001cb2e48e1bcfeb5e6c00">&#9670;&#160;</a></span>MC_GetCommandStateMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a> MC_GetCommandStateMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of the last buffered command for Motor 1. The status can be one of the following values: </p>
<ul>
<li><a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1cad4d949d293c5da638085a77923be9150">MCI_BUFFER_EMPTY</a>: no buffered command is currently programmed.</li>
<li><a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1cae9f26ee1b08e2ff96d23761e60bb9497">MCI_COMMAND_NOT_ALREADY_EXECUTED</a>: A command has been buffered but the conditions for its execution have not occurred yet. The command is still in the buffer, pending execution.</li>
<li><a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1caa37592c9a61810de56769f10c13b5dc1">MCI_COMMAND_EXECUTED_SUCCESFULLY</a>: the last buffered command has been executed successfully. In this case calling this function reset the command state to #BC_BUFFER_EMPTY.</li>
<li><a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1cad75729ad0b4166e6a4311c44b8926ffd">MCI_COMMAND_EXECUTED_UNSUCCESFULLY</a>: the buffered command has been executed unsuccessfully. In this case calling this function reset the command state to #BC_BUFFER_EMPTY. </li>
</ul>

</div>
</div>
<a id="gaf77d5671bfaace7e29f92171980f3050" name="gaf77d5671bfaace7e29f92171980f3050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf77d5671bfaace7e29f92171980f3050">&#9670;&#160;</a></span>MC_GetCommandStateMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak <a class="el" href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a> MC_GetCommandStateMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of the last buffered command for Motor 2. The status can be one of the following values: </p>
<ul>
<li><a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1cad4d949d293c5da638085a77923be9150">MCI_BUFFER_EMPTY</a>: no buffered command is currently programmed.</li>
<li><a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1cae9f26ee1b08e2ff96d23761e60bb9497">MCI_COMMAND_NOT_ALREADY_EXECUTED</a>: A command has been buffered but the conditions for its execution have not occurred yet. The command is still in the buffer, pending execution.</li>
<li><a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1caa37592c9a61810de56769f10c13b5dc1">MCI_COMMAND_EXECUTED_SUCCESFULLY</a>: the last buffered command has been executed successfully. In this case calling this function reset the command state to #BC_BUFFER_EMPTY.</li>
<li><a class="el" href="group___m_c_interface.html#gga93b37db848f1e9e2f72923b7d6909f1cad75729ad0b4166e6a4311c44b8926ffd">MCI_COMMAND_EXECUTED_UNSUCCESFULLY</a>: the buffered command has been executed unsuccessfully. In this case calling this function reset the command state to #BC_BUFFER_EMPTY. </li>
</ul>

</div>
</div>
<a id="ga02bc4c4589901cd5f6ddb3bab7a2e2b2" name="ga02bc4c4589901cd5f6ddb3bab7a2e2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02bc4c4589901cd5f6ddb3bab7a2e2b2">&#9670;&#160;</a></span>MC_GetControlPositionStatusMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak PosCtrlStatus_t MC_GetControlPositionStatusMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current control position state of Motor 1. </p>

</div>
</div>
<a id="ga83b2788b90bd9844e4224a17e8f59778" name="ga83b2788b90bd9844e4224a17e8f59778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83b2788b90bd9844e4224a17e8f59778">&#9670;&#160;</a></span>MC_GetControlPositionStatusMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak PosCtrlStatus_t MC_GetControlPositionStatusMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current control position state of Motor 2. </p>

</div>
</div>
<a id="ga638964d634142640e1e4c94895e743ed" name="ga638964d634142640e1e4c94895e743ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga638964d634142640e1e4c94895e743ed">&#9670;&#160;</a></span>MC_GetCurrentFaultsMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t MC_GetCurrentFaultsMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a bitfield showing all current faults on Motor 1 </p>
<p >This function returns a 16 bit fields containing the Motor Control faults that are currently active.</p>
<p >See <a class="el" href="group___m_c___type.html#fault_codes">Motor Control Faults</a> for a list of of all possible faults codes. </p>

</div>
</div>
<a id="ga6b79c1ef8084c47c7da26bc024327b29" name="ga6b79c1ef8084c47c7da26bc024327b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b79c1ef8084c47c7da26bc024327b29">&#9670;&#160;</a></span>MC_GetCurrentFaultsMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t MC_GetCurrentFaultsMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a bitfield showing all current faults on Motor 2 </p>
<p >This function returns a 16 bit fields containing the Motor Control faults that are currently active.</p>
<p >See <a class="el" href="group___m_c___type.html#fault_codes">Motor Control Faults</a> for a list of of all possible faults codes. </p>

</div>
</div>
<a id="gae413bdde9c24d55a77c179517aa11064" name="gae413bdde9c24d55a77c179517aa11064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae413bdde9c24d55a77c179517aa11064">&#9670;&#160;</a></span>MC_GetCurrentPosition1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MC_GetCurrentPosition1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current position of Motor 1. </p>

</div>
</div>
<a id="ga9d966590ce899672007581e2a7d96818" name="ga9d966590ce899672007581e2a7d96818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d966590ce899672007581e2a7d96818">&#9670;&#160;</a></span>MC_GetCurrentPosition2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MC_GetCurrentPosition2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current position of Motor 2. </p>

</div>
</div>
<a id="ga81255845ad783b18a5c8320364bddce5" name="ga81255845ad783b18a5c8320364bddce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81255845ad783b18a5c8320364bddce5">&#9670;&#160;</a></span>MC_GetImposedDirectionMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MC_GetImposedDirectionMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rotation direction imposed by the last command on Motor 1. </p>
<p >The last command is either <a class="el" href="group___m_c_i_a_p_i.html#gabb40bdb1abfc0d65aa272a44d09363c1" title="Programs a speed ramp for Motor 1 for later or immediate execution.">MC_ProgramSpeedRampMotor1()</a>, <a class="el" href="group___m_c_i_a_p_i.html#ga7b597ef87d57c31a0f2dd72e65528ad4" title="Programs a torque ramp for Motor 1 for later or immediate execution.">MC_ProgramTorqueRampMotor1()</a> or <a class="el" href="group___m_c_i_a_p_i.html#ga160d027fc6b06718292495937e95e6c1" title="Programs the current reference to Motor 1 for later or immediate execution.">MC_SetCurrentReferenceMotor1()</a>.</p>
<p >The function returns -1 if the sign of the final speed, the final torque or the Iq current reference component of the last command is negative. Otherwise, 1 is returned.</p>
<dl class="section note"><dt>Note</dt><dd>if no such command has ever been submitted, 1 is returned as well. <br  />
 </dd></dl>

</div>
</div>
<a id="gab1a290400c01aee7e348358a0ea7a3eb" name="gab1a290400c01aee7e348358a0ea7a3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1a290400c01aee7e348358a0ea7a3eb">&#9670;&#160;</a></span>MC_GetImposedDirectionMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MC_GetImposedDirectionMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rotation direction imposed by the last command on Motor 2. </p>
<p >The last command is either <a class="el" href="group___m_c_i_a_p_i.html#gabb40bdb1abfc0d65aa272a44d09363c1" title="Programs a speed ramp for Motor 1 for later or immediate execution.">MC_ProgramSpeedRampMotor1()</a>, <a class="el" href="group___m_c_i_a_p_i.html#ga3ffea985358843aa7c087ae7714a1f53" title="Programs a torque ramp for Motor 2 for later or immediate execution.">MC_ProgramTorqueRampMotor2()</a> or <a class="el" href="group___m_c_i_a_p_i.html#gaedb4d4c377a50700e3498fda348c571c" title="Programs the current reference to Motor 2 for later or immediate execution.">MC_SetCurrentReferenceMotor2()</a>.</p>
<p >The function returns -1 if the sign of the final speed, the final torque or the Iq current reference component of the last command is negative. Otherwise, 1 is returned.</p>
<dl class="section note"><dt>Note</dt><dd>if no such command has ever been submitted, 1 is returned as well. <br  />
 </dd></dl>

</div>
</div>
<a id="gab51f9d2fb7350b099a94e1ae2a0a5679" name="gab51f9d2fb7350b099a94e1ae2a0a5679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab51f9d2fb7350b099a94e1ae2a0a5679">&#9670;&#160;</a></span>MC_GetLastRampFinalSpeedMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MC_GetLastRampFinalSpeedMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last computed average mechanical rotor speed for Motor 1, expressed in rpm. </p>
<p >Returns the final speed of the last ramp programmed for Motor 1 if this ramp was a speed ramp, 0 otherwise. </p>

</div>
</div>
<a id="gaa81a6e618cbd5039e0caca329771d272" name="gaa81a6e618cbd5039e0caca329771d272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa81a6e618cbd5039e0caca329771d272">&#9670;&#160;</a></span>MC_GetMecSpeedAverageMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MC_GetMecSpeedAverageMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current mechanical rotor speed reference set for Motor 1, expressed in rpm. </p>
<p >Returns the last computed average mechanical rotor speed for Motor 1, expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a> </p>

</div>
</div>
<a id="ga4a90398d61f38c0714b81da3df32e433" name="ga4a90398d61f38c0714b81da3df32e433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a90398d61f38c0714b81da3df32e433">&#9670;&#160;</a></span>MC_GetMoveDuration1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MC_GetMoveDuration1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the total movement duration to reach the target position of Motor 1. </p>

</div>
</div>
<a id="ga49b12cfaf851871f6ea2b66bf02402aa" name="ga49b12cfaf851871f6ea2b66bf02402aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49b12cfaf851871f6ea2b66bf02402aa">&#9670;&#160;</a></span>MC_GetMoveDuration2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MC_GetMoveDuration2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the total movement duration to reach the target position of Motor 2. </p>

</div>
</div>
<a id="gaccf1b164487fc23c152be6cd68657a9d" name="gaccf1b164487fc23c152be6cd68657a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccf1b164487fc23c152be6cd68657a9d">&#9670;&#160;</a></span>MC_GetOccurredFaultsMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t MC_GetOccurredFaultsMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a bitfiled showing "new" faults that occured on Motor 1. </p>
<p >This function returns a 16 bit fields containing the Motor Control faults that have occurred on Motor 1 since its state machine moved to the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca481894d1977cdfcf5820b30d0ab39355">FAULT_NOW</a> state.</p>
<p >See <a class="el" href="group___m_c___type.html#fault_codes">Motor Control Faults</a> for a list of of all possible faults codes. </p>

</div>
</div>
<a id="ga2c3468a84f53f9611c90de6219b3a5c4" name="ga2c3468a84f53f9611c90de6219b3a5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c3468a84f53f9611c90de6219b3a5c4">&#9670;&#160;</a></span>MC_GetOccurredFaultsMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint16_t MC_GetOccurredFaultsMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a bitfiled showing "new" faults that occured on Motor 2. </p>
<p >This function returns a 16 bit fields containing the Motor Control faults that have occurred on Motor 1 since its state machine moved to the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca481894d1977cdfcf5820b30d0ab39355">FAULT_NOW</a> state.</p>
<p >See <a class="el" href="group___m_c___type.html#fault_codes">Motor Control Faults</a> for a list of of all possible faults codes. </p>

</div>
</div>
<a id="gad7c51bdba77128238e1c837645718f9a" name="gad7c51bdba77128238e1c837645718f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7c51bdba77128238e1c837645718f9a">&#9670;&#160;</a></span>MC_GetPhaseCurrentAmplitudeMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MC_GetPhaseCurrentAmplitudeMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the amplitude of the phase current injected in Motor 1 </p>
<p >The returned amplitude (0-to-peak) is expressed in s16A unit. To convert it to amperes, use the following formula:</p>
<p class="formulaDsp">
\[
I_{Amps} = \frac{ I_{s16A} \times V_{dd}}{ 65536 \times R_{shunt} \times A_{op} }
\]
</p>
 
</div>
</div>
<a id="ga2939080df9cfd99803d5228275943997" name="ga2939080df9cfd99803d5228275943997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2939080df9cfd99803d5228275943997">&#9670;&#160;</a></span>MC_GetPhaseCurrentAmplitudeMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MC_GetPhaseCurrentAmplitudeMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the amplitude of the phase current injected in Motor 2 </p>
<p >The returned amplitude (0-to-peak) is expressed in s16A unit. To convert it to amperes, use the following formula:</p>
<p class="formulaDsp">
\[
I_{Amps} = \frac{ I_{s16A} \times V_{dd}}{ 65536 \times R_{shunt} \times A_{op} }
\]
</p>
 
</div>
</div>
<a id="ga0d97aa529a94937fca40fbf0d1bc7bd8" name="ga0d97aa529a94937fca40fbf0d1bc7bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d97aa529a94937fca40fbf0d1bc7bd8">&#9670;&#160;</a></span>MC_GetPhaseVoltageAmplitudeMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MC_GetPhaseVoltageAmplitudeMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the amplitude of the phase voltage applied to Motor 1 </p>
<p >The returned amplitude (0-to-peak) is expressed in s16V unit. To convert it to volts, use the following formula:</p>
<p class="formulaDsp">
\[
U_{Volts} = \frac{ U_{s16V} \times V_{bus}}{ \sqrt{3} \times 32768  }
\]
</p>
 
</div>
</div>
<a id="ga501d6ca588489e64728ca92c4714bee0" name="ga501d6ca588489e64728ca92c4714bee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga501d6ca588489e64728ca92c4714bee0">&#9670;&#160;</a></span>MC_GetPhaseVoltageAmplitudeMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak int16_t MC_GetPhaseVoltageAmplitudeMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the amplitude of the phase voltage applied to Motor 2 </p>
<p >The returned amplitude (0-to-peak) is expressed in s16V unit. To convert it to volts, use the following formula:</p>
<p class="formulaDsp">
\[
U_{Volts} = \frac{ U_{s16V} \times V_{bus}}{ \sqrt{3} \times 32768  }
\]
</p>
 
</div>
</div>
<a id="ga50d338d34aa4ab1d36b898e15ef674d3" name="ga50d338d34aa4ab1d36b898e15ef674d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50d338d34aa4ab1d36b898e15ef674d3">&#9670;&#160;</a></span>MC_GetPolarizationOffsetsMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MC_GetPolarizationOffsetsMotor1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *&#160;</td>
          <td class="paramname"><em>PolarizationOffsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the polarization offset values measured or set for Motor 1. </p>
<p >See <a class="el" href="group___m_c_i_a_p_i.html#ga7fdd9cbe06a5472bd6a164944bdf3fa7" title="Sets the polarization offset values to use for Motor 1.">MC_SetPolarizationOffsetsMotor1()</a> for more details.</p>
<p >If the Motor Control Firmware knows the polarization offset values, they are copied into the <code>PolarizationOffsets</code> structure and #MC_SUCCESS is returned. Otherwise, nothing is done and #MC_NO_POLARIZATION_OFFSETS_ERROR is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PolarizationOffsets</td><td>an pointer on the structure into which the polarization offsets will be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#MC_SUCCESS if calibration data were present and could be copied into <code>PolarizationOffsets</code>, #MC_NO_POLARIZATION_OFFSETS_ERROR otherwise. </dd></dl>

</div>
</div>
<a id="ga3917a644b567cc7345ed2172b34aaf99" name="ga3917a644b567cc7345ed2172b34aaf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3917a644b567cc7345ed2172b34aaf99">&#9670;&#160;</a></span>MC_GetPolarizationOffsetsMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MC_GetPolarizationOffsetsMotor2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *&#160;</td>
          <td class="paramname"><em>PolarizationOffsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the polarization offset values measured or set for Motor 2. </p>
<p >See <a class="el" href="group___m_c_i_a_p_i.html#gaf677d7fb819876147617a86f2de01e09" title="Sets the polarization offset values to use for Motor 2.">MC_SetPolarizationOffsetsMotor2()</a> for more details.</p>
<p >If the Motor Control Firmware knows the polarization offset values, they are copied into the <code>PolarizationOffsets</code> structure and #MC_SUCCESS is returned. Otherwise, nothing is done and #MC_NO_POLARIZATION_OFFSETS_ERROR is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PolarizationOffsets</td><td>an pointer on the structure into which the polarization offsets will be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#MC_SUCCESS if calibration data were present and could be copied into <code>PolarizationOffsets</code>, #MC_NO_POLARIZATION_OFFSETS_ERROR otherwise. </dd></dl>

</div>
</div>
<a id="gac4e549359099a2aa88e78b6608a52b87" name="gac4e549359099a2aa88e78b6608a52b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4e549359099a2aa88e78b6608a52b87">&#9670;&#160;</a></span>MC_GetTargetPosition1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MC_GetTargetPosition1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the target position of Motor 1. </p>

</div>
</div>
<a id="gae229ae16dd2252b3f82efafff5b41e15" name="gae229ae16dd2252b3f82efafff5b41e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae229ae16dd2252b3f82efafff5b41e15">&#9670;&#160;</a></span>MC_GetTargetPosition2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak float MC_GetTargetPosition2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the target position of Motor 2. </p>

</div>
</div>
<a id="gafc4d9e892723e5769184e165ec8496d4" name="gafc4d9e892723e5769184e165ec8496d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc4d9e892723e5769184e165ec8496d4">&#9670;&#160;</a></span>MC_ProfilerCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak uint8_t MC_ProfilerCommand </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>txSyncFreeSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>txLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>txBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call the correct profiler command. Interface is generic MCPV2 interface : </p>
<p >Not implemented MC_Profiler function.</p>
<ul>
<li>rxLength : length of data send in the payload command</li>
<li>rxBuffer : pointer to the actual payload command</li>
<li>txSyncFreeSpace : Total amount of space available for the answer</li>
<li>txLength : Amount of space actually used for the answer - Set in the command itself</li>
<li>txBuffer : Pointer to the buffer containing the answer <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">returns</td><td>MCP_CMD_OK or MCP_CMD_NOK if profiler is started correctly or not.</td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="gabea8166031d1b0b5d4d3fc23b0b53d06" name="gabea8166031d1b0b5d4d3fc23b0b53d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabea8166031d1b0b5d4d3fc23b0b53d06">&#9670;&#160;</a></span>MC_ProgramPositionCommandMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_ProgramPositionCommandMotor1 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fTargetPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fDuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs a position command for Motor 1 for later or immediate execution. </p>
<p >A position command allows to program a specific movement from current position to the <code>fTargetPosition</code> target mechanical angle reference in the given <code>fDuration</code> time.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#gabea8166031d1b0b5d4d3fc23b0b53d06" title="Programs a position command for Motor 1 for later or immediate execution.">MC_ProgramPositionCommandMotor1()</a> function programs a target position with the provided parameters. The programmed position is executed immediately if there is no movement ongoing.</p>
<p >The Application can check the status of the control with the <a class="el" href="group___m_c_i_a_p_i.html#ga02bc4c4589901cd5f6ddb3bab7a2e2b2" title="returns the current control position state of Motor 1.">MC_GetControlPositionStatusMotor1()</a> to know whether the motor is ready to execute a new command or not.</p>
<dl class="section note"><dt>Note</dt><dd>when the duration is set to 0, the input target position is immediately executed. By calling repeatedly the command with an update of input target angle, the control will be in follow mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fTargetPosition</td><td>Target mechanical angle reference at the end of the movement. This value represents the final position expressed in radian. </td></tr>
    <tr><td class="paramname">fDuration</td><td>Duration of the movement expressed in seconds. It is possible to set 0 to perform an instantaneous angular change (follow mode). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ad8878f43ccfe53521d3f64a3325e92" name="ga0ad8878f43ccfe53521d3f64a3325e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad8878f43ccfe53521d3f64a3325e92">&#9670;&#160;</a></span>MC_ProgramPositionCommandMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_ProgramPositionCommandMotor2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fTargetPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fDuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs a position command for Motor 2 for later or immediate execution. </p>
<p >A position command allows to program a specific movement from current position to the <code>fTargetPosition</code> target mechanical angle reference in the given <code>fDuration</code> time.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#ga0ad8878f43ccfe53521d3f64a3325e92" title="Programs a position command for Motor 2 for later or immediate execution.">MC_ProgramPositionCommandMotor2()</a> function programs a target position with the provided parameters. The programmed position is executed immediately if there is no movement ongoing.</p>
<p >The Application can check the status of the control with the <a class="el" href="group___m_c_i_a_p_i.html#ga83b2788b90bd9844e4224a17e8f59778" title="returns the current control position state of Motor 2.">MC_GetControlPositionStatusMotor2()</a> to know whether the motor is ready to execute a new command or not.</p>
<dl class="section note"><dt>Note</dt><dd>when the duration is set to 0, the input target position is immediately executed. By calling repeatedly the command with an update of input target angle, the control will be in follow mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fTargetPosition</td><td>Target mechanical angle reference at the end of the movement. This value represents the final position expressed in radiant. </td></tr>
    <tr><td class="paramname">fDuration</td><td>Duration of the movement expressed in seconds. It is possible to set 0 to perform an instantaneous angular change (follow mode). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb40bdb1abfc0d65aa272a44d09363c1" name="gabb40bdb1abfc0d65aa272a44d09363c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb40bdb1abfc0d65aa272a44d09363c1">&#9670;&#160;</a></span>MC_ProgramSpeedRampMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_ProgramSpeedRampMotor1 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>hFinalSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs a speed ramp for Motor 1 for later or immediate execution. </p>
<p >A speed ramp is a linear change from the current speed reference to the <code>hFinalSpeed</code> target speed in the given <code>hDurationms</code> time.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#gabb40bdb1abfc0d65aa272a44d09363c1" title="Programs a speed ramp for Motor 1 for later or immediate execution.">MC_ProgramSpeedRampMotor1()</a> function programs a new speed ramp with the provided parameters. The programmed ramp is executed immediately if Motor 1's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the ramp is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gabff5c0d063001cb2e48e1bcfeb5e6c00" title="Returns the status of the last buffered command for Motor 1. The status can be one of the following v...">MC_GetCommandStateMotor1()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another ramp - whether a speed or a torque one - or if another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="section note"><dt>Note</dt><dd>A ramp cannot reverse the rotation direction if the Application is using sensorless motor control techniques. If the sign of the hFinalSpeed parameter differs from that of the current speed, the ramp will not complete and a Speed Feedback error (<a class="el" href="group___m_c___type.html#gacec9c7bdd88ec978b0bf4db517830740" title="Error: Speed feedback.">MC_SPEED_FDBK</a>) will occur when the rotation speed is about to reach 0 rpm. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFinalSpeed</td><td>Mechanical rotor speed reference at the end of the ramp. Expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>Duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the speed value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadde6e90156b113f378821b578901b462" name="gadde6e90156b113f378821b578901b462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadde6e90156b113f378821b578901b462">&#9670;&#160;</a></span>MC_ProgramSpeedRampMotor1_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_ProgramSpeedRampMotor1_F </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>FinalSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs a speed ramp for Motor 1 for later or immediate execution. </p>
<p >A speed ramp is a linear change from the current speed reference to the <code>FinalSpeed</code> target speed in the given <code>hDurationms</code> time.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#gabb40bdb1abfc0d65aa272a44d09363c1" title="Programs a speed ramp for Motor 1 for later or immediate execution.">MC_ProgramSpeedRampMotor1()</a> function programs a new speed ramp with the provided parameters. The programmed ramp is executed immediately if Motor 1's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the ramp is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gabff5c0d063001cb2e48e1bcfeb5e6c00" title="Returns the status of the last buffered command for Motor 1. The status can be one of the following v...">MC_GetCommandStateMotor1()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another ramp - whether a speed or a torque one - or if another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="section note"><dt>Note</dt><dd>A ramp cannot reverse the rotation direction if the Application is using sensorless motor control techniques. If the sign of the hFinalSpeed parameter differs from that of the current speed, the ramp will not complete and a Speed Feedback error (<a class="el" href="group___m_c___type.html#gacec9c7bdd88ec978b0bf4db517830740" title="Error: Speed feedback.">MC_SPEED_FDBK</a>) will occur when the rotation speed is about to reach 0 rpm. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FinalSpeed</td><td>Mechanical rotor speed reference at the end of the ramp. Expressed in rpm. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>Duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the speed value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2afb28fa66f813cfaf3e4e5e827882d2" name="ga2afb28fa66f813cfaf3e4e5e827882d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2afb28fa66f813cfaf3e4e5e827882d2">&#9670;&#160;</a></span>MC_ProgramSpeedRampMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_ProgramSpeedRampMotor2 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>hFinalSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs a speed ramp for Motor 2 for later or immediate execution. </p>
<p >A speed ramp is a linear change from the current speed reference to the <code>hFinalSpeed</code> target speed in the given <code>hDurationms</code> time.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#ga2afb28fa66f813cfaf3e4e5e827882d2" title="Programs a speed ramp for Motor 2 for later or immediate execution.">MC_ProgramSpeedRampMotor2()</a> function programs a new speed ramp with the provided parameters. The programmed ramp is executed immediately if Motor 2's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the ramp is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gaf77d5671bfaace7e29f92171980f3050" title="Returns the status of the last buffered command for Motor 2. The status can be one of the following v...">MC_GetCommandStateMotor2()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another ramp - whether a speed or a torque one - or if another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="section note"><dt>Note</dt><dd>A ramp cannot reverse the rotation direction if the Application is using sensorless motor control techniques. If the sign of the hFinalSpeed parameter differs from that of the current speed, the ramp will not complete and a Speed Feedback error (<a class="el" href="group___m_c___type.html#gacec9c7bdd88ec978b0bf4db517830740" title="Error: Speed feedback.">MC_SPEED_FDBK</a>) will occur when the rotation speed is about to reach 0 rpm. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFinalSpeed</td><td>Mechanical rotor speed reference at the end of the ramp. Expressed in the unit defined by <a class="el" href="mc__stm__types_8h.html#a068140274b96a55eabb3ed3261c30d75" title="Rotation speed unit used at the interface with the application.">SPEED_UNIT</a>. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>Duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the speed value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6f0280fe2c9a76c706e023415765933" name="gaf6f0280fe2c9a76c706e023415765933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6f0280fe2c9a76c706e023415765933">&#9670;&#160;</a></span>MC_ProgramSpeedRampMotor2_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_ProgramSpeedRampMotor2_F </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>FinalSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs a speed ramp for Motor 2 for later or immediate execution. </p>
<p >A speed ramp is a linear change from the current speed reference to the <code>FinalSpeed</code> target speed in the given <code>hDurationms</code> time.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#ga2afb28fa66f813cfaf3e4e5e827882d2" title="Programs a speed ramp for Motor 2 for later or immediate execution.">MC_ProgramSpeedRampMotor2()</a> function programs a new speed ramp with the provided parameters. The programmed ramp is executed immediately if Motor 1's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the ramp is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gaf77d5671bfaace7e29f92171980f3050" title="Returns the status of the last buffered command for Motor 2. The status can be one of the following v...">MC_GetCommandStateMotor2()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another ramp - whether a speed or a torque one - or if another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="section note"><dt>Note</dt><dd>A ramp cannot reverse the rotation direction if the Application is using sensorless motor control techniques. If the sign of the hFinalSpeed parameter differs from that of the current speed, the ramp will not complete and a Speed Feedback error (<a class="el" href="group___m_c___type.html#gacec9c7bdd88ec978b0bf4db517830740" title="Error: Speed feedback.">MC_SPEED_FDBK</a>) will occur when the rotation speed is about to reach 0 rpm. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FinalSpeed</td><td>Mechanical rotor speed reference at the end of the ramp. Expressed in rpm. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>Duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the speed value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b597ef87d57c31a0f2dd72e65528ad4" name="ga7b597ef87d57c31a0f2dd72e65528ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b597ef87d57c31a0f2dd72e65528ad4">&#9670;&#160;</a></span>MC_ProgramTorqueRampMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_ProgramTorqueRampMotor1 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>hFinalTorque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs a torque ramp for Motor 1 for later or immediate execution. </p>
<p >A torque ramp is a linear change from the current torque reference to the <code>hFinalTorque</code> target torque reference in the given <code>hDurationms</code> time.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#ga7b597ef87d57c31a0f2dd72e65528ad4" title="Programs a torque ramp for Motor 1 for later or immediate execution.">MC_ProgramTorqueRampMotor1()</a> function programs a new torque ramp with the provided parameters. The programmed ramp is executed immediately if Motor 1's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the ramp is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gabff5c0d063001cb2e48e1bcfeb5e6c00" title="Returns the status of the last buffered command for Motor 1. The status can be one of the following v...">MC_GetCommandStateMotor1()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another ramp - whether a torque or a speed one - or if another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="section note"><dt>Note</dt><dd>A ramp cannot reverse the rotation direction if the Application is using sensorless motor control techniques. If the sign of the hFinalTorque parameter differs from that of the current torque, the ramp will not complete and a Speed Feedback error (<a class="el" href="group___m_c___type.html#gacec9c7bdd88ec978b0bf4db517830740" title="Error: Speed feedback.">MC_SPEED_FDBK</a>) will occur when the rotation speed is about to reach 0 rpm. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFinalTorque</td><td>Mechanical motor torque reference at the end of the ramp. This value represents actually the Iq current expressed in digit. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>Duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the torque value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7c953c9501378078b3a5b4e8f71b266" name="gab7c953c9501378078b3a5b4e8f71b266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c953c9501378078b3a5b4e8f71b266">&#9670;&#160;</a></span>MC_ProgramTorqueRampMotor1_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_ProgramTorqueRampMotor1_F </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>FinalTorque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs a torque ramp for Motor 1 for later or immediate execution. </p>
<p >A torque ramp is a linear change from the current torque reference to the <code>FinalTorque</code> target torque reference in the given <code>hDurationms</code> time.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#ga7b597ef87d57c31a0f2dd72e65528ad4" title="Programs a torque ramp for Motor 1 for later or immediate execution.">MC_ProgramTorqueRampMotor1()</a> function programs a new torque ramp with the provided parameters. The programmed ramp is executed immediately if Motor 1's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the ramp is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gabff5c0d063001cb2e48e1bcfeb5e6c00" title="Returns the status of the last buffered command for Motor 1. The status can be one of the following v...">MC_GetCommandStateMotor1()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another ramp - whether a torque or a speed one - or if another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="section note"><dt>Note</dt><dd>A ramp cannot reverse the rotation direction if the Application is using sensorless motor control techniques. If the sign of the FinalTorque parameter differs from that of the current torque, the ramp will not complete and a Speed Feedback error (<a class="el" href="group___m_c___type.html#gacec9c7bdd88ec978b0bf4db517830740" title="Error: Speed feedback.">MC_SPEED_FDBK</a>) will occur when the rotation speed is about to reach 0 rpm. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FinalTorque</td><td>Mechanical motor torque reference at the end of the ramp. This value represents actually the Iq current expressed in Ampere. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>Duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the torque value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ffea985358843aa7c087ae7714a1f53" name="ga3ffea985358843aa7c087ae7714a1f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ffea985358843aa7c087ae7714a1f53">&#9670;&#160;</a></span>MC_ProgramTorqueRampMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_ProgramTorqueRampMotor2 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>hFinalTorque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs a torque ramp for Motor 2 for later or immediate execution. </p>
<p >A torque ramp is a linear change from the current torque reference to the <code>hFinalTorque</code> target torque reference in the given <code>hDurationms</code> time.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#ga3ffea985358843aa7c087ae7714a1f53" title="Programs a torque ramp for Motor 2 for later or immediate execution.">MC_ProgramTorqueRampMotor2()</a> function programs a new torque ramp with the provided parameters. The programmed ramp is executed immediately if Motor 2's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the ramp is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gaf77d5671bfaace7e29f92171980f3050" title="Returns the status of the last buffered command for Motor 2. The status can be one of the following v...">MC_GetCommandStateMotor2()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another ramp - whether a torque or a speed one - or if another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="section note"><dt>Note</dt><dd>A ramp cannot reverse the rotation direction if the Application is using sensorless motor control techniques. If the sign of the hFinalTorque parameter differs from that of the current torque, the ramp will not complete and a Speed Feedback error (<a class="el" href="group___m_c___type.html#gacec9c7bdd88ec978b0bf4db517830740" title="Error: Speed feedback.">MC_SPEED_FDBK</a>) will occur when the rotation speed is about to reach 0 rpm. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFinalTorque</td><td>Mechanical motor torque reference at the end of the ramp. This value represents actually the Iq current expressed in digit. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>Duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the torque value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa734fa35ed0f523630b83ada65dce0c1" name="gaa734fa35ed0f523630b83ada65dce0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa734fa35ed0f523630b83ada65dce0c1">&#9670;&#160;</a></span>MC_ProgramTorqueRampMotor2_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_ProgramTorqueRampMotor2_F </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>FinalTorque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hDurationms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs a torque ramp for Motor 2 for later or immediate execution. </p>
<p >A torque ramp is a linear change from the current torque reference to the <code>FinalTorque</code> target torque reference in the given <code>hDurationms</code> time.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#ga3ffea985358843aa7c087ae7714a1f53" title="Programs a torque ramp for Motor 2 for later or immediate execution.">MC_ProgramTorqueRampMotor2()</a> function programs a new torque ramp with the provided parameters. The programmed ramp is executed immediately if Motor 1's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the ramp is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gaf77d5671bfaace7e29f92171980f3050" title="Returns the status of the last buffered command for Motor 2. The status can be one of the following v...">MC_GetCommandStateMotor2()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another ramp - whether a torque or a speed one - or if another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="section note"><dt>Note</dt><dd>A ramp cannot reverse the rotation direction if the Application is using sensorless motor control techniques. If the sign of the FinalTorque parameter differs from that of the current torque, the ramp will not complete and a Speed Feedback error (<a class="el" href="group___m_c___type.html#gacec9c7bdd88ec978b0bf4db517830740" title="Error: Speed feedback.">MC_SPEED_FDBK</a>) will occur when the rotation speed is about to reach 0 rpm. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FinalTorque</td><td>Mechanical motor torque reference at the end of the ramp. This value represents actually the Iq current expressed in Ampere. </td></tr>
    <tr><td class="paramname">hDurationms</td><td>Duration of the ramp expressed in milliseconds. It is possible to set 0 to perform an instantaneous change in the torque value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga160d027fc6b06718292495937e95e6c1" name="ga160d027fc6b06718292495937e95e6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga160d027fc6b06718292495937e95e6c1">&#9670;&#160;</a></span>MC_SetCurrentReferenceMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_SetCurrentReferenceMotor1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td>
          <td class="paramname"><em>Iqdref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs the current reference to Motor 1 for later or immediate execution. </p>
<p >The current reference to consider is made of the Id and Iq current components.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#ga160d027fc6b06718292495937e95e6c1" title="Programs the current reference to Motor 1 for later or immediate execution.">MC_SetCurrentReferenceMotor1()</a> function programs a current reference with the provided parameters. The programmed reference is executed immediately if Motor 1's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the command is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gabff5c0d063001cb2e48e1bcfeb5e6c00" title="Returns the status of the last buffered command for Motor 1. The status can be one of the following v...">MC_GetCommandStateMotor1()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Iqdref</td><td>current reference in the Direct-Quadratic reference frame. Expressed in the <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c75f1af4071aa0cca3f698d35c2d26a" name="ga4c75f1af4071aa0cca3f698d35c2d26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c75f1af4071aa0cca3f698d35c2d26a">&#9670;&#160;</a></span>MC_SetCurrentReferenceMotor1_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_SetCurrentReferenceMotor1_F </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqd__f__t.html">qd_f_t</a>&#160;</td>
          <td class="paramname"><em>IqdRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs the current reference to Motor 1 for later or immediate execution. </p>
<p >The current reference to consider is made of the Id and Iq current components.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#ga4c75f1af4071aa0cca3f698d35c2d26a" title="Programs the current reference to Motor 1 for later or immediate execution.">MC_SetCurrentReferenceMotor1_F()</a> function programs a current reference with the provided parameters. The programmed reference is executed immediately if Motor 1's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the command is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gabff5c0d063001cb2e48e1bcfeb5e6c00" title="Returns the status of the last buffered command for Motor 1. The status can be one of the following v...">MC_GetCommandStateMotor1()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Iqdref</td><td>current reference in the Direct-Quadratic reference frame. Expressed in the <a class="el" href="structqd__f__t.html" title="Two components q, d in float type.">qd_f_t</a> format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaedb4d4c377a50700e3498fda348c571c" name="gaedb4d4c377a50700e3498fda348c571c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb4d4c377a50700e3498fda348c571c">&#9670;&#160;</a></span>MC_SetCurrentReferenceMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_SetCurrentReferenceMotor2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqd__t.html">qd_t</a>&#160;</td>
          <td class="paramname"><em>Iqdref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs the current reference to Motor 2 for later or immediate execution. </p>
<p >The current reference to consider is made of the Id and Iq current components.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#gaedb4d4c377a50700e3498fda348c571c" title="Programs the current reference to Motor 2 for later or immediate execution.">MC_SetCurrentReferenceMotor2()</a> function programs a current reference with the provided parameters. The programmed reference is executed immediately if Motor 2's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the command is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gaf77d5671bfaace7e29f92171980f3050" title="Returns the status of the last buffered command for Motor 2. The status can be one of the following v...">MC_GetCommandStateMotor2()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Iqdref</td><td>current reference in the Direct-Quadratic reference frame. Expressed in the <a class="el" href="structqd__t.html" title="Two components q, d type definition.">qd_t</a> format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga209ce8254d6a5cb3bfe9eddd22cb3298" name="ga209ce8254d6a5cb3bfe9eddd22cb3298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga209ce8254d6a5cb3bfe9eddd22cb3298">&#9670;&#160;</a></span>MC_SetCurrentReferenceMotor2_F()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_SetCurrentReferenceMotor2_F </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqd__f__t.html">qd_f_t</a>&#160;</td>
          <td class="paramname"><em>IqdRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs the current reference to Motor 2 for later or immediate execution. </p>
<p >The current reference to consider is made of the Id and Iq current components.</p>
<p >Invoking the <a class="el" href="group___m_c_i_a_p_i.html#ga209ce8254d6a5cb3bfe9eddd22cb3298" title="Programs the current reference to Motor 2 for later or immediate execution.">MC_SetCurrentReferenceMotor2_F()</a> function programs a current reference with the provided parameters. The programmed reference is executed immediately if Motor 1's state machine is in the #START_RUN or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> states. Otherwise, the command is buffered and will be executed when the state machine reaches any of the aforementioned state.</p>
<p >The Application can check the status of the command with the <a class="el" href="group___m_c_i_a_p_i.html#gaf77d5671bfaace7e29f92171980f3050" title="Returns the status of the last buffered command for Motor 2. The status can be one of the following v...">MC_GetCommandStateMotor2()</a> to know whether the last command was executed immediately or not.</p>
<p >Only one command can be buffered at any given time. If another buffered command is programmed before the current one has completed, the latter replaces the former.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Iqdref</td><td>current reference in the Direct-Quadratic reference frame. Expressed in the <a class="el" href="structqd__f__t.html" title="Two components q, d in float type.">qd_f_t</a> format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fdd9cbe06a5472bd6a164944bdf3fa7" name="ga7fdd9cbe06a5472bd6a164944bdf3fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fdd9cbe06a5472bd6a164944bdf3fa7">&#9670;&#160;</a></span>MC_SetPolarizationOffsetsMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MC_SetPolarizationOffsetsMotor1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *&#160;</td>
          <td class="paramname"><em>PolarizationOffsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the polarization offset values to use for Motor 1. </p>
<p >The Motor Control algorithm relies on a number of current and voltage measures. The hardware parts that make these measurements need to be characterized at least once in the course of product life, prior to its first activation. This characterization consists in measuring the voltage presented to the ADC channels when either no current flows into the phases of the motor or no voltage is applied to them. This characterization is named polarization offsets measurement and its results are the polarization offsets.</p>
<p >The Motor Control Firmware can performs this polarization offsets measurement procedure which results in a number of offset values that the application can store in a non volatile memory and then set into the Motor Control subsystem at power-on or after a reset.</p>
<p >The application uses this function to set the polarization offset values that the Motor Control subsystem is to use in the current session. This function can only be used when the state machine of the motor is in the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> state in which case it returns #MC_SUCCESS. Otherwise, it does nothing and returns the #MC_WRONG_STATE_ERROR error code.</p>
<p >The Motor Control subsystem needs to know the polarization offsets before the motor can be controlled. The <a class="el" href="group___m_c_i_a_p_i.html#ga7fdd9cbe06a5472bd6a164944bdf3fa7" title="Sets the polarization offset values to use for Motor 1.">MC_SetPolarizationOffsetsMotor1()</a> function provides a way to set these offsets. Alternatively, the application can either:</p>
<ul>
<li>Execute the polarization offsets measurement procedure with a call to <a class="el" href="group___m_c_i_a_p_i.html#gae65543b075f4a089c583c8d7f852837b" title="Starts the polarization offsets measurement procedure.">MC_StartPolarizationOffsetsMeasurementMotor1()</a> after a reset or a power on;</li>
<li>Start the motor control with the MC_StartWithPolarizationMotor1() that will execute the procedure before actually starting the motor, on the first time it is called after a reset or a power on.</li>
</ul>
<p >When this function completes successfully, the state of the polarization offsets measurement procedure is set to #COMPLETED. See MC_GetPolarizationState().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PolarizationOffsets</td><td>an pointer on a structure containing the offset values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf677d7fb819876147617a86f2de01e09" name="gaf677d7fb819876147617a86f2de01e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf677d7fb819876147617a86f2de01e09">&#9670;&#160;</a></span>MC_SetPolarizationOffsetsMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MC_SetPolarizationOffsetsMotor2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_polarization_offsets__t.html">PolarizationOffsets_t</a> *&#160;</td>
          <td class="paramname"><em>PolarizationOffsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the polarization offset values to use for Motor 2. </p>
<p >The Motor Control algorithm relies on a number of current and voltage measures. The hardware parts that make these measurements need to be characterized at least once in the course of product life, prior to its first activation. This characterization consists in measuring the voltage presented to the ADC channels when either no current flows into the phases of the motor or no voltage is applied to them. This characterization is named polarization offsets measurement and its results are the polarization offsets.</p>
<p >The Motor Control Firmware can performs this polarization offsets measurement procedure which results in a number of offset values that the application can store in a non volatile memory and then set into the Motor Control subsystem at power-on or after a reset.</p>
<p >The application uses this function to set the polarization offset values that the Motor Control subsystem is to use in the current session. This function can only be used when the state machine of the motor is in the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> state in which case it returns #MC_SUCCESS. Otherwise, it does nothing and returns the #MC_WRONG_STATE_ERROR error code.</p>
<p >The Motor Control subsystem needs to know the polarization offsets before the motor can be controlled. The <a class="el" href="group___m_c_i_a_p_i.html#gaf677d7fb819876147617a86f2de01e09" title="Sets the polarization offset values to use for Motor 2.">MC_SetPolarizationOffsetsMotor2()</a> function provides a way to set these offsets. Alternatively, the application can either:</p>
<ul>
<li>Execute the polarization offsets measurement procedure with a call to <a class="el" href="group___m_c_i_a_p_i.html#gad235bd8b3f93f0f0be64d5b70e5039de" title="Starts the polarization offsets measurement procedure for Motor 2.">MC_StartPolarizationOffsetsMeasurementMotor2()</a> after a reset or a power on;</li>
<li>Start the motor control with the MC_StartWithPolarizationMotor2() that will execute the procedure before actually starting the motor, on the first time it is called after a reset or a power on.</li>
</ul>
<p >When this function completes successfully, the state of the polarization offsets measurement procedure is set to #COMPLETED. See MC_GetPolarizationState().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PolarizationOffsets</td><td>an pointer on a structure containing the offset values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42e5fb747722e38d753b3c5aa8cfa478" name="ga42e5fb747722e38d753b3c5aa8cfa478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42e5fb747722e38d753b3c5aa8cfa478">&#9670;&#160;</a></span>MC_StartMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MC_StartMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the start-up procedure for Motor 1. </p>
<p >If the state machine of Motor 1 is in <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> state, the command is immediately executed. Otherwise the command is discarded. The Application can check the return value to know whether the command was executed or discarded.</p>
<p >One of the following commands must be executed before calling <a class="el" href="group___m_c_i_a_p_i.html#ga42e5fb747722e38d753b3c5aa8cfa478" title="Initiates the start-up procedure for Motor 1.">MC_StartMotor1()</a>:</p>
<ul>
<li><a class="el" href="group___m_c_i_a_p_i.html#gabb40bdb1abfc0d65aa272a44d09363c1" title="Programs a speed ramp for Motor 1 for later or immediate execution.">MC_ProgramSpeedRampMotor1()</a></li>
<li><a class="el" href="group___m_c_i_a_p_i.html#ga7b597ef87d57c31a0f2dd72e65528ad4" title="Programs a torque ramp for Motor 1 for later or immediate execution.">MC_ProgramTorqueRampMotor1()</a></li>
<li><a class="el" href="group___m_c_i_a_p_i.html#ga160d027fc6b06718292495937e95e6c1" title="Programs the current reference to Motor 1 for later or immediate execution.">MC_SetCurrentReferenceMotor1()</a></li>
</ul>
<p >Failing to do so results in an unpredictable behaviour.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group___m_c_i_a_p_i.html#ga42e5fb747722e38d753b3c5aa8cfa478" title="Initiates the start-up procedure for Motor 1.">MC_StartMotor1()</a> command only triggers the start-up procedure: It moves Motor 1's state machine from the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> to the #IDLE_START state and then returns. It is not blocking the application until the motor is indeed running. To know if it is running, the application can query Motor 1's state machine and check if it has reached the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> state. See <a class="el" href="group___m_c_i_a_p_i.html#ga4960f7bf643c9d5aff481df0cf9c0756" title="returns the current state of Motor 1 state machine">MC_GetSTMStateMotor1()</a> for more details.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">returns</td><td>true if the command is successfully executed, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7e199ce97fe67cba8622e5a7b2521f5" name="gab7e199ce97fe67cba8622e5a7b2521f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7e199ce97fe67cba8622e5a7b2521f5">&#9670;&#160;</a></span>MC_StartMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MC_StartMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the start-up procedure for Motor 2. </p>
<p >If the state machine of Motor 2 is in <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> state, the command is immediately executed. Otherwise the command is discarded. The Application can check the return value to know whether the command was executed or discarded.</p>
<p >One of the following commands must be executed before calling <a class="el" href="group___m_c_i_a_p_i.html#gab7e199ce97fe67cba8622e5a7b2521f5" title="Initiates the start-up procedure for Motor 2.">MC_StartMotor2()</a>:</p>
<ul>
<li><a class="el" href="group___m_c_i_a_p_i.html#ga2afb28fa66f813cfaf3e4e5e827882d2" title="Programs a speed ramp for Motor 2 for later or immediate execution.">MC_ProgramSpeedRampMotor2()</a></li>
<li><a class="el" href="group___m_c_i_a_p_i.html#ga3ffea985358843aa7c087ae7714a1f53" title="Programs a torque ramp for Motor 2 for later or immediate execution.">MC_ProgramTorqueRampMotor2()</a></li>
<li><a class="el" href="group___m_c_i_a_p_i.html#gaedb4d4c377a50700e3498fda348c571c" title="Programs the current reference to Motor 2 for later or immediate execution.">MC_SetCurrentReferenceMotor2()</a></li>
</ul>
<p >Failing to do so results in an unpredictable behaviour.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group___m_c_i_a_p_i.html#gab7e199ce97fe67cba8622e5a7b2521f5" title="Initiates the start-up procedure for Motor 2.">MC_StartMotor2()</a> command only triggers the start-up procedure: It moves Motor 1's state machine from the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> to the #IDLE_START state and then returns. It is not blocking the application until the motor is indeed running. To know if it is running, the application can query Motor 1's state machine and check if it has reached the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> state. See <a class="el" href="group___m_c_i_a_p_i.html#gae7449fd926b607ad9cc4dcd5a88453c0" title="returns the current state of Motor 2 state machine">MC_GetSTMStateMotor2()</a> for more details.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">returns</td><td>true if the command is successfully executed, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae65543b075f4a089c583c8d7f852837b" name="gae65543b075f4a089c583c8d7f852837b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae65543b075f4a089c583c8d7f852837b">&#9670;&#160;</a></span>MC_StartPolarizationOffsetsMeasurementMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MC_StartPolarizationOffsetsMeasurementMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the polarization offsets measurement procedure. </p>
<p >See <a class="el" href="group___m_c_i_a_p_i.html#ga7fdd9cbe06a5472bd6a164944bdf3fa7" title="Sets the polarization offset values to use for Motor 1.">MC_SetPolarizationOffsetsMotor1()</a> for more details.</p>
<p >If the Motor Control Firmware is in the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> state, the procedure is started, the state machine of the motor switches to <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca4a727c494b6bb2945a8d36fdebbf2cf9">OFFSET_CALIB</a> and #MC_SUCCESS is returned. Otherwise, nothing is done and the #MC_WRONG_STATE_ERROR error code is returned.</p>
<p >The polarization offsets measurement procedure is only triggered by this function and it is has not completed when this function returns. The application can use the MC_GetPolarizationState() function to query the state of the procedure.</p>
<dl class="section see"><dt>See also</dt><dd>MC_GetPolarizationState() </dd></dl>

</div>
</div>
<a id="gad235bd8b3f93f0f0be64d5b70e5039de" name="gad235bd8b3f93f0f0be64d5b70e5039de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad235bd8b3f93f0f0be64d5b70e5039de">&#9670;&#160;</a></span>MC_StartPolarizationOffsetsMeasurementMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MC_StartPolarizationOffsetsMeasurementMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the polarization offsets measurement procedure for Motor 2. </p>
<p >See <a class="el" href="group___m_c_i_a_p_i.html#gaf677d7fb819876147617a86f2de01e09" title="Sets the polarization offset values to use for Motor 2.">MC_SetPolarizationOffsetsMotor2()</a> for more details.</p>
<p >If the Motor Control Firmware is in the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> state, the procedure is started, the state machine of the motor switches to <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca4a727c494b6bb2945a8d36fdebbf2cf9">OFFSET_CALIB</a> and #MC_SUCCESS is returned. Otherwise, nothing is done and the #MC_WRONG_STATE_ERROR error code is returned.</p>
<p >The polarization offsets measurement procedure is only triggered by this function and it is has not completed when this function returns. The application can use the MC_GetPolarizationState() function to query the state of the procedure.</p>
<dl class="section see"><dt>See also</dt><dd>MC_GetPolarizationState() </dd></dl>

</div>
</div>
<a id="gad2e6cff9f74f1c8c5dbb315050ff7f8e" name="gad2e6cff9f74f1c8c5dbb315050ff7f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2e6cff9f74f1c8c5dbb315050ff7f8e">&#9670;&#160;</a></span>MC_StopMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MC_StopMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the stop procedure for Motor 1. </p>
<p >If the state machine is in <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca13d000b4d7dc70d90239b7430d1eb6b2">START</a> states the command is immediately executed. Otherwise, the command is discarded. The Application can check the return value to know whether the command was executed or discarded.</p>
<dl class="section note"><dt>Note</dt><dd>The MCI_StopMotor1() command only triggers the stop motor procedure moving Motor 1's state machine to #ANY_STOP and then returns. It is not blocking the application until the motor is indeed stopped. To know if it has stopped, the application can query Motor 1's state machine ans check if the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> state has been reached back.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">returns</td><td>true if the command is successfully executed, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa985abf29c62a7ca64b3eb68ea920d49" name="gaa985abf29c62a7ca64b3eb68ea920d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa985abf29c62a7ca64b3eb68ea920d49">&#9670;&#160;</a></span>MC_StopMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MC_StopMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the stop procedure for Motor 2. </p>
<p >If the state machine is in <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca439c688a4e9ed31638d5922a50680a8e">RUN</a> or <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0ca13d000b4d7dc70d90239b7430d1eb6b2">START</a> states the command is immediately executed. Otherwise, the command is discarded. The Application can check the return value to know whether the command was executed or discarded.</p>
<dl class="section note"><dt>Note</dt><dd>The MCI_StopMotor2() command only triggers the stop motor procedure moving Motor 2's state machine to #ANY_STOP and then returns. It is not blocking the application until the motor is indeed stopped. To know if it has stopped, the application can query Motor 1's state machine ans check if the <a class="el" href="group___m_c_interface.html#ggaf9c63cc62b4961a5e4ae805cac0abf0cafd6a0e4343048b10646dd2976cc5ad18">IDLE</a> state has been reached back.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">returns</td><td>true if the command is successfully executed, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga33cc4d83a5a038b41d03d9a73e8bab6f" name="ga33cc4d83a5a038b41d03d9a73e8bab6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33cc4d83a5a038b41d03d9a73e8bab6f">&#9670;&#160;</a></span>MC_StopRampMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_StopRampMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the execution of the on-going ramp for Motor 1, if any. </p>
<p >If a ramp is currently being executed, it is immediately stopped, the torque or the speed of Motor 1 is maintained to its current value. </p>

</div>
</div>
<a id="ga81e43508fcf9c8b3d2e908e1cf12c2d9" name="ga81e43508fcf9c8b3d2e908e1cf12c2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81e43508fcf9c8b3d2e908e1cf12c2d9">&#9670;&#160;</a></span>MC_StopRampMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak void MC_StopRampMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the execution of the on-going ramp for Motor 2, if any. </p>
<p >If a ramp is currently being executed, it is immediately stopped, the torque or the speed of Motor 2 is maintained to its current value. </p>

</div>
</div>
<a id="ga8bdf135d4e761f0afb9118966b5aa5d6" name="ga8bdf135d4e761f0afb9118966b5aa5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bdf135d4e761f0afb9118966b5aa5d6">&#9670;&#160;</a></span>MC_StopSpeedRampMotor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MC_StopSpeedRampMotor1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the execution of the on-going speed ramp for Motor 1, if any. </p>
<p >If a speed ramp is currently being executed, it is immediately stopped, the rotation speed of Motor 1 is maintained to its current value and true is returned. If no speed ramp is on-going, nothing is done and false is returned.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This function is deprecated and should not be used anymore. It will be removed in a future version of the MCSDK. Use <a class="el" href="group___m_c_i_a_p_i.html#ga33cc4d83a5a038b41d03d9a73e8bab6f" title="Stops the execution of the on-going ramp for Motor 1, if any.">MC_StopRampMotor1()</a> instead. </dd></dl>

</div>
</div>
<a id="gabe62db3a0a7a8afa28ae519b1ef97114" name="gabe62db3a0a7a8afa28ae519b1ef97114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe62db3a0a7a8afa28ae519b1ef97114">&#9670;&#160;</a></span>MC_StopSpeedRampMotor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__weak bool MC_StopSpeedRampMotor2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the execution of the on-going speed ramp for Motor 2, if any. </p>
<p >If a speed ramp is currently being executed, it is immediately stopped, the rotation speed of Motor 2 is maintained to its current value and true is returned. If no speed ramp is on-going, nothing is done and false is returned.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This function is deprecated and should not be used anymore. It will be removed in a future version of the MCSDK. Use <a class="el" href="group___m_c_i_a_p_i.html#ga81e43508fcf9c8b3d2e908e1cf12c2d9" title="Stops the execution of the on-going ramp for Motor 2, if any.">MC_StopRampMotor2()</a> instead. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
