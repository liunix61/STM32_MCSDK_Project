<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: Six-step Firmware Algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Six-step Firmware Algorithm </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Introduction</h1>
<p >This document describes the software library that implements the 6-step algorithm, also known as a trapezoidal algorithm, contained in the <a href="https://www.st.com/en/embedded-software/x-cube-mcsdk.html">X-CUBE-MCSDK</a> STM32 motor-control software development kits (SDKs) designed for, and to be used with, STM32 microcontrollers. The 6-step library allows the control of a 3-phase permanent magnet (PMSM) or brushless direct current motor (BLDC) and can be used to quickly evaluate ST microcontrollers, complete ST application platforms, and save time when developing motor control algorithms to be run on ST microcontrollers. It is written in the C language and implements the core motor control algorithms, as well as sensor reading/decoding algorithms and sensor-less algorithms for rotor position reconstruction.</p>
<p >The library can be customized to suit user application parameters (motor, sensors, power stage, control stage, pin-out assignment) and provides a ready-to-use application programming interface (API). A PC graphical user interface (GUI), the ST motor control workbench, allows complete and easy customization of the library. Thanks to this, the user can run a motor in a very short time.</p>
<p >A set of ready-to-use examples is provided to explain the use of the motor control API and its most commonly used features.</p>
<p >These projects usually provide a UART interface that allows convenient real-time fine-tuning of the motor-control subsystem with a remote control tool, the STM32 motor control monitor.</p>
<p >The STM32 motor control SDK is delivered as an expansion pack for the STM32 CubeMX tool, and the 6-step library is based on the STM32 Cube Firmware libraries.</p>
<p >The list of supported STM32 microcontrollers is provided in the release note delivered with the SDK.</p>
<h1>Acronyms and abbreviations</h1>
<p >Refer to the <a class="el" href="md_docs_terms_abbreviations.html">Terms &amp; Abbreviations</a> page for a list of all acronyms and abbreviations used in the documentation. </p><h1>6-step firmware algorithms</h1>
<h2>Definitions</h2>
<p >A brushless three-phase motor is composed as shown in <b>Figure 1</b> of a fixed element, called the stator, made of a set of three windings, meaning phases, connected at one side and a moving element containing an internal permanent magnet called the rotor. The rotor may have several pole pairs regularly distributed around the stator.</p>
<p ><b>Figure 1</b>: Motor stator and rotor arrangement<br  />
 <img src="6S_STM32_MC_Picture1.png" alt="" class="inline" title="Figure 1 : Motor stator and rotor arrangement"/>    </p>
<p >In 6-step driving, the electrical cycle is divided into six commutation steps. At each step, the bus voltage is connected to one of the three-phase windings of the motor while the ground is connected to a second winding, forcing a current flowing through these two windings and generating a stator magnetic field as shown in <b>Figure 2</b>. The third winding remains floating.</p>
<p ><b>Figure 2</b> : Motor stator and rotor magnetic fields<br  />
 <img src="6S_STM32_MC_6stepUM_2.png" alt="" class="inline" title="Figure 2 : Motor stator and rotor magnetic fields"/>    </p>
<p >The orientation of the stator magnetic field is changed energizing the windings in the sequence shown in <b>Figure 3</b>.</p>
<p ><b>Figure 3</b>: Motor stator magnetic fields discrete positions<br  />
 <img src="6S_STM32_MC_6stepUM_3.png" alt="" class="inline" title="Figure 3 : Motor stator magnetic fields discrete positions"/>    </p>
<p >Since the rotor has a permanent magnetic field, the rotating stator magnetic field creates a torque that moves the rotor. The maximum torque is obtained when the electrical angle between the rotor and the stator is 90°. The orientation of the stator magnetic field is changed thanks to the 6-step commutation keeping the motor spinning, as explained in <b>Figure 4</b>.</p>
<p ><b>Figure 4</b>: Motor torque<br  />
 <img src="6S_STM32_MC_6stepUM_4.png" alt="" class="inline" title="Figure 4 : Motor torque"/>    </p>
<h2>Algorithm overview</h2>
<p >The 6-step firmware reveals the position of the motor rotor every 60 electrical degrees (in sensor-less or sensored mode). Based on this information, it computes the time for the next step commutation and calculates the duty cycles for the PWM signals that drive the output power transistors. These transistors control the motor phase voltages allowing them to reach a target speed.</p>
<p >The 6-step firmware can be viewed as a set of components, each with a different task.</p>
<p ><b>Figure 5</b>: Basic 6-step algorithm structure<br  />
 <img src="6S_STM32_MC_6stepUM_5.png" alt="" class="inline" title="Basic 6-step algorithm structure"/>    </p>
<p >The following list describes the components shown in <b>Figure 5</b>:</p>
<ul>
<li><em>speed and position feedback</em> component: BEMF sensing is used with the sensors-less driving mode while Hall sensors are exploited with the sensor driving mode</li>
<li><em>pulse computation</em> component (voltage mode – VM or current mode - CM) is used. A proportional-integral (PI) controller algorithm is employed for the speed loop control</li>
<li><em>time computation</em> component: it manages the step change and applies the configuration of the timers set by the <em>step update</em> component</li>
<li><em>step update</em> component: it updates the configuration of the timers, hence the proper energization of the phases, according to the selected driving mode (standard with synchronous rectification).</li>
</ul>
<h3>Voltage driving mode</h3>
<p >The motor speed is controlled by directly varying the duty cycle of the pulse width modulated voltages applied to the motor phases.</p>
<h3>Current driving mode</h3>
<p >The motor speed is controlled by limiting the peak of the current flowing through the active phases.</p>
<p >This driving mode exploits the presence of an amplifier A and a comparator C. The current is controlled by setting the duty cycle of a PWM generated by a timer (REF timer) used as the reference voltage of the comparator C. The output of the comparator triggers the switch-off of the PWMs connected to the motor phases when the amplified sense resistor voltage is greater than the reference voltage.</p>
<p ><b>Figure 6</b>: Current driving mode structure<br  />
 <img src="6S_STM32_MC_6stepUM_6.png" alt="" class="inline" title="Figure 6 : Current driving mode structure"/>    </p>
<h3>Sensor-less algorithm</h3>
<p >In the sensor-less mode, the position of the rotor is obtained by detecting the zero-crossing of the Back Electro-Motive Force sensed at the floating phase. This is commonly done using an ADC as shown in <b>Figure 7</b>. In particular, when the magnetic field of the rotor crosses the high impedance phase, the corresponding BEMF voltage changes its sign (zero-crossing). The BEMF voltage can be scaled at the ADC input, thanks to a resistor network controlled by a GPIO. When the GPIO output is low, the resistor network divides the voltage coming from the motor phase.</p>
<p ><b>Figure 7</b>: Motor with sensor-less circuit <img src="6S_STM32_MC_6stepUM_7.png" alt="" class="inline" title="Figure 7 : Motor with sensor-less circuit"/>    </p>
<h3>Hall sensors algorithm</h3>
<p >In this driving mode, the positioning of the rotor is obtained by reading the digital signals coming from the Hall sensors (connected to three GPIOs).</p>
<p >During the alignment time, the position of the rotor is acquired and the motor windings are energized accordingly. When a sensor commutation is detected, new status is acquired. At the same time, the step is changed and the PWMs updated accordingly.</p>
<h1>STM32 MC firmware</h1>
<p >The STM32 MC firmware is the heart of the SDK. It provides all the software components needed to control 3-phase motors using the 6-step strategy and integrates these components into an MC subsystem. It offers a versatile set of interfaces that custom applications can use to drive motors according to their needs.</p>
<p ><b>Figure 8</b> shows the architecture of the STM32 MC firmware.</p>
<p >The firmware consists of the three following functional sets:</p>
<ul>
<li>The 6-step Library contains software components that implement the motor control features;</li>
<li>The UI Library contains software components that deal with the communication between the motor control firmware subsystem and either the user or an offloaded application;</li>
<li>The motor control cockpit integrates all these software components into a motor control firmware subsystem and implements the regulation loops.</li>
</ul>
<p ><b>Figure 8</b>: STM32 motor control firmware architecture<br  />
 <img src="6S_STM32_MC_6stepUM_8.png" alt="" class="inline" title="Figure 8 : STM32 motor control firmware architecture"/>    </p>
<h2>6-step MC library</h2>
<p >The 6-step MC library is a collection of software components. Each component implements a feature involved in MC such as the speed and position sensing, PID regulator, or motor control algorithms.</p>
<p >For some features, the library provides several components, each containing a different implementation. This allows to efficiently support various hardware configurations. Then, the components to use are chosen depending on the characteristics of the user’s application and are integrated into a motor control firmware subsystem.</p>
<p ><b>Figure 9</b> summarizes the features provided by the 6-step library as components. The list of most of the components in the 6-step library and their specificities are described in Section 5.1.</p>
<p ><b>Figure 9</b>: 6-step MC library features delivered as components<br  />
 <img src="6S_STM32_MC_6stepUM_9.png" alt="" class="inline" title="Figure 9 : 6-step MC library features delivered as components"/>    </p>
<h2>User interface library</h2>
<p >The user interface library or UI library contains software components that deal with the communication between the MC firmware subsystem and the outside world using a serial port. This library is used to allow the STM32 MC WB to connect to the Application and control it with its Monitor feature.</p>
<h2>Motor control cockpit integration</h2>
<p >The Motor control cockpit integrates the software components into an MC firmware subsystem and implements the regulation loops. It instantiates, configures, and interfaces the firmware components selected in the 6-step library and the user interface library for the user’s application. The code of the MC Cockpit is generated by STM32Cube according to the characteristics of the application. Thanks to this generation the code of the cockpit only contains what is needed and is thus easily readable.</p>
<h1>6-step motor control firmware subsystem</h1>
<p >The motor control firmware subsystem is the firmware library that results from the configuration and generation of a firmware project with the STM32 MC WB / STM32CubeMx pair. Users then build their final application on top of this subsystem, adding their code that uses one of the provided APIs (see below).</p>
<p ><b>Figure 10</b> provides an overview of this subsystem showing optional and mandatory functional blocks as well as how they interact with one another. Note that only the most important blocks and interactions are shown for the sake of clarity. This figure highlights three sets of functional blocks: the 6-step loop, the reference computation loop and the safety loop. Each of them is made up of one or more components that implement a specific feature of the algorithm.</p>
<p ><b>Figure 10</b>: Motor-control subsystem overview<br  />
 <img src="6S_STM32_MC_6stepUM_10.png" alt="" class="inline" title="Figure 10 : Motor-control subsystem overview"/>    </p>
<h2>6-Step loop</h2>
<p >The 6-step loop is the core of the algorithm. It aims to compute the phase voltages and produce the resulting duty cycles to apply to the transistors driving the motor’s phases. It performs the correlation between electrical angle and 6-step tables and updates the timer registers accordingly determining the step change.</p>
<p >The 6-step loop is executed at a high rate, the PWM frequency or its multiple (according to the 6-step loop execution time set by the user). Higher the rate higher the accuracy of the electrical angle control at the expense of a higher computation load. This might be limiting for lower-end microcontrollers.</p>
<h2>Reference computation loop</h2>
<p >The purpose of the Reference computation loop, as its name suggests, is to compute the duty cycle references based on targets coming from the application. Usually, the application provides a reference expressed in a way that matches its needs: a speed reference or ramp. The reference computation loop first converts the application target into a phase voltage duty cycle or reference current duty cycle which is then used to generate motor windings PWMs and optionally a current reference PWM.</p>
<p >This process is in force when the motor-control subsystem is executing in closed-loop mode.</p>
<p >However, this is not the only operating mode. Indeed, depending on the chosen Speed and Position Feedback technology, a rev/up phase may be needed that will take over that process until the rotor Position estimation is judged reliable. This is the purpose of the Rev-up Control component.</p>
<p >In addition, some applications may require that the motor control stays in open-loop mode. This case is handled by the open-loop control component that is executed instead of the normal-regulation process.</p>
<p >All these cases fall in the basket of the Reference computation loop that is executed at a medium rate, typically on the SysTick interrupt.</p>
<h2>Safety loop</h2>
<p >The last set of functional blocks is the Safety loop. This set is called a loop because it consists of functions that get executed periodically. They all deal with features that aim at reacting to conditions that may endanger the system from a hardware point of view: Over and under-voltage protection, overheating protection, and overcurrent protection. In the case of overcurrent protection, the STM32 MC firmware is designed to exploit hardware mechanisms implemented in the STM32 MCUs such as the Timer Break input that accelerate the system reaction to an overcurrent situation.</p>
<p >The Safety loop is executed at the same rate as the Reference computation loop – that is at a medium rate, usually with the SysTick interrupt.</p>
<h2>Motor control firmware components</h2>
<p >Most of the motor control firmware is organized as a set of software components. A component is a self-contained software unit that defines:</p>
<ul>
<li>A structure with the data needed to fulfill the feature the component is designed to provide</li>
<li>A set of functions operating on instances of the structure and that implement that feature</li>
</ul>
<p >The data placed in the structure of a component are the parameters that characterize this component and that tune its behavior. They fully describe the state of the component. In the motor control firmware, a type is defined to hold these data together. Variables of this type are used as handles on instances of the component.</p>
<p ><b>Figure 11</b>: A component with its handle and its function<br  />
 <img src="6S_STM32_MC_6stepUM_11.png" alt="" class="inline" title="Figure 11 : A component with its handle and its function"/>    </p>
<p >The way this principle is used is very straightforward. Where a feature is needed, the component that matches this feature is selected and a variable of the structure’s type is defined. The variable is then initialized with the feature’s parameters as defined for the application. This is done when the motor control firmware subsystem is initialized by the <code>MC_boot()</code> function.</p>
<p >Finally, during the operation of the motor control firmware subsystem, the functions defined for the component are called where and when needed to benefit from the feature it provides. These functions provide the component’s feature. To perform their task, they expect a pointer on a handle of the component’s structure as the first argument so that they have access to the state and the settings of the instance of the component they work for.</p>
<p >The notion of components makes it easy to offer several implementations of a given feature. For such cases, a generic component is defined for the feature. Its handle contains the data common to the feature whatever its actual implementation is, and its functions operate on these data. In addition, the prototypes of the functions that each component implementing the feature need to provide are defined. These functions are the interface of the components.</p>
<p >Then, these implementing components reuse and extend the handle of the generic component into their own and implement the functions needed to fulfill the feature. This allows for simplified integration and an easy replacement of implementation by another.</p>
<p ><b>Figure 12</b>: A component with its handle and its function<br  />
 <img src="6S_STM32_MC_6stepUM_12.png" alt="" class="inline" title="Figure 12 : A component with its handle and its function"/>    </p>
<p >An example of this situation is the set of Speed and Position Feedback components. A generic component is defined, represented by the <a class="el" href="struct_speedn_pos_fdbk___handle__t.html" title="SpeednPosFdbk handles definitions of mechanical and electrical speed, mechanical acceleration,...">SpeednPosFdbk_Handle_t</a> handle structure, defined in the <a class="el" href="speed__pos__fdbk_8h.html" title="This file provides all definitions and functions prototypes of the Speed &amp; Position Feedback componen...">speed_pos_fdbk.h</a> file. The handle of this generic component only contains the data purely related to the speed and the position of the motor’s rotor such as the current mechanical and electrical angles, the conversion factor between them, and the limits within which the feature is to be used. And its functions are only about setting and getting these data. Two actual implementations are provided, one that uses Hall Effect sensors and one that implements the feature using a bemf sensing-based algorithm. Each of these two implementations defines its handle that extends <a class="el" href="struct_speedn_pos_fdbk___handle__t.html" title="SpeednPosFdbk handles definitions of mechanical and electrical speed, mechanical acceleration,...">SpeednPosFdbk_Handle_t</a> and each defines interface functions based on the same prototypes.</p>
<p >The following sections present an overview of all the components offered by the STM32 MC SDK. For a complete description, refer to the STM32 MC firmware reference manual.</p>
<h3>PWM generation component</h3>
<h4>Features overview</h4>
<p >The PWM component is responsible for</p>
<ul>
<li>applying the desired voltage on the three phases</li>
<li>managing the triggering of the ADC (sensor-less mode only)</li>
</ul>
<p >A timer peripheral is used to generate the PWM signals and to trigger the measurement of the ADC at the right time. This mechanism is described in more detail in Section 5.1.2.</p>
<p >Concretely, the main task of this component is to enable and disable the outputs and apply the voltages to the proper phases following the 6-step sequence and the driving modes described here below.</p>
<p >This task begins when the motor is started and ends when it is stopped. In addition, these components also play a role in other matters such as the boot capacitor charging which requires switching the low sides transistors on, and the overcurrent protection. Each PWM handles the Timer interrupts that are relevant to its operation. It expects these interrupts to be configured with a given priority level and it defines its functions to handle them.</p>
<p >The Application shall tamper neither with the priorities of these interrupts nor with the order in which they are served in the interrupt handler.</p>
<h4>Available Implementations and specificities</h4>
<p >The 6-step library provides all the components needed to support 6-pwm and 3-pwm (plus 3 enable GPIOs) devices. The selection of the component that matches the device topology actually in use by the application is performed through the STM32 MC WB.</p>
<p >These implementations are built on a generic PWM generation component that they extend and that provides the functions and data common to all of them. This base component cannot be used as-is since it does not provide a complete implementation of the features. Rather, its handle structure (PWMC_Handle_t) is reused by all the PWM generation-specific implementations.</p>
<p >The functions, that the generic PWM generation component provides, form the API of the PWM generation feature. Calling those results in calling functions of the component implementing the feature.</p>
<p >Besides the standard driving mode (one phase with PWM applied, one phase floating, and one phase to ground), three additional driving modes are implemented: Mid-Step alignment, fast demagnetization and quasi-synchronous rectification.</p>
<p >These additional modes are implemented in each of the specific PWM generation components. They are explained in detail in the following sections.</p>
<h4>Mid-Step alignment driving mode</h4>
<p >In sensor-less driving mode, the motor is first aligned at a predefined and known rotor position before starting the acceleration phase. To minimize the mechanical vibrations and make the start-up more smooth, the alignment position is chosen to be in the middle between adjacent steps. Therefore, instead of the standard 6-step phase polarization table the following one is used, based on the initial step of the sequence and spinning direction. None of the three phases is floating.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Initial step   </th><th class="markdownTableHeadNone">Direction   </th><th class="markdownTableHeadNone">PWM applied   </th><th class="markdownTableHeadNone">Ground    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Step1   </td><td class="markdownTableBodyNone">Clockwise   </td><td class="markdownTableBodyNone">PhaseU + Phase W   </td><td class="markdownTableBodyNone">Phase V    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Counter-clockwise   </td><td class="markdownTableBodyNone">PhaseU   </td><td class="markdownTableBodyNone">PhaseV + PhaseW    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Step2   </td><td class="markdownTableBodyNone">Clockwise   </td><td class="markdownTableBodyNone">PhaseU   </td><td class="markdownTableBodyNone">PhaseV + PhaseW    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Counter-clockwise   </td><td class="markdownTableBodyNone">PhaseU + PhaseV   </td><td class="markdownTableBodyNone">PhaseW    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Step3   </td><td class="markdownTableBodyNone">Clockwise   </td><td class="markdownTableBodyNone">PhaseU + PhaseV   </td><td class="markdownTableBodyNone">PhaseW    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Counter-clockwise   </td><td class="markdownTableBodyNone">PhaseV   </td><td class="markdownTableBodyNone">PhaseU + Phase W    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Step4   </td><td class="markdownTableBodyNone">Clockwise   </td><td class="markdownTableBodyNone">PhaseV   </td><td class="markdownTableBodyNone">PhaseU + Phase W    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Counter-clockwise   </td><td class="markdownTableBodyNone">PhaseV + PhaseW   </td><td class="markdownTableBodyNone">PhaseU    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Step5   </td><td class="markdownTableBodyNone">Clockwise   </td><td class="markdownTableBodyNone">PhaseV + PhaseW   </td><td class="markdownTableBodyNone">PhaseU    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Counter-clockwise   </td><td class="markdownTableBodyNone">PhaseW   </td><td class="markdownTableBodyNone">PhaseU + PhaseV    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Step6   </td><td class="markdownTableBodyNone">Clockwise   </td><td class="markdownTableBodyNone">PhaseW   </td><td class="markdownTableBodyNone">PhaseU + PhaseV    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Counter-clockwise   </td><td class="markdownTableBodyNone">PhaseU + Phase W   </td><td class="markdownTableBodyNone">PhaseV   </td></tr>
</table>
<p >Table 3 : Mid-alignment driving mode table</p>
<h4>Fast demagnetization driving mode</h4>
<p >When the microcontroller switches from one step to the next, the non-excited winding needs a certain demagnetization time. During this time, the current in the winding continues in the same direction but decreases to zero. To accelerate the demagnetization, the PWM signal must be applied to the low-side switch during the step when the demagnetizing current is flowing from the bridge to the motor phases. Refer to Table 4 for a description of the firmware implementation</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Step   </th><th class="markdownTableHeadNone">MOSfet On(HigSide + LowSide)   </th><th class="markdownTableHeadNone">Demagnetizationcurrent   </th><th class="markdownTableHeadNone">PWM applied withFAST_DEMA=1    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Step1   </td><td class="markdownTableBodyNone">PhaseU+PhaseV   </td><td class="markdownTableBodyNone">PhaseW (from bridge to motor)   </td><td class="markdownTableBodyNone">PhaseV (LS)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Step2   </td><td class="markdownTableBodyNone">PhaseU+PhaseW   </td><td class="markdownTableBodyNone">PhaseV (from motor to bridge)   </td><td class="markdownTableBodyNone">PhaseU (HS)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Step3   </td><td class="markdownTableBodyNone">PhaseV+PhaseW   </td><td class="markdownTableBodyNone">PhaseU (from bridge to motor)   </td><td class="markdownTableBodyNone">PhaseW (LS)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Step4   </td><td class="markdownTableBodyNone">PhaseV+PhaseU   </td><td class="markdownTableBodyNone">PhaseW (from motor to bridge)   </td><td class="markdownTableBodyNone">PhaseV (HS)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Step5   </td><td class="markdownTableBodyNone">PhaseW+PhaseU   </td><td class="markdownTableBodyNone">PhaseV (from bridge to motor)   </td><td class="markdownTableBodyNone">PhaseU (LS)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Step6   </td><td class="markdownTableBodyNone">PhaseW+PhaseV   </td><td class="markdownTableBodyNone">PhaseU (from motor to bridge)   </td><td class="markdownTableBodyNone">PhaseW (HS)   </td></tr>
</table>
<p >Table 4 : Fast demagnetization table</p>
<p >The fast demagnetization driving mode can be enabled before the project generation or in the Motor Pilot application. When enabled, the fast demagnetization configuration is applied during the whole step in sensored mode and during only the demagnetization period in sensor-less mode.</p>
<h4>Quasi-synchronous rectification driving mode</h4>
<p >By default, the power stage is driven by the algorithm in fast decay mode.</p>
<p >At the start of the OFF-time, both the power MOS of the energized phases are switched off and the current recirculates through the two opposite freewheeling diodes. The current decays with a high di/dt since the voltage across the coil is the power-supply voltage. After the deadtime, the low-side MOS and the high-side MOS in parallel with the conducting diode are turned on in synchronous rectification mode (see Figure 13).</p>
<p >In applications where the motor current is low, the load current may decay completely to zero and rise in the opposite direction.</p>
<p >To avoid this, the quasi-synchronous rectification option may be enabled: The lower power MOS is not turned on preventing the current to reverse (see Figure 14). This driving mode is available only with the devices supporting the 6-pwm configuration and, similarly to the fast demagnetization option, it can be activated in the Motor Pilot application.</p>
<p >The quasi-synchronous rectification and the fast demagnetization modes are incompatible one another.</p>
<p ><b>Figure 13</b>: Synchronous rectification<br  />
 <img src="STM32_MC_6step_9.png" alt="" class="inline" title="Synchronous rectification"/>    </p>
<p ><b>Figure 14</b>: Quasi-synchronous rectification<br  />
 <img src="STM32_MC_6step_10.png" alt="" class="inline" title="Synchronous rectification"/>    </p>
<h3>Speed and position feedback components</h3>
<p >These components provide the speed and the angular position of the rotor of a motor (both electrical and mechanical). While the angular position is crucial to perform properly the step-change at the right time, the rotor speed measurement is needed to close the speed loop.</p>
<p >Two implementations of the Speed and Position Feedback feature are provided by the STM32 MC firmware. One uses sensors embedded in some motors (Hall sensors) and the other one provides an estimation of the speed and the position of the rotor based on the sensing of the Back-EMF of the motor.</p>
<p >These two implementations are built on a generic Speed and Position Feedback component – named the Speed and Position Feedback component – which they extend and which provides the data common to all of them. In addition to that, also the sensing of the Back-EMF is deployed in several components, each of them dedicated to a specific microcontroller family.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Component   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Hall Speed and Position Feedback   </td><td class="markdownTableBodyNone">This component uses the signal coming from three Hall-effect sensors to provide a measure of the speed and the position of the rotor of the motor    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">BEMF Speed and Position Feedback – G4xx micro family   </td><td class="markdownTableBodyNone">This component uses the sensing of the Back-EMF at the motor phases to provide an estimation of the position of the rotor of the motor and then calculate its speed    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BEMF Speed and Position Feedback – G0xx micro family   </td><td class="markdownTableBodyNone">This component uses the sensing of the Back-EMF at the motor phases to provide an estimation of the position of the rotor of the motor and then calculate its speed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">BEMF Speed and Position Feedback – F0xx micro family   </td><td class="markdownTableBodyNone">This component uses the sensing of the Back-EMF at the motor phases to provide an estimation of the position of the rotor of the motor and then calculate its speed   </td></tr>
</table>
<p >Table 5 : Available Speed and Position Feedback Components</p>
<p >An additional implementation is also present in the firmware: the Virtual Speed and Position Feedback component. This component is only used during the Rev up phase of the motor, while Back_EMF-based implementations are used for closed-loop mode.</p>
<h4>Back-EMF sensing and zero-crossing point detection</h4>
<p >Back-EMF sensing components take full ownership of the ADC peripherals they use. The application can use the ADC channels left free by the motor-control subsystem, but it may not interface with these channels directly. The Application shall use the functions of the Regular Conversion Manager (RCM) component. Refer to the Reference Documentation of the MC SDK for a complete description.</p>
<p ><b>Figure 15</b> shows the synchronization strategy between the TIM1 PWM output and the ADC. Normally the A/D converter peripheral is configured so that it is triggered by the falling edge of TIM1_CH4 during the decay time (PWM-OFF time).</p>
<p ><b>Figure 15</b>: PWM and ADC synchronization<br  />
 <img src="6S_STM32_MC_6stepUM_13.png" alt="" class="inline" title="Figure 15 : PWM and ADC synchronization"/>    </p>
<p >The interrupt triggered by the end of the injected channel conversion manages the polling of the converted value and its evaluation for the estimation of the rotor position.</p>
<p >The Back-EMF waveform of a brushless motor changes along with the rotor position and speed and is in a trapezoidal shape. <b>Figure 16</b> shows the waveform of the current and back-EMF for one electrification period, where the solid line denotes the current (Ripples are ignored for the sake of simplicity). The dashed line represents the back electro-motive force and the horizontal coordinate represents the electric perspective of motor rotation.</p>
<p ><b>Figure 16</b>: BLDC current and back-EMF waveforms<br  />
 <img src="6S_STM32_MC_6stepUM_14.png" alt="" class="inline" title="Figure 16 : BLDC current and back-EMF waveforms"/>    </p>
<p >The middle of every two phase-switching points corresponds to one point whose back electro-motive force polarity is changed, the zero-crossing point. Once the zero-crossing point is identified, the phase-switching moment is set after an electrical delay of 30°.</p>
<p >Two different strategies are available for the identification of the zero-crossing point:</p>
<ul>
<li>Back-EMF sensing during the OFF time</li>
<li>Back-EMF sensing during the ON time</li>
</ul>
<h4>Back-EMF sensing during the OFF time</h4>
<p >This kind of detection can be used with both the driving modes, current and voltage modes. The principle is the one described in <b>Figure 17</b> where the ADC conversion is triggered during the OFF time of the PWM. At the beginning of every 6-step commutation, the ADC channel corresponding to the floating phase is selected. After a masking period corresponding to the demagnetization period of the floating phase, during which the Back-EMF reading is not reliable, the converted values are compared with a threshold to determine the Back-EMF polarity change. Once the zero-crossing point is detected a delay of 30° electrical degrees, based on the current measured speed, is programmed on a timer, whose update triggers finally the step commutation. Comparison thresholds can be set independently on the direction of change of the Back-EMF (increasing or decreasing).</p>
<p >Note: To avoid damaging the devices, as shown in <b>Figure 17</b>, the minimum of the back-EMF reading is limited by the protection diodes present on the board</p>
<p ><b>Figure 17</b>: Back-EMF sensing and step commutation<br  />
 <img src="6S_STM32_MC_6stepUM_15.png" alt="" class="inline" title="Figure 17 : Back-EMF sensing and step commutation"/>    </p>
<h4>Back-EMF sensing during the ON time</h4>
<p >This kind of detection can be used with the voltage driving mode only where the duty cycle is fixed and doesn’t change along the step. The principle is the one described in <b>Figure 18</b> where the ADC conversion is triggered during the ON time of the PWM. At the beginning of every 6-step commutation, the ADC channel corresponding to the floating phase is selected. After a masking period corresponding to the demagnetization period of the floating phase, during which the Back-EMF reading is not reliable, thanks to a resistor network that allows estimating the voltage of the center-tap point (the common point of the three motor phases), the converted values are compared with a threshold that is ideally half of the Bus voltage.</p>
<p ><em><b>B-emf threshold (ON-time sensing) = Bus_Voltage / 2</b></em></p>
<p >The threshold is set considering a resistor dividing network that rescales the phase voltage to the ADC input range. Once the crossing point based on the current measured speed is programmed on a timer, whose update triggers finally the step commutation. In some cases, the resistor dividing network may include diodes to protect the ADC inputs from overvoltage. The above threshold is then replaced by the following one:</p>
<p ><em><b>B-emf threshold (ON-time sensing) = (Bus_Voltage / 2) + 0.7</b></em></p>
<p ><b>Figure 18</b>: Back-EMF during ON time<br  />
 <img src="6S_STM32_MC_6stepUM_16.png" alt="" class="inline" title="Figure 18 : Back-EMF during ON time"/>    </p>
<p >While the Back-EMF sensing during the OFF time is normally performed in sensor-less mode, the user is allowed to enable or disable the sensing during the ON time as long as the voltage drive mode is selected.</p>
<p >When both sensing techniques are used, the algorithm automatically switches between one another based on the PWM duty cycle allowing it to reach close to 100% duty cycle.</p>
<p ><b>Note: Zero-crossing detection thresholds (both with back-emf rising and falling) during the pwm on-time are usually close to half of the bus voltage. Since they are not dynamically calculated by the firmware, user is advised to manually tune and change them through the Workbench user interface if bus voltage is different from the nominal one. Otherwise, "over-current" or "speed feedback" errors may rise</b></p>
<h3>Bus voltage sensing components</h3>
<p >The STM32 MC firmware provides components to report the value of the bus voltage. A measurement of the bus voltage is, of course, needed for features like the under or over voltage Protection.</p>
<p >Two implementations of a bus voltage sensing component are available. One that uses an ADC channel and two big resistors to measure the voltage (the Resistor Divider Bus Voltage Sensor) and another one that actually does not measure anything and only reports a configured value (the Virtual Bus Voltage Sensor).</p>
<p >For its measurements, the resistor divider bus voltage sensor implementation uses a channel of the ADC configured for the current feedback of motor 1, thanks to the regular conversion API. Refer to Section 5.2.4 for more details.</p>
<h3>Temperature measurement component</h3>
<p >The STM32 MC firmware provides one component to report the motor-control subsystem’s temperature. This component – the NTC Temperature Sensor – acts both as a real temperature sensor that uses an ADC channel to measure the temperature from a probe and as a virtual temperature sensor that reports a configured temperature value.</p>
<h3>Drive Regulation components</h3>
<p >This section presents some of the drive regulation components that are delivered with the firmware. For complete information on all these components, refer to the STM32 Motor Control Reference Manual.</p>
<h4>PID</h4>
<p >The PID component provides an implementation of a proportional–integral–derivative controller. This component is primarily used by the reference computation loop in the speed controller.</p>
<p >It comes in two flavors: a full PID using all three terms and a simpler one that only uses the Proportional and Integral terms. The motor-control subsystem uses the latter one.</p>
<h4>Revup</h4>
<p >The Revup component is responsible for starting the motor. Its task begins when the motor is started open-loop and ends when the current control loop can be closed.</p>
<h4>Speed Control</h4>
<p >This component serves two purposes:</p>
<ol type="1">
<li>It produces the duty cycle reference from the speed reference submitted by the application. As such, it manages the ramps programmed by the application</li>
<li>It regulates this speed reference thanks to a PID component.</li>
</ol>
<h2>Motor control cockpit</h2>
<p >The motor control cockpit plays a central role in a motor-control subsystem; it configures and integrates a few components selected for the MC application. And, in addition, it provides the implementation of the 6-step algorithm, reference computation, and safety loops that match the designed application.</p>
<p >As such, it must support a vast diversity of configurations that lead to a potentially huge and cumbersome source code. To avoid this issue and to provide a code that is as simple as possible, most of the cockpit’s code is generated from the application’s characteristics. Thanks to this generation, only these portions of the code that are needed for the MC system are present in the MC cockpit’s source code.</p>
<p >Despite its changing nature, the code of the MC cockpit is organized in a sole and structured way.</p>
<h3>Motor Control Cockpit main source files</h3>
<p >This section lists the most important source files that make the MC cockpit. Refer to the STM32 MC SDK reference documentation (delivered with the SDK) for a complete list of these files and their documentation.</p>
<p ><b><a class="el" href="motorcontrol_8c.html" title="Motor Control Subsystem initialization functions.">motorcontrol.c</a>, <a class="el" href="motorcontrol_8h.html" title="Motor Control Subsystem initialization functions.">motorcontrol.h</a>:</b></p>
<p >The <a class="el" href="motorcontrol_8c.html" title="Motor Control Subsystem initialization functions.">motorcontrol.c</a> file mainly contains a function <a class="el" href="group___m_c_interface.html#ga5c1d915db5adf398cbe27acc15496f7f" title="Initializes and configures the Motor Control Subsystem.">MX_MotorControl_Init()</a> which is used by the application generated by STM32CubeMx to initialize the MC subsystem. Its <a class="el" href="motorcontrol_8h.html" title="Motor Control Subsystem initialization functions.">motorcontrol.h</a> companion file is only useful to the CubeMX generated main.c file to get the prototype of the function it calls.</p>
<p ><b><a class="el" href="mc__api_8c.html" title="This file implements the high level interface of the Motor Control SDK.">mc_api.c</a>, <a class="el" href="mc__api_8h.html" title="This file defines the high level interface of the Motor Control SDK.">mc_api.h</a>:</b></p>
<p >This pair of files contains the definition and implementation of the high-level Application Programming Interface that the application can use to control the motors. See Section 6.1 for a description of this API. As such, <a class="el" href="mc__api_8h.html" title="This file defines the high level interface of the Motor Control SDK.">mc_api.h</a> is the file that applications need to include to use it.</p>
<p ><b><a class="el" href="mc__config_8c.html" title="Motor Control Subsystem components configuration and handler structures.">mc_config.c</a>, <a class="el" href="mc__config_8h.html" title="Motor Control Subsystem components configuration and handler structures declarations.">mc_config.h</a>:</b></p>
<p >The <a class="el" href="mc__config_8c.html" title="Motor Control Subsystem components configuration and handler structures.">mc_config.c</a> file contains the structures and the data used to configure all the components used by the MC subsystem. The <a class="el" href="mc__config_8h.html" title="Motor Control Subsystem components configuration and handler structures declarations.">mc_config.h</a> file exports the names of the structures for the application to use as the Lower Level API as described in Section 6.2.</p>
<p ><b><a class="el" href="mc__parameters_8c.html" title="This file provides definitions of HW parameters specific to the configuration of the subsystem.">mc_parameters.c</a>, <a class="el" href="mc__parameters_8h.html" title="This file provides declarations of HW parameters specific to the configuration of the subsystem.">mc_parameters.h</a>:</b></p>
<p >The <a class="el" href="mc__parameters_8c.html" title="This file provides definitions of HW parameters specific to the configuration of the subsystem.">mc_parameters.c</a> file contains structures and data that contain constant parameters for the MC subsystem. Its role is similar to the <a class="el" href="mc__config_8c.html" title="Motor Control Subsystem components configuration and handler structures.">mc_config.c</a> file except that its content can be fully placed in FLASH memory since it is constant. The <a class="el" href="mc__parameters_8h.html" title="This file provides declarations of HW parameters specific to the configuration of the subsystem.">mc_parameters.h</a> file exports the names of the structures for the application to read them in the scope of the Lower Level API as described in Section 6.2.</p>
<p ><b>mc_types.h:</b></p>
<p >This file contains type definitions that are used across the motor-control subsystem. In addition, it includes all relevant STM32 Cube LL header files that are needed for the motor-control subsystem.</p>
<p ><b>Motor-control subsystem parameters:</b></p>
<p >A serie of files is generated that contain a lot of constants – defined as C preprocessor symbols – which are set to values that are meaningful to the MC subsystem and that are used in its code. Some of these files are dedicated to some STM32 family and are only present if the chosen MCU is part of this family. The list of these files:</p>
<ul>
<li><a class="el" href="drive__parameters_8h.html" title="This file contains the parameters needed for the Motor Control SDK in order to configure a motor driv...">drive_parameters.h</a></li>
<li><a class="el" href="pmsm__motor__parameters_8h.html" title="This file contains the parameters needed for the Motor Control SDK in order to configure the motor to...">pmsm_motor_parameters.h</a></li>
<li><a class="el" href="power__stage__parameters_8h.html" title="This file contains the parameters needed for the Motor Control SDK in order to configure a power stag...">power_stage_parameters.h</a></li>
<li><a class="el" href="parameters__conversion_8h.html" title="This file includes the proper Parameter conversion on the base of stdlib for the first drive.">parameters_conversion.h</a></li>
<li><a class="el" href="parameters__conversion__g4xx_8h.html" title="This file contains the definitions needed to convert MC SDK parameters so as to target the STM32G4 Fa...">parameters_conversion_g4xx.h</a></li>
</ul>
<p ><b>Interrupt handling:</b></p>
<p >The motor-control subsystem provides handlers for the interrupts it uses. These are defined in files that depend on the chosen STM32 family (stm32g4xx_mc_it.c for G4xx microcontroller family).</p>
<p ><b><a class="el" href="mc__tasks_8c.html" title="This file implements tasks definition.">mc_tasks.c</a>:</b></p>
<p >This file contains the implementation of the core of the MC cockpit. It contains the code of the loops described at the beginning of Section 5. More information on them is given below.</p>
<h3>Tasks of the motor-control subsystem</h3>
<p >The code of each of the three loops that are at the heart of the MC firmware subsystem is distributed into “Task” functions.</p>
<p >The 6-step loop is implemented in the <a class="el" href="group___m_c_tasks.html#ga8c1ddefd0981ca101cfa98acb72aacc4" title="Motor control profiler HF task.">TSK_HighFrequencyTask()</a> function. This function is executed at the PWM frequency rate (That is: once every PWM Period, see Section 5.1.1 PWM generation component). The PWM frequency is the highest in the motor-control subsystem. It is executed in the handler of the interrupt that occurs at each timer update</p>
<p >The main task of this function is to translate the electrical angle into the 6-step sequence and update the PWM duty cycles that are to be programmed in the PWM Timer channels. Hence, the time this function must operate is limited as it needs to complete before the next timer-update event when new PWM duty cycles are taken into account. Failing to execute in this lapse of time results in the 6-step execution error.</p>
<p >The Reference computation loop is implemented in the function <a class="el" href="mc__tasks_8c.html#ae66a3f6dc67830ff22319890739f87f9" title="Executes medium frequency periodic Motor Control tasks.">TSK_MediumFrequencyTaskM1()</a>. This function needs to be invoked periodically at a frequency that is typically lower than that of the <a class="el" href="group___m_c_tasks.html#ga8c1ddefd0981ca101cfa98acb72aacc4" title="Motor control profiler HF task.">TSK_HighFrequencyTask()</a>. In the STM32 MC firmware subsystem, the functions are called on the SysTick interrupt.</p>
<p >The Safety loop is implemented by the <a class="el" href="group___m_c_tasks.html#ga70dcc80ce2a677f112e8e19b15ec9c5a" title="Executes safety checks (e.g. bus voltage and temperature) for all drive instances.">TSK_SafetyTask()</a> function. This function calls one of <a class="el" href="mc__tasks_8c.html#a2a38df09e9886223637a149039130d27" title="Safety task implementation if MC.ON_OVER_VOLTAGE == TURN_OFF_PWM.">TSK_SafetyTask_PWMOFF()</a> or <a class="el" href="mc__tasks_8c.html#a2f8a82965caa948cb475b57d65b720ea" title="Safety task implementation if MC.ON_OVER_VOLTAGE == TURN_ON_LOW_SIDES.">TSK_SafetyTask_LSON()</a> depending on the chosen over-voltage protection. <a class="el" href="group___m_c_tasks.html#ga70dcc80ce2a677f112e8e19b15ec9c5a" title="Executes safety checks (e.g. bus voltage and temperature) for all drive instances.">TSK_SafetyTask()</a> is invoked periodically at the same frequency as the reference computation loop and on the same interrupt.</p>
<h3>Fault handling</h3>
<p >The MC subsystem reports the faults it detects to the application. On the fault detection, the MC firmware first executes actions to place the motor hardware subsystem in a safe state, and then it enters a fault state. These actions always result in the faulty motor being stopped.</p>
<p >The faults that are detected are the following:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Component   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MC_NO_ERROR   </td><td class="markdownTableBodyNone">There is no fault currently pending on the motor-control subsystem    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MC_DURATION   </td><td class="markdownTableBodyNone">The 6-step loop lasted too long (the PWM timer-update event occurred before the new PWM duty cycle values were available)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MC_OVER_VOLTAGE   </td><td class="markdownTableBodyNone">An overvoltage condition detected on the Bus    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MC_UNDER_VOLTAGE   </td><td class="markdownTableBodyNone">An under-voltage condition detected on the Bus    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MC_OVER_TEMP   </td><td class="markdownTableBodyNone">The Temperature of the system crossed the maximum threshold    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MC_START_UP   </td><td class="markdownTableBodyNone">The startup phase ends before the speed and position estimation is reliable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MC_SPEED_FDBK   </td><td class="markdownTableBodyNone">The speed feedback is not reliable anymore (usually happens when the rotor speed goes too low)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MC_BREAK_IN   </td><td class="markdownTableBodyNone">An overcurrent condition or a general fault signal from a power device embedded protection is detected    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MC_SW_ERROR   </td><td class="markdownTableBodyNone">A non-motor dependent error (Pure MC firmware error) is detected   </td></tr>
</table>
<p >Table 6 : Detected fault</p>
<p >The handling of faults in the MC firmware involves two states of the MC state machine. When a fault is detected, the MC state machine enters the FAULT_NOW state which indicates that a fault condition currently exists. On entering this state, the PWM output is immediately cut off. The MC state machine remains in this state as long as the fault condition remains valid, meaning as long as the condition that led to declaring the fault is true. When the no-fault condition is not active anymore, the MC state machine switches to the FAULT_OVER state and will remain in that state until the application acknowledges them. On the acknowledgment of the Faults, the MC state machine goes back to the IDLE state and the subsystem is ready to start the motor again (see Section 5.3.3).</p>
<h3>ADC conversions for the Application</h3>
<p >There are situations where the application needs to use free channels of the ADC peripheral used by the MC subsystem for phase Back-EMF measurement. As described in Configuring peripherals with STM32CubeMx these ADC channels can be configured with STM32CubeMx.</p>
<p >However, the application must not use these channels directly. It may rather use the API functions described in Programming a regular conversion on a Motor Control ADC, Retrieving the result of a Motor Control ADC regular conversion, and Retrieving the state of a Motor Control ADC regular conversion. Indeed, the instants when the phase Back-EMF measurements are to be made must be set within the PWM period. In the firmware, Injected conversions are used and external triggers coming from the PWM timer start them.</p>
<p >Hence, the Application cannot use injected conversions on these ADC peripherals as they are reserved for motor control and they must avoid disturbing the injected conversion. The purpose of the APIs mentioned here is to allow the application to perform regular ADC conversions without disturbing the motor-control subsystem. Getting a conversion done with them is a three-step process:</p>
<p >1. The MC_ProgramRegularConversion() function is called to request an ADC regular conversion on the given channel and with the given conversion time. The motor-control subsystem then schedules the requested conversion that will occur right after the next Injected conversion, when there is no risk of collision;</p>
<p >2. The Application can then call the MC_GetRegularConversionState() function to determine if the requested conversion is completed.</p>
<p >3. Finally, the Application calls the MC_GetRegularConversionValue() to retrieve the converted value.</p>
<p >Note: The motor-control subsystem will only accept one conversion at a time. So, the application may use the MC_GetRegularConversionState() to determine if the conversion can be handled. In addition, all conversion requests must be performed inside routines with the same priority level.</p>
<h3>Motor Control State Machine</h3>
<p >The MC firmware subsystem maintains a state machine for the motor it controls. The tasks executed on the motor, and the API functions that can be called, are depending on the current state of the state machine.</p>
<p ><b>Figure 19</b> details the full MC state machine. States are indicated in the blue circles while possible transitions between the states are marked with the arrows.</p>
<p >The actual state machine may be simpler depending on the configured application. Indeed, some states are only needed in specific cases. For instance, the states about motor acceleration and closed-loop switch-over are only useful if the sensor-less mode is used.</p>
<p >The state machine is never directly changed by the application. Its management is handled by the Reference computation loop which is in the <a class="el" href="mc__tasks_8c.html#ae66a3f6dc67830ff22319890739f87f9" title="Executes medium frequency periodic Motor Control tasks.">TSK_MediumFrequencyTaskM1()</a> function.</p>
<p ><b>Figure 19</b>: Motor state machine<br  />
 <img src="6S_STM32_MC_6stepUM_17.png" alt="" class="inline" title="Figure 19 : Motor state machine"/>    </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Component   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">IDLE   </td><td class="markdownTableBodyNone">The Motor is not spinning, but is ready to start or to align    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CHARGE_BOOT_CAP   </td><td class="markdownTableBodyNone">State where the gate driver boot capacitors will be charged    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">START   </td><td class="markdownTableBodyNone">State where the motor alignment and rev-up steps are intended to be executed. It ends with the validation of the sensor-less estimation of the rotor position    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SWITCH_OVER   </td><td class="markdownTableBodyNone">State where the speed loop is closed. The following state is normally RUN    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RUN   </td><td class="markdownTableBodyNone">State with running motor. The following state is normally STOP when a stop motor command is executed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">STOP   </td><td class="markdownTableBodyNone">The following state is normally IDLE as soon as conditions for moving state machine are detected (stop procedure is completed)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FAULT_NOW   </td><td class="markdownTableBodyNone">The state machine can be moved from any condition directly to this state by STM_FaultProcessing() function. This method also manages the passage to the only allowed following state which is FAULT_OVER.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FAULT_OVER   </td><td class="markdownTableBodyNone">State where the application is intended to stay when the fault conditions disappear. The following state is normally IDLE. The state machine is moved as soon as the user acknowledges the fault condition   </td></tr>
</table>
<p >Table 7 : Motor state machine</p>
<h1>Motor control API</h1>
<h2>Motor control API</h2>
<p >The Motor Control API also referred to as the MC API, is the main and most straightforward interface offered to applications for controlling the motors driven by the STM32 MC subsystem.</p>
<p >For the sake of simplicity, the MC API offers one set of functions restricting the number of parameters these functions expect to the bare minimum.</p>
<p >The main purpose of this API is to start, stop the motors, and control their rotation. The control of the rotation of a motor is achieved by programming a speed reference that the PID regulator of the motor-control subsystem will maintain. Such a reference must be set before starting a motor.</p>
<p >The speed reference is programmed as a ramp that moves the actual reference from its current value to its target value in a given time.</p>
<p >A programmed reference or ramp is executed at once if the motor is spinning and steady (Its state machine is in the RUN state). Otherwise, it is buffered until the state machine of the motor reaches the RUN state. Only one reference or ramp can be programmed at a time, the last one replacing the previous.</p>
<p >In addition to the rotation controlling functions, the MC API also provides functions to get the values of various parameters and state variables of the MC subsystem such as the mechanical or electrical speed for instance.</p>
<p >A brief description of the main functions of the MC API consists of is given here along with the usage principles. A complete definition is available in the STM32 MC SDK Reference Manual.</p>
<h3>Starting a motor</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="group___m_c_i_a_p_i.html#ga42e5fb747722e38d753b3c5aa8cfa478">MC_StartMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_ga42e5fb747722e38d753b3c5aa8cfa478"><div class="ttname"><a href="group___m_c_i_a_p_i.html#ga42e5fb747722e38d753b3c5aa8cfa478">MC_StartMotor1</a></div><div class="ttdeci">bool MC_StartMotor1(void)</div><div class="ttdoc">Initiates the start-up procedure for Motor 1.</div><div class="ttdef"><b>Definition:</b> mc_api.c:111</div></div>
</div><!-- fragment --><p >Starts the target Motor. *Before calling this function, a Speed ramp or a duty cycle reference must have been set.</p>
<h3>Stopping motor</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="group___m_c_i_a_p_i.html#gad2e6cff9f74f1c8c5dbb315050ff7f8e">MC_StopMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_gad2e6cff9f74f1c8c5dbb315050ff7f8e"><div class="ttname"><a href="group___m_c_i_a_p_i.html#gad2e6cff9f74f1c8c5dbb315050ff7f8e">MC_StopMotor1</a></div><div class="ttdeci">bool MC_StopMotor1(void)</div><div class="ttdoc">Initiates the stop procedure for Motor 1.</div><div class="ttdef"><b>Definition:</b> mc_api.c:131</div></div>
</div><!-- fragment --><p >Stops the target Motor. If the target motor is not spinning, this function does nothing. Otherwise, the PWM outputs are switched off, whether the MC subsystem is in a close loop or still in the rev up phase.</p>
<h3>Programming a speed ramp</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group___m_c_i_a_p_i.html#gabb40bdb1abfc0d65aa272a44d09363c1">MC_ProgramSpeedRampMotor1</a>(int16_t hFinalSpeed, uint16_t hDurationms );</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_gabb40bdb1abfc0d65aa272a44d09363c1"><div class="ttname"><a href="group___m_c_i_a_p_i.html#gabb40bdb1abfc0d65aa272a44d09363c1">MC_ProgramSpeedRampMotor1</a></div><div class="ttdeci">void MC_ProgramSpeedRampMotor1(int16_t hFinalSpeed, uint16_t hDurationms)</div><div class="ttdoc">Programs a speed ramp for Motor 1 for later or immediate execution.</div><div class="ttdef"><b>Definition:</b> mc_api.c:167</div></div>
</div><!-- fragment --><p >Programs a speed ramp on the target motor. If the target Motor is in the RUN state – that is: the Motor is spinning and steady – the ramp is executed immediately. Otherwise, it is buffered until this state is reached.</p>
<p >A speed ramp takes the motor from its rotation speed at the start of the ramp to the hFinalSpeed target speed of the ramp in the hDurations duration.</p>
<h3>Stopping an on-going speed ramp</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="group___m_c_i_a_p_i.html#ga8bdf135d4e761f0afb9118966b5aa5d6">MC_StopSpeedRampMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_ga8bdf135d4e761f0afb9118966b5aa5d6"><div class="ttname"><a href="group___m_c_i_a_p_i.html#ga8bdf135d4e761f0afb9118966b5aa5d6">MC_StopSpeedRampMotor1</a></div><div class="ttdeci">bool MC_StopSpeedRampMotor1(void)</div><div class="ttdoc">Stops the execution of the on-going speed ramp for Motor 1, if any.</div><div class="ttdef"><b>Definition:</b> mc_api.c:399</div></div>
</div><!-- fragment --><p >Stops the execution of the current speed ramp of the target Motor.</p>
<h3>Retrieving the status of a ramp</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="group___m_c_i_a_p_i.html#gaada6da7e5ae1bcc9f22d23b51f2f0eca">MC_HasRampCompletedMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_gaada6da7e5ae1bcc9f22d23b51f2f0eca"><div class="ttname"><a href="group___m_c_i_a_p_i.html#gaada6da7e5ae1bcc9f22d23b51f2f0eca">MC_HasRampCompletedMotor1</a></div><div class="ttdeci">bool MC_HasRampCompletedMotor1(void)</div><div class="ttdoc">Returns true if the last ramp submited for Motor 1 has completed, false otherwise.</div><div class="ttdef"><b>Definition:</b> mc_api.c:418</div></div>
</div><!-- fragment --><p >Returns true if the last submitted ramp for the target Motor is completed, false otherwise.</p>
<h3>Retrieving the PWM duty cycle reference</h3>
<div class="fragment"><div class="line">uint16_t <a class="code hl_function" href="group___m_c_i_a_p_i.html#ga21dc1a07d794b7a13ac515bfd34ea383">MCI_GetDutyCycleRefMotor1</a>();</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_ga21dc1a07d794b7a13ac515bfd34ea383"><div class="ttname"><a href="group___m_c_i_a_p_i.html#ga21dc1a07d794b7a13ac515bfd34ea383">MCI_GetDutyCycleRefMotor1</a></div><div class="ttdeci">int16_t MCI_GetDutyCycleRefMotor1(void)</div><div class="ttdoc">returns the electrical torque reference for Motor 1</div><div class="ttdef"><b>Definition:</b> mc_api.c:367</div></div>
</div><!-- fragment --><p >Returns the duty cycle reference applied to the output phases.</p>
<h3>Retrieving the state of commands</h3>
<div class="fragment"><div class="line"><a class="code hl_enumeration" href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a> <a class="code hl_function" href="group___m_c_i_a_p_i.html#gabff5c0d063001cb2e48e1bcfeb5e6c00">MC_GetCommandStateMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_gabff5c0d063001cb2e48e1bcfeb5e6c00"><div class="ttname"><a href="group___m_c_i_a_p_i.html#gabff5c0d063001cb2e48e1bcfeb5e6c00">MC_GetCommandStateMotor1</a></div><div class="ttdeci">MCI_CommandState_t MC_GetCommandStateMotor1(void)</div><div class="ttdoc">Returns the status of the last buffered command for Motor 1. The status can be one of the following v...</div><div class="ttdef"><b>Definition:</b> mc_api.c:384</div></div>
<div class="ttc" id="agroup___m_c_interface_html_ga93b37db848f1e9e2f72923b7d6909f1c"><div class="ttname"><a href="group___m_c_interface.html#ga93b37db848f1e9e2f72923b7d6909f1c">MCI_CommandState_t</a></div><div class="ttdeci">MCI_CommandState_t</div><div class="ttdef"><b>Definition:</b> mc_interface.h:85</div></div>
</div><!-- fragment --><p >Returns the state of the last submitted command for the target motor. “Command” means a speed ramp or a duty cycle reference setting.</p>
<p >The returned state is an MCI_CommandState_t enumerable value:</p>
<ul>
<li><code>MCI_BUFFER_EMPTY</code>: No command is submitted;</li>
<li><code>MCI_COMMAND_NOT_ALREADY_EXECUTED</code>: A command is buffered but its execution is not completed yet;</li>
<li><code>MCI_COMMAND_EXECUTED_SUCCESFULLY</code>: Execution of the last buffered command is completed successfully;</li>
<li><code>MCI_COMMAND_EXECUTED_UNSUCCESFULLY</code>: Execution of the last buffered command is completed unsuccessfully.</li>
</ul>
<h3>Retrieving the control mode of the motor</h3>
<div class="fragment"><div class="line"><a class="code hl_enumeration" href="group___m_c___type.html#ga93791db1e1974fe42cab1e0a9c35e21e">MC_ControlMode_t</a> <a class="code hl_function" href="group___m_c_i_a_p_i.html#ga085a7dc5c638012df6213194f056dc9d">MC_GetControlModeMotor1</a>();</div>
<div class="ttc" id="agroup___m_c___type_html_ga93791db1e1974fe42cab1e0a9c35e21e"><div class="ttname"><a href="group___m_c___type.html#ga93791db1e1974fe42cab1e0a9c35e21e">MC_ControlMode_t</a></div><div class="ttdeci">MC_ControlMode_t</div><div class="ttdoc">Specifies the control modality of the motor.</div><div class="ttdef"><b>Definition:</b> mc_type.h:228</div></div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_ga085a7dc5c638012df6213194f056dc9d"><div class="ttname"><a href="group___m_c_i_a_p_i.html#ga085a7dc5c638012df6213194f056dc9d">MC_GetControlModeMotor1</a></div><div class="ttdeci">MC_ControlMode_t MC_GetControlModeMotor1(void)</div><div class="ttdoc">Returns the Control Mode used for Motor 1 (either Speed or Torque)</div><div class="ttdef"><b>Definition:</b> mc_api.c:546</div></div>
</div><!-- fragment --><p >Returns the control mode for the target motor. The available return states are <code>MCM_TORQUE_MODE</code> (open-loop operation) and <code>MCM_SPEED_MODE</code> (closed-loop operation).</p>
<h3>Retrieving the drive mode of the motor</h3>
<div class="fragment"><div class="line"><a class="code hl_enumeration" href="group___m_c___type.html#ga76f46bd91dbbd8abc8817460d9ea9777">DrivingMode_t</a> MC_GetDriveModeMotor1();</div>
<div class="ttc" id="agroup___m_c___type_html_ga76f46bd91dbbd8abc8817460d9ea9777"><div class="ttname"><a href="group___m_c___type.html#ga76f46bd91dbbd8abc8817460d9ea9777">DrivingMode_t</a></div><div class="ttdeci">DrivingMode_t</div><div class="ttdoc">DrivingMode_t type definition, it's used by Bemf_ADC class to specify the driving mode type.</div><div class="ttdef"><b>Definition:</b> mc_type.h:219</div></div>
</div><!-- fragment --><p >Returns the drive mode for the target motor. It can be either VM (voltage mode) or CM (current mode).</p>
<h3>Retrieving the direction of rotation of the motor</h3>
<div class="fragment"><div class="line">int16_t <a class="code hl_function" href="group___m_c_i_a_p_i.html#ga81255845ad783b18a5c8320364bddce5">MC_GetImposedDirectionMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_ga81255845ad783b18a5c8320364bddce5"><div class="ttname"><a href="group___m_c_i_a_p_i.html#ga81255845ad783b18a5c8320364bddce5">MC_GetImposedDirectionMotor1</a></div><div class="ttdeci">int16_t MC_GetImposedDirectionMotor1(void)</div><div class="ttdoc">Returns the rotation direction imposed by the last command on Motor 1.</div><div class="ttdef"><b>Definition:</b> mc_api.c:562</div></div>
</div><!-- fragment --><p >Returns the direction imposed by the last command on the target motor. The returned value is either 1 or -1.</p>
<h3>Retrieving speed sensor reliability</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="group___m_c_i_a_p_i.html#gaacb8ff46b9093a12296074ba366aa8da">MC_GetSpeedSensorReliabilityMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_gaacb8ff46b9093a12296074ba366aa8da"><div class="ttname"><a href="group___m_c_i_a_p_i.html#gaacb8ff46b9093a12296074ba366aa8da">MC_GetSpeedSensorReliabilityMotor1</a></div><div class="ttdeci">bool MC_GetSpeedSensorReliabilityMotor1(void)</div><div class="ttdoc">Returns true if the speed sensor used for Motor 1 is reliable, false otherwise.</div><div class="ttdef"><b>Definition:</b> mc_api.c:570</div></div>
</div><!-- fragment --><p >Returns true if the speed sensor of the target motor provides reliable values.</p>
<h3>Retrieving average mechanical rotation speed of the motor</h3>
<div class="fragment"><div class="line">int16_t <a class="code hl_function" href="group___m_c_i_a_p_i.html#gaa81a6e618cbd5039e0caca329771d272">MC_GetMecSpeedAverageMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_gaa81a6e618cbd5039e0caca329771d272"><div class="ttname"><a href="group___m_c_i_a_p_i.html#gaa81a6e618cbd5039e0caca329771d272">MC_GetMecSpeedAverageMotor1</a></div><div class="ttdeci">int16_t MC_GetMecSpeedAverageMotor1(void)</div><div class="ttdoc">Returns the current mechanical rotor speed reference set for Motor 1, expressed in rpm.</div><div class="ttdef"><b>Definition:</b> mc_api.c:442</div></div>
</div><!-- fragment --><p >Returns the last computed average mechanical rotor speed for the target Motor, expressed in dHz (Tenth of Hertz).</p>
<h3>Retrieving electrical angle of the motor</h3>
<div class="fragment"><div class="line">int16_t <a class="code hl_function" href="group___m_c_i_a_p_i.html#ga08eeab345a77b7bf42647c4832b7afca">MC_GetElAngledppMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_ga08eeab345a77b7bf42647c4832b7afca"><div class="ttname"><a href="group___m_c_i_a_p_i.html#ga08eeab345a77b7bf42647c4832b7afca">MC_GetElAngledppMotor1</a></div><div class="ttdeci">int16_t MC_GetElAngledppMotor1(void)</div><div class="ttdoc">returns the electrical angle of the rotor of Motor 1, in DDP format</div><div class="ttdef"><b>Definition:</b> mc_api.c:681</div></div>
</div><!-- fragment --><p >Returns the electrical angle of the rotor of the motor.</p>
<h3>Motor control fault acknowledgement</h3>
<div class="fragment"><div class="line">int16_t <a class="code hl_function" href="group___m_c_i_a_p_i.html#gaee5ef9cd0d85a8998d1e635f6cbaf6f7">MC_AcknowledgeFaultMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_gaee5ef9cd0d85a8998d1e635f6cbaf6f7"><div class="ttname"><a href="group___m_c_i_a_p_i.html#gaee5ef9cd0d85a8998d1e635f6cbaf6f7">MC_AcknowledgeFaultMotor1</a></div><div class="ttdeci">bool MC_AcknowledgeFaultMotor1(void)</div><div class="ttdoc">Acknowledge a Motor Control fault that occured on Motor 1.</div><div class="ttdef"><b>Definition:</b> mc_api.c:724</div></div>
</div><!-- fragment --><p >Acknowledges MC faults pending on the target motor. This function returns true if faults were indeed pending and false otherwise. Refer to Section 5.3.1 for more information on MC fault management.</p>
<h3>Retrieving the latest motor control faults</h3>
<div class="fragment"><div class="line">int16_t <a class="code hl_function" href="group___m_c_i_a_p_i.html#gaccf1b164487fc23c152be6cd68657a9d">MC_GetOccurredFaultsMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_gaccf1b164487fc23c152be6cd68657a9d"><div class="ttname"><a href="group___m_c_i_a_p_i.html#gaccf1b164487fc23c152be6cd68657a9d">MC_GetOccurredFaultsMotor1</a></div><div class="ttdeci">uint16_t MC_GetOccurredFaultsMotor1(void)</div><div class="ttdoc">Returns a bitfiled showing &quot;new&quot; faults that occured on Motor 1.</div><div class="ttdef"><b>Definition:</b> mc_api.c:738</div></div>
</div><!-- fragment --><p >Returns a bit field showing faults that have occurred since the MC state machine of the target motor was moved to the FAULT_NOW state. Refer to Section 5.3.1 for more information on MC fault management and Section 5.3.3 for a description of the MC state machine.</p>
<h3>Retrieving all motor control faults</h3>
<div class="fragment"><div class="line">int16_t <a class="code hl_function" href="group___m_c_i_a_p_i.html#ga638964d634142640e1e4c94895e743ed">MC_GetCurrentFaultsMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_ga638964d634142640e1e4c94895e743ed"><div class="ttname"><a href="group___m_c_i_a_p_i.html#ga638964d634142640e1e4c94895e743ed">MC_GetCurrentFaultsMotor1</a></div><div class="ttdeci">uint16_t MC_GetCurrentFaultsMotor1(void)</div><div class="ttdoc">returns a bitfield showing all current faults on Motor 1</div><div class="ttdef"><b>Definition:</b> mc_api.c:752</div></div>
</div><!-- fragment --><p >Returns a bit field showing all current faults on the target motor. Refer to Section 5.3.1 for more information on MC fault management.</p>
<h3>Retrieving the state of the motor control state machine</h3>
<div class="fragment"><div class="line"><a class="code hl_enumeration" href="group___m_c_interface.html#gaf9c63cc62b4961a5e4ae805cac0abf0c">MCI_State_t</a>  <a class="code hl_function" href="group___m_c_i_a_p_i.html#ga4960f7bf643c9d5aff481df0cf9c0756">MC_GetSTMStateMotor1</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup___m_c_i_a_p_i_html_ga4960f7bf643c9d5aff481df0cf9c0756"><div class="ttname"><a href="group___m_c_i_a_p_i.html#ga4960f7bf643c9d5aff481df0cf9c0756">MC_GetSTMStateMotor1</a></div><div class="ttdeci">MCI_State_t MC_GetSTMStateMotor1(void)</div><div class="ttdoc">returns the current state of Motor 1 state machine</div><div class="ttdef"><b>Definition:</b> mc_api.c:760</div></div>
<div class="ttc" id="agroup___m_c_interface_html_gaf9c63cc62b4961a5e4ae805cac0abf0c"><div class="ttname"><a href="group___m_c_interface.html#gaf9c63cc62b4961a5e4ae805cac0abf0c">MCI_State_t</a></div><div class="ttdeci">MCI_State_t</div><div class="ttdoc">State_t enum type definition, it lists all the possible state machine states.</div><div class="ttdef"><b>Definition:</b> mc_interface.h:111</div></div>
</div><!-- fragment --><p >Returns the current state of the target motor state machine. Refer to Section 5.3.3 for a description of the MC state machine and of the values of the State_t enumerable.</p>
<h2>Motor control low-level API</h2>
<p >The low-level application programming interface provided by the MC firmware allows applications that need finer control over the internals of the MC subsystem. This API consists of all the components that are instantiated to form the subsystem. These components can be addressed by the application thanks to their handles. These handles are defined in the <b><a class="el" href="mc__config_8c.html" title="Motor Control Subsystem components configuration and handler structures.">mc_config.c</a></b> file and can be accessed by including the <b><a class="el" href="mc__config_8h.html" title="Motor Control Subsystem components configuration and handler structures declarations.">mc_config.h</a></b> file. For more information, see the STM32 MC SDK reference manual delivered with the SDK. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
